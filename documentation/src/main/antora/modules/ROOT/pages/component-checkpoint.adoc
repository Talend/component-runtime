= Checkpointing
:page-partial:
:description: How to develop a checkpointing producer with Talend Component Kit
:keywords: component type, producer, emitter, input, checkpoint, bookmark



= Checkpointing in Talend Component Kit

== Introduction
Checkpointing is a new feature in the Talend Component Kit (TCK) that enables an input connector to resume processing from the last recorded checkpoint. This ensures fault tolerance and better handling of large data streams by avoiding reprocessing from the beginning in case of failures.

== Checkpointing Mechanism
Checkpointing in TCK is implemented using specific annotations and an interface that defines the required methods. The checkpointing mechanism allows the runtime to save and restore processing states efficiently.

=== Checkpointing Annotations

`@CheckpointData`: This annotation marks a method that returns a checkpoint object based on the type of data being processed.

`@CheckpointAvailable`: This annotation marks a method that indicates when a new checkpoint (or bookmark) is available.

`@Checkpoint`: This annotation is used to mark a class as a checkpointing configuration class. It can specify:

- The method type used for checkpointing.

- The checkpointing frequency.

=== Connector Implementation
To support checkpointing, the input component used in the lifecycle implement the following interface:

[source,java]
----
public interface Input extends Lifecycle {

...

default void start(final Consumer<Object> checkpointCallback) {
    throw new IllegalArgumentException("Checkpoint feature is not implemented.");
}

default Object getCheckpoint() {
    throw new IllegalArgumentException("Checkpoint feature is not implemented.");
}

default Boolean isCheckpointReady() {
    throw new IllegalArgumentException("Checkpoint feature is not implemented.");
}
----

The start() method is called with a callback function that retrieves and serializes the checkpoint object. The getCheckpoint() method returns the checkpoint object, and isCheckpointReady() checks if a checkpoint is available.

Those methods are frontend methods for connectors' methods annotated with `@CheckpointAvailable`, and `@Checkpoint`.



== Checkpointing Usage Scenarios
At runtime, checkpointing can be used in two ways:

=== 1. Explicit Runtime Usage
In this mode, the runtime directly calls the methods of the input connector to manage checkpointing. It is responsible for:

- Determining when to create a checkpoint.

- Checking if a checkpoint is available using `isCheckpointReady()`.

- Retrieving and storing the checkpoint using `getCheckpoint()`.

[source,java]
----


----


=== 2. Automatic Mode
In this mode, checkpointing is handled automatically during the lifecycle:

The `start()` method is called with a callback function that retrieves and serializes the checkpoint object.

While reading records (`next()` method), the connector checks whether a checkpoint can be provided.

If necessary, the checkpoint is generated by calling `getCheckpoint()`, which internally calls the method annotated with `@CheckpointData`.


== How to resume

 As state previously, checkpoints are configured via the `@Checkpoint` annotated configuration class. The `@Checkpoint` annotation can be used to specify the method type used for checkpointing and the checkpointing frequency. The checkpointing frequency can be set to `RECORD` or `TIME`. The `RECORD` frequency saves the checkpoint after processing a certain number of records, while the `TIME` frequency saves the checkpoint after a certain time interval.

When the component is restarted, the runtime calls the `start()` method. The connector then retrieves the checkpoint object and resumes processing from the last saved state from the configuration.



== Conclusion
The checkpointing feature in TCK improves resilience by allowing input connectors to resume from the last saved state. By leveraging annotations and the input interface, developers can integrate checkpointing seamlessly into their components, ensuring efficient and fault-tolerant data processing.