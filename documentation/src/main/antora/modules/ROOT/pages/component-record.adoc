= Improve Record API to add error info for invalid entries
:page-partial:
:description: How to develop a connector to handle errors in records with Talend Component Kit
:keywords: component type, producer, emitter, input, record, bookmark


== Introduction
When we create TCK/Record, in some use case, first with quality applications, we have to return a record even when there is an issue in retrieved value.

For instance, in an Excel file, when the 'A' column is identified as a 'date', and so the related entry as DATETIME type in the schema, there can be an excel cell that contains a String. Currently, it throws an exception. Quality application has to get a record to be able to present the value in error.

We improve the TCK record api to be able to set the entry of a record in error and retrieve a fallback value (the value that has been retrieved but that was inconsistent with the schema) and an error message.

This mechanism should be disengageable to maintain the current behavior that throws an exception (maybe using java property or a parameter in the record builderï¼Œ switch between withError or not: means throw exception or not.

IMPORTANT: The feature is disabled by default, to use it, you need to add a system property *`talend.component.record.error.support`*  in the runtime jvm like this:

```
-Dtalend.component.record.error.support=true
```


== Mechanism
Checkpointing in TCK is implemented using specific annotations and an interface that defines the required methods. .

=== Connector Implementation
To support it, the input component used in the lifecycle should call the following interface:

[source,java]
----
public interface Input extends Lifecycle {

...
 final Schema schema = new SchemaImpl.BuilderImpl()
                .withType(Schema.Type.RECORD)
                .withEntry(new SchemaImpl.EntryImpl.BuilderImpl()
                        .withName("age")
                        .withNullable(false)
                        .withType(Type.INT)
                        .withErrorCapable(true) // The entry accept wrong values without raising exception
                        .build())
                .build();
        // The schema is built and is immutable

        String value = "12";

        RecordImpl.BuilderImpl builder = new RecordImpl.BuilderImpl(schema);
        Entry ageEntry = schema .getEntry("age");
        builder.with(ageEntry, value);

        // If an error is identified when the value is given to the with(Entry, Object) method
        // The entry in error is updated with some properties:
        // entry.withProp(SchemaProperty.ENTRY_IS_ON_ERROR, "true")
        // entry.withProp(SchemaProperty.ENTRY_ERROR_MESSAGE, errorMessage): error message genetated by the with(Entry, Object) method
        // entry.withProp(SchemaProperty.ENTRY_ERROR_FALLBACK_VALUE, stringFallbackValue): The string representation of the given value

        Record record = builder.build();

        Entry ageEntry = record..getSchema().getEntry("age");
        if(ageEntry.isValid()) {
            Integer age = record.get(Integer.class, "age");
            //  process the age...
        }
        else{
            String errorMessage = ageEntry.getErrorMessage();
            String errorFallbackValue = ageEntry.getErrorFallbackValue();
            // Do something with the error value
            Integer age = record.get(Integer.class, "age"); // returns null since no valid value was set
        }

 ----

== Conclusion
This feature will not interrupt the data processing even with some invalid values. It is important for the whole progress.
And the invalid values can be handled after records were build.