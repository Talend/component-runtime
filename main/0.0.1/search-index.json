[{"lang":"en","title":"Advanced: define a custom API","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/services-custom-api.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Advanced: define a custom API"],"lvl1":["Extending the UI"],"text":["It is possible to extend the Component API for custom front features.","What is important here is to keep in mind you should do it only if it targets not portable components (only used by the Studio or Beam).","In term of organization it is recommanded to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI just add an annotation which can be put on @Option fields which is decorated with @Ui. All its members will be put in the metadata of the parameter. Example:"]},{"lang":"en","title":"Beam testing","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/testing-beam.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Beam testing"],"text":["If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don’t want to use spark).","Check beam.apache.org/contribute/testing/ out for more details."]},{"lang":"en","title":"Best practises","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/testing-best-practices.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Best practises"],"lvl1":["Parameterized tests"],"lvl2":["JUnit 4","JUnit 5"],"text":["this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG as well, check out the documentation if you need to use TestNG.","This is a great solution to repeat the same test multiple times. Overall idea is to define a test scenario (I test function F) and to make the input/output data dynamic.","Here is an example. Let’s assume we have this test which validates the connection URI using ConnectionService:","We clearly identify the test method is always the same except the value. It can therefore be rewritter using JUnit Parameterized runner like that:","you don’t have to define a single @Test method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)","JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:","However you can still use the previous behavior using a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.","don’t forget to add junit-jupiter-params dependency to benefit from this feature."]},{"lang":"en","title":"Built in services","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/services-built-in.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Built in services"],"lvl1":["HttpClient usage"],"lvl2":["Advanced HTTP client request customization"],"text":["The framework provides some built-in services you can inject by type in components and actions out of the box.","Here is the list:","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data which don’t need to be recomputed very often. Commonly used by actions for the UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommanded to use this one instead of a custom one for memory/speed optimizations.","it assumes the dependency is locally available to the execution instance which is not guaranteed yet by the framework.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration which can be used during the design.","it is not recommanded to use it for the runtime since the local configuration is generally different and the instances are distincts.","you can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","This let you define an http client in a declarative manner using an annotated interface.","See the HttpClient usage for details.","Let assume that we have a REST API defined like below, and that it requires a basic authentication header.","GET /api/records/{id}","-","POST /api/records","with a json playload to be created {\"id\":\"some id\", \"data\":\"some data\"}","To create an http client able to consume this REST API, we will define an interface that extends HttpClient,","The HttpClient interface lets you set the base for the http address that our client will hit.","The base is the part of the address that we will need to add to the request path to hit the api.","Every method annotated with @Request of our interface will define an http request. Also every request can have @Codec that let us encode/decode the request/response playloads.","if your payload(s) is(are) String or Void you can ignore the coder/decoder.","The interface should extends HttpClient.","In the codec classes (class that implement Encoder/Decoder) you can inject any of your services annotated with @Service or @Internationalized into the constructor. The i18n services can be useful to have i18n messages for errors handling for example.","This interface can be injected into our Components classes or Services to consume the defined api.","Note: by default /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases you can customize the Connection directly using @UseConfigurer on the method. It will call your custom instance of Configurer. Note that you can use some @ConfigurerOption in the method signature to pass some configurer configuration.","For instance if you have this configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:"]},{"lang":"en","title":"Component Loading","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/component-loading.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Component Loading"],"lvl1":["Packaging a plugin","Packaging an application"],"lvl2":["Dependencies","Listing needed plugins","maven-shade-plugin extensions"],"lvl3":["Create a nested maven repository with maven-shade-plugin","ContainerDependenciesTransformer","PluginTransformer"],"text":["Talend Component scanning is based on a plugin concept. To ensure plugins can be developped in parallel and avoid conflicts it requires to isolate plugins (components or component grouped in a single jar/plugin).","Here we have multiple options which are (high level):","flat classpath: listed for completeness but rejected by design because it doesn’t match at all this requirement.","tree classloading: a shared classloader inherited by plugin classloaders but plugin classloader classes are not seen by the shared classloader nor by other plugins.","graph classloading: this one allows you to link the plugins and dependencies together dynamically in any direction.","If you want to map it to concrete common examples, the tree classloading is commonly used by Servlet containers where plugins are web applications and the graph classloading can be illustrated by OSGi containers.","In the spirit of avoiding a lot of complexity added by this layer, Talend Component relies on a tree classloading. The advantage is you don’t need to define the relationship with other plugins/dependencies (it is built-in).","Here is a representation of this solution:","","The interesting part is the shared area will contain Talend Component API which is the only (by default) shared classes accross the whole plugins.","Then each plugins will be loaded in their own classloader with their dependencies.","this part explains the overall way to handle dependecnies but the Talend Maven plugin provides a shortcut for that.","A plugin is just a jar which was enriched with the list of its dependencies. By default Talend Component runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt location so you just need to ensure your component defines the following plugin:","If you check your jar once built you will see that the file contains something like:","What is important to see is the scope associated to the artifacts:","the API (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (it comes with the framework)","your specific dependencies (awesome-project) is compile: it will be included as a needed dependency by the framework (note that using runtime works too).","the other dependencies will be ignored (test dependencies)","Even if a flat classpath deployment is possible, it is not recommanded because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local maven repository layout. As a quick reminder it looks like:","This is all the layout the framework will use. Concretely the logic will convert the t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component runtime has two ways to find an artifact:","from the file system based on a configure maven 2 repository.","from a fatjar (uber jar) with a nested maven repository under MAVEN-INF/repository.","The first option will use either - by default - ${user.home}/.m2/repository or a specific path configured when creating a ComponentManager. The nested repository option will need some configuration during the packaging to ensure the repository is well created.","To create the nested MAVEN-INF/repository repository you can use nested-maven-repository extension:","Plugin are programmatically registered in general but if you want to make some of them automatically available you need to generate a TALEND-INF/plugins.properties which will map a plugin name to coordinates found with the maven mecanism we just talked about.","Here again we can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven shade plugin:","the configuration unrelated to transformers can depend your application.","ContainerDependenciesTransformer is the one to embed a maven repository and PluginTransformer to create a file listing (one per line) a list of artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma separated list of scope to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system, test).","include: a comma separated list of artifact to include in the artifact filtering.","exclude: a comma separated list of artifact to exclude in the artifact filtering.","userArtifacts: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline - mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included, true by default.","includeProjectComponentDependencies: should project component dependencies be included, false by default (normally a job project uses isolation for components so this is not needed).","userArtifacts: set of component artifacts to include.","to use with the component tooling, it is recommended to keep default locations. Also if you feel you need to use project dependencies, you can need to refactor your project structure to ensure you keep component isolation. Talend component let you handle that part but the recommended practise is to use userArtifacts for the components and not the project <dependencies>.","ContainerDependenciesTransformer specific configuration is the following one:","repositoryBase: base repository location (default to MAVEN-INF/repository).","ignoredPaths: a comma separated list of folder to not create in the output jar, this is common for the ones already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties`).","Example: if you want to list only the plugins you use you can configure this transformer like that:"]},{"lang":"en","title":"Configuring components","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/component-configuration.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Configuring components"],"lvl1":["Primitives","Complex object mapping","Constraints and validation on the configuration/input","Marking a configuration as a particular type of data","Define links between properties","Add hints about the rendering based on configuration/component knowledge"],"lvl2":["List case","Map case"],"text":["Component are configured through their constructor parameters. They can all be marked with @Option which will let you give a name to parameters (if not it will use the bytecode name which can require you to compile with -parameter flag to not have arg0, arg1, … as names).","The parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","it is recommanded to use simple models which can be serialized by components to avoid headaches when implementing serialized components.","Here is an example:","Using this kind of API makes the configuration extensible and component oriented letting the user define all he needs.","The instantiation of the parameters is done from the properties passed to the component (see next part).","What is considered as a primitive in this mecanism is a class which can be directly converted from a String to the expected type.","It obviously includes all java primitives, String type itself but also all the types with a org.apache.xbean.propertyeditor.Converter.","This includes out of the box:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","The conversion from properties to object is using the dotted notation. For instance:","will match","assuming the method parameter was configured with @Option(\"file\").","Lists use the same syntax but to define their elements their rely on an indexed syntax. Assuming the list parameter is named files and the elements are of FileOptions type, here is how to define a list of 2 elements:","Inspired from the list case, the map uses .key[index] and .value[index] to represent its key and values:","don’t abuse of map type. If not needed for your configuration (= if you can configure your component with an object) don’t use it.","It is common to need to add as metadata a field is required, another has a minimum size etc. This is done with the validation in org.talend.sdk.component.api.configuration.constraint package:","API","Name","Parameter Type","Description","Supported Types","Metadata sample","@org.talend.sdk.component.api.configuration.constraint.Max","maxLength","double","Ensure the decorated option size is validated with a higher bound.","CharSequence","{\"validation::maxLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minLength","double","Ensure the decorated option size is validated with a lower bound.","CharSequence","{\"validation::minLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Pattern","pattern","string","Validate the decorated string with a java pattern, you can use xregex library in javascript.","CharSequence","{\"validation::pattern\":\"test\"}","@org.talend.sdk.component.api.configuration.constraint.Max","max","double","Ensure the decorated option size is validated with a higher bound.","Number, int, short, byte, long, double, float","{\"validation::max\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","min","double","Ensure the decorated option size is validated with a lower bound.","Number, int, short, byte, long, double, float","{\"validation::min\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Required","required","-","Mark the field as being mandatory.","Object","{\"validation::required\":\"true\"}","@org.talend.sdk.component.api.configuration.constraint.Max","maxItems","double","Ensure the decorated option size is validated with a higher bound.","Collection","{\"validation::maxItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minItems","double","Ensure the decorated option size is validated with a lower bound.","Collection","{\"validation::minItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Uniques","uniqueItems","-","Ensure the elements of the collection must be distinct (kind of set).","Collection","{\"validation::uniqueItems\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","It is common to classify the incoming data. You can see it as tagging them in several types. The most common ones are the:","datastore: all the data you need to connect to the backend","dataset: a datastore coupled with all the data you need to execute an action","API","Type","Description","Metadata sample","org.talend.sdk.component.api.configuration.type.DataSet","dataset","Mark a model (complex object) as being a dataset.","{\"tcomp::configurationtype::type\":\"dataset\",\"tcomp::configurationtype::name\":\"test\"}","org.talend.sdk.component.api.configuration.type.DataStore","datastore","Mark a model (complex object) as being a datastore (connection to a backend).","{\"tcomp::configurationtype::type\":\"datastore\",\"tcomp::configurationtype::name\":\"test\"}","the component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","Those configuration types can be composed to provide one configuration item. For example a dataset type will often need a datastore type to be provided. and a datastore type (that provides the connection information) will be used to create a dataset type.","Those configuration types will also be used at design time to create shared configuration that can be stored and used at runtime.","For example, we can think about a relational database that support JDBC:","A datastore may provide:","jdbc url, username, password","A dataset may be:","datastore (that will provide the connection data to the database)","table name, data []","The component server will scan all those configuration types and provide a configuration type index. This index can be used for the integration into the targeted platforms (studio, web applications…)","The configuration type index is represented as a flat tree that contains all the configuration types represented as nodes and indexed by their ids.","Also, every node can point to other nodes. This relation is represented as an array of edges that provide the childes ids.","For example, a configuration type index for the above example will be:","It can be needed to define a binding between properties, a set of annotations allows to do it:","API","Name","Description","Metadata Sample","@org.talend.sdk.component.api.configuration.condition.ActiveIf","if","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","{\"condition::if::target\":\"test\",\"condition::if::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.condition.ActiveIfs","ifs","Allows to set multiple visibility conditions on the same property.","{\"condition::if::value::0\":\"value1,value2\",\"condition::if::value::1\":\"SELECTED\",\"condition::if::target::0\":\"sibling1\",\"condition::if::target::1\":\"../../other\"}","Target element location is specified as a relative path to current location using Unix path characters. Configuration class delimiter is /. Parent configuration class is specified by ... Thus ../targetProperty denotes a property, which is located in parent configuration class and has name targetProperty.","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","In some case it can be needed to add some metadata about the configuration to let the UI render properly the configuration. A simple example is a password value must be hidden and not a simple clear input box. For these cases - when the component developper wants to influence the UI rendering - you can use a particular set of annotations:","API","Description","Generated property metadata","@org.talend.sdk.component.api.configuration.ui.DefaultValue","Provide a default value the UI can use - only for primitive fields.","{\"ui::defaultvalue::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.OptionsOrder","Allows to sort a class properties.","{\"ui::optionsorder::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Request the rendered to do what it thinks is best.","{\"ui::autolayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","{\"ui::gridlayout::value1::value\":\"first","second,third\",\"ui::gridlayout::value2::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","{\"ui::gridlayout::Advanced::value\":\"another\",\"ui::gridlayout::Main::value\":\"first","second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI an horizontal layout is preferred.","{\"ui::horizontallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","{\"ui::verticallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being represented by some code widget (vs textarea for instance).","{\"ui::code::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a credential. It is typically used to hide the value in the UI.","{\"ui::credential\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a List<String> or Map<String, String> field as being represented as the component data selector (field names generally or field names as key and type as value).","{\"ui::structure::type\":\"null\",\"ui::structure::discoverSchema\":\"test\",\"ui::structure::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.TextArea","Mark a field as being represented by a textarea(multiline text input).","{\"ui::textarea\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","target support should cover org.talend.core.model.process.EParameterFieldType but we need to ensure web renderers is able to handle the same widgets."]},{"lang":"en","title":"Create an input component","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/tutorial-create-an-input-component.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Create an input component"],"lvl1":["The component family registration","The component configuration","The Partition Mapper","The Producer (Source)"],"lvl2":["The constructor","The PostConstruct method","The PreDestroy method","The Assessor method","The Split method","The Emitter method","The full implementation of the Partition Mapper"],"text":["In this tutorial we will create a complete working input component for hazelcast.","This will include :","The component family registration.","The component configuration and the UI layout","The partition mapper that let the input split it self to work in a distributed environment.","The source that is responsible for connecting and reading data from the data source.","Getter and Setter methods are omitted for simplicity in this tutorial","We register the component family via a the package-info.java file in the package of the component.","The component configuration define the configurable part of the component in addition to the configuration type and the UI layout. The configuration is a simple POJO class decorated with annotations from the component framework. Here is the configuration of our component, that we will explain in details.","Read more about the component configuration…","As our component need to work first in distributed environments. Every input component has to define a partition mapper that will be responsible of calculating the number of sources to be created according to the hole dataset size and the requested bundle size by the targeted runner.","Let’s first start examining the skeleton of our partition mapper. Then we will implement every method one by one.","Now that we know what we need to implement and why. Let’s start coding those methods one by one.","Here is the HazelcastService implementation. Every class annotated with @Service can be injected to the component via it’s constructor.","Here is the implementation of the two methods used above","Here is the full code source for the partition mapper to have a global view of it. Read more about partition mapper…","Now that we have setup our component configuration and written our partition mapper that will create our producers. Let implement the source logic that will use the configuration provided by the mapper to read the records from the data source. To implement a source we need to implement the producer method that will produce a record every time it’s invoked.","Read more about source …","We have seen how to create a complete working input in this tutorial. In the next one we will explain how to create some unit tests for it."]},{"lang":"en","title":"Creating a job pipeline","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/services-pipeline.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Creating a job pipeline"],"lvl1":["Job Builder","Beam case"],"lvl2":["I/O","Processors","Deployment","Convert a Beam.io in a component I/O"],"lvl3":["Environment/Runner","Key Provider"],"text":["The Job builder let you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, so you can built complex pipelines.","Let’s take a simple use case where we will have 2 data source (employee and salary) that we will format to csv and write the result to a file.","The URI follow the form : [family]://[component][?version][&configuration]","family: the name of the component family","component: the name of the component","version : the version of the component, it’s represented in a key=value format. where the key is __version and the value is a number.","configuration: here you can provide the component configuration as key=value tuple. where the key is the path of the configuration and the value is the configuration value in string format.","configuration parameters must be URI/URL encoded.","You can also connect a specific branch of a component if it has multiple or named inputs/outputs branches using the methods from(id, branchName) → to(id, branchName).","In the example above, the concat component have to inputs (string1 and string2).","It has some starting components (component that don’t have a from connection and that need to be of type producer).","There is no cyclic connections. as the job pipeline need to be an acyclic graph.","All the components used in connections are already declared.","The connection is used only once. you can’t connect a component input/output branch twice.","In this version, the execution of the job is linear. the component are not executed in parallel even if some steps may be independents.","Depending the configuration you can select which environment you execute your job in.","To select the environment the logic is the following one:","if an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder is passed through the job properties then use it (supported type are a ExecutionBuilder instance, a Class or a String).","if an ExecutionBuilder SPI is present then use it (it is the case if component-runtime-beam is present in your classpath).","else just use a local/standalone execution.","In the case of a Beam execution you can customize the pipeline options using system properties. They have to be prefixed by talend.beam.job.. For instance to set appName option you will set -Dtalend.beam.job.appName=mytest.","The job builder let you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job","If the incoming data has different ids you can provide a complex global key provider relaying on the context that give you the component id and the branch Name.","For beam case, you need to rely on beam pipeline definition and use component-runtime-beam dependency which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and integrate it in the pipeline.","The multiple inputs/outputs are represented by a Map element in beam case to avoid to use multiple inputs/outputs.","you can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, so a kind of Map<String, List<?>>, but materialized as a JsonObject. Input data must be of type JsonObject in this case.","Beam serializing components it is crucial to add component-runtime-standalone dependency to the project. It will take care of providing an implicit and lazy ComponentManager managing the component in a fatjar case.","For simple I/O you can get automatic conversion of the Beam.io to a component I/O transparently if you decorated your PTransform with @PartitionMapper or @Processor.","The limitation are:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and just register on the input PCollection a DoFn.","More information on that topic on How to wrap a Beam I/O page."]},{"lang":"en","title":"Gallery","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/gallery.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Gallery"],"lvl1":["Widgets","Validations"],"text":["Name","Code","Studio Rendering","Web Rendering","Input/Text","Password","Textarea","Checkbox","List","Table","Code","Schema","Name","Code","Studio Rendering","Web Rendering","Property validation","Data store validation"]},{"lang":"en","title":"Generate a project using the component starter","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/tutorial-generate-project-using-starter.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Generate a project using the component starter"],"lvl1":["Project configuration","Create an input component","Create a Processor component","Create an Output component","Generate and download the final project.","Compile and explore the generated project files"],"text":["The component starter let you design your components configuration and generate a ready to implement project structure.","In this tutorial, we will use the component starter to generate some components for MySQL database.","Choose your favorite build tool. we will use maven in this tutorial but you can select gradle if you prefer.","We add the test facet to get some unit tests generated automatically for the component that we will create after.","Complete the component description (family, and category).","Complete the project metadata. the groupId, ArtifactId and the package.","Click ADD A COMPONENT button to start designing your components.","Let’s create an input component that will connect to a MySQL database, execute a SQL query and get the result.","We choose the component type. INPUT in this case.","Give the component a cool name. MySQLInput is good enough.","This button will let us create the required configuration for our component. To be able to execute a SQL query, we will need a connection url, the username and the password for the database and the SQL query to be executed. Click the (+) button on the right to add a field and chose it type.","Our component will be an ordinary (non streaming) component. so just let this toggle button off.","Here we define the record type that this component will produce. we let it generic for now. as our component will generate some json records. You can also choose a custom type to define a POJO that will represent your records.","In this step we will create a very simple processor component that will receive a record, log it and return it at is.","Choose the component type. PROCESSOR/OUTPUT in this case.","Give an explicit name to the component. RecordLogger, as our processor will log the records.","This is the configuration button. this component don’t need any configuration. so we just skip this step.","Here we define the inputs of the component. so click ADD INPUT button to create an input. In this component we will have only one input that will receive the record to be log.","click the input name to access it configuration. you can change the name and define the record model. Here we will use a generic record. otherwise you can use a POJO to represent the record.","Click ADD OUTPUT to create an output for this processor. we will need only one output as our logger only emit the received record. NOTE: the outputs are also configurable in the same way as the inputs (as explained in 5).","Now we will create an output component that will receive a record and insert it into a database table.","Output components are Processors without outputs. In other words, the output is a processor that don’t produce any records.","Choose the component type. PROCESSOR/OUTPUT in this case.","Give the component a name. MySQLOutput","Create the component configuration. in this case we will need the connection url, the credentials of the database and the table name to insert the record in.","Like what we have done for the processor component above. we add an input","We make our input generic as we want to handle generic records in this component.","We don’t create any outputs for this component as it will not produce any records. this is the only difference betweene an output an a processor.","In the previous steps we have configured a project and created 3 components of different types (input, processor and output). Now click the GO TO FINISH button beside the ADD A COMPONENT button. You will be redirected to a summary page that shows :","Project configuration summary.","The list of the created components at the left panel.","You have two options to get the generated project. Download it locally as a zip file using the DOWNLOAD AS ZIP","Create a github repository and push the project to it using the button CREATE ON GITHUB.","Download the project as a zip to your local machine or clone it if you have created a github project.","As we have created a maven project here, we will use maven command to compile the project. In the project directory we execute the command mvn package","If you don’t have Maven installed on your machine, you can use the maven wrapper provided in the generated project. All you need is to execute the command: ./mvnw package","If you have created a gradle project you can compile with gradle build or use the gradle wrapper ./gradlew build","The generated project code contains documentation that will guide you to implement the component logic. so import the project to your favorite IDE and start implementing coding.","In the next tutorial, we will explain how to implement an Input component in details."]},{"lang":"en","title":"Generating data?","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/testing-generating-data.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Generating data?"],"text":["Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","…","A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:","github.com/devopsfolks/podam","github.com/benas/random-beans","…","Note there are two main kind of implementations:","the one using a pattern and random generated data","a set of precomputed data extrapolated to create new values","Check against your use case to know which one is the best.","an interesting alternative to data generation is to import real data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data) and just inject that file into the system.","If you are using JUnit 5, you can have a look to glytching.github.io/junit-extensions/randomBeans which is pretty good on that topic."]},{"lang":"en","title":"Gradle Plugin","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/build-tools-gradle.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Gradle Plugin"],"text":["gradle-talend-component intends to help you to write components validating components match best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file the SDK uses to build the component classpath. For more information on the configuration you can check out the maven properties matching the attributes.","Here is how to use it:"]},{"lang":"en","title":"Internationalization","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/component-internationalization.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Internationalization"],"lvl1":["Default components keys"],"text":["In the simplest case you should store messages using ResourceBundle properties file in your component module to use internationalization. The location of the properties file should be in the same package as the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties).","Out of the box components are internationalized using the same location logic for the resource bundle and here is the list of supported keys:","Name Pattern","Description","${family}._displayName","the display name of the family","${family}.${configurationType}.${name}._displayName","the display name of a configuration type (dataStore or dataSet)","${family}.${component_name}._displayName","the display name of the component (used by the GUIs)","${property_path}._displayName","the display name of the option.","${simple_class_name}.${property_name}._displayName","the display name of the option using it class name.","${property_path}._placeholder","the placeholder of the option.","Example of configuration for a component named list belonging to the family memory (@Emitter(family = \"memory\", name = \"list\")):","Configuration class are also translatable using the simple class name in the messages properties file. This useful when you have some common configuration shared within multiple components.","If you have a configuration class like :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the config class.","If you have a display name using the property path, it will override the display name defined using the simple class name. this rule apply also to placeholders"]},{"lang":"en","title":"Internationalization","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/services-internationalization.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Internationalization"],"lvl1":["Internationalization API"],"text":["Recommanded practise for internationalization are:","store messages using ResourceBundle properties file in your component module","the location of the properties are in the same package than the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties)","for your own messages use the internationalization API","Overal idea is to design its messages as methods returning String values and back the template by a ResourceBundle located in the same package than the interface defining these methods and named Messages.","this is the mecanism to use to internationalize your own messages in your own components.","To ensure you internationalization API is identified you need to mark it with @Internationalized:"]},{"lang":"en","title":"Mask your configuration sensitive data","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/tutorial-configuration-sensitive-data.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Mask your configuration sensitive data"],"lvl1":["The component configuration","Mark sensitive data"],"text":["In this tutorial we will see how to ensure the sensitive data of a component configuration is correctly handled.","It is very common to define credentials in a component configuration. Most known use cases will be:","Passwords,","Secrets,","Potentially keys (it is also common to show them in plain text in a textarea),","Tokens","To illustrate that we will use a REST client configuration which takes a username, password and token to connect to the REST API:","This simple configuration defines three String without any specific widget so they will be represented as plain inputs.","There are two major consequences you probably want to avoid:","The password and token will be clearly readable in all Talend user interfaces (Studio or Web),","The password and token will be potentially stored in clear.","To solve that, Talend Component Kit provides you @Credential marker you can use on any @Option. This marker will have two effects:","Replace the default input widget by a password oriented one (See widgets gallery for screenshots),","Request the Studio or the Talend Cloud products to store the data as sensitive data (as encrypted values).","To ensure our password and token are never stored in clear or shown in the code we migrate our previous model to the following one:","And that it is! Now your password and token will not be accessible by error anymore :).","Read more about the component configuration…"]},{"lang":"en","title":"Maven Plugin","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/build-tools-maven.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Maven Plugin"],"lvl1":["Dependencies","Validate","Documentation","Web","Generate inputs or outputs","Talend Component Archive"],"lvl2":["Render your documentation"],"lvl3":["HTML","PDF","Include the documentation into a document","More"],"text":["talend-component-maven-plugin intends to help you to write components validating components match best practices and also generating transparently metadata used by Talend Studio.","Here is how to use it:","Note that this plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, dependencies, validate and documentation goals will be set up.","The first goal is a shortcut for the maven-dependency-plugin, it will create the TALEND-INF/dependencies.txt file with the compile and runtime dependencies to let the component use it at runtime:","The most important goal is here to help you to validate the common programming model of the component. Here is the execution definition to activate it:","By default it will be bound to process-classes phase. When executing it will do several validations which can be switched off adding the corresponding flags to false in the <configuration> block of the execution:","Name","Description","Default","validateInternationalization","Validates resource bundle are presents and contain commonly used keys (like _displayName)","true","validateModel","Ensure components pass validations of the ComponentManager and Talend Component runtime","true","validateSerializable","Ensure components are Serializable - note this is a sanity check, the component is not actually serialized here, if you have a doubt ensure to test it. It also checks any @Internationalized class is valid and has its keys.","true","validateMetadata","Ensure components define an @Icon and @Version.","true","validateDataStore","Ensure any @DataStore defines a @HealthCheck.","true","validateComponent","Ensure native programming model is respected, you can disable it when using another programming model like in beam case.","true","validateActions","Validate actions signatures for the ones not tolerating dynamic binding (@HealthCheck, @DynamicValues, …). It is recommanded to keep it true.","true","validateFamily","Validate the family, i.e. the package containing the @Components has also a @Icon.","true","validateDocumentation","Ensure all 1. components and 2. @Option properties have a documentation using @Documentation","true","This goal generates an Asciidoc file documenting your component from the configuration model (@Option) and @Documentation you can put on options and the component itself.","Name","Description","Default","level","Which level are the root title","2 which means ==","output","Where to store the output, it is NOT recommended to change it","${classes}/TALEND-INF/documentation.adoc","formats","A map of the renderings to do, keys are the format (pdf or html) and values the output paths","-","attributes","A map of asciidoctor attributes when formats is set","-","templateDir / templateEngine","Template configuration for the rendering","-","title","Document title","${project.name}","attachDocumentations","Should the documentations (.adoc, and formats keys) should be attached to the project (and deployed)","true","if you use the extension you can add the property talend.documentation.htmlAndPdf and set it to true in your project to automatically get a html and PDF rendering of the documentation.","To render the generated documentation you can use the Asciidoctor Maven plugin (or Gradle equivalent):","Will generate in target/classes/TALEND-INF/documentation.adoc the components documentation.","Will render the documenation as an html file in target/documentation/documentation.html.","ensure to execute it after the documentation generation.","If you prefer a PDF rendering you can configure the following execution in the asciidoctor plugin (note that you can configure both executions if you want both HTML and PDF rendering):","If you want to add some more content or add a title, you can include the generated document into another document using Asciidoc include directive.","A common example is:","This assumes you pass to the plugin the attribute generated_doc, this can be done this way:","This is optional but allows to reuse maven placeholders to pass paths which is quite convenient in an automated build.","You can find more customizations on Asciidoctor website.","Testing the rendering of your component(s) configuration into the Studio is just a matter of deploying a component in Talend Studio (you can have a look to link::studio.html[Studio Documentation] page. But don’t forget the component can also be deployed into a Cloud (web) environment. To ease the testing of the related rendering, you can use the goal web of the plugin:","Then you can test your component going on localhost:8080. You need to select which component form you want to see using the treeview on the left, then on the right the form will be displayed.","The two available configurations of the plugin are serverPort which is a shortcut to change the default, 8080, port of the embedded server and serverArguments to pass Meecrowave options to the server. More on that configuration is available at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","this command reads the component jar from the local maven repository so ensure to install the artifact before using it.","The Mojo generate (maven plugin goal) of the same plugin also embeds a generator you can use to bootstrap any input or output component:","It is intended to be used from the command line (or IDE Maven integration):","For this command to work you will need to just register the plugin:","Component ARchive (.car) is the way to bundle a component to share it in Talend ecosystem. It is a plain Java ARchive (.jar) containing a metadata file and a nested maven repository containing the component and its depenencies.","It will create a .car in your build directory which is shareable on Talend platforms.","Note that this CAR is executable and exposes the command studio-deploy which takes as parameter a Talend Studio home location. Executed it will install the dependencies into the studio and register the component in your instance. Here is a sample launch command:"]},{"lang":"en","title":"Multiple environments for the same tests","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/testing-multiple-envs.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Multiple environments for the same tests"],"lvl1":["JUnit 4","JUnit 5","Provided environments","Configuring environments"],"lvl2":["Advanced usage"],"text":["JUnit (4 or 5) already provides some ways to parameterized tests and execute the same \"test logic\" against several data. However it is not that convenient to test multiple environments.","For instance, with Beam, you can desire to test against multiple runners your code and it requires to solve conflicts between runner dependencies, setup the correct classloaders etc…It is a lot of work!","To simplify such cases, the framework provides you a multi-environment support for your tests.","It is in the junit module and is usable with JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner will execute the test(s) for each defined environments. It means it will run test1 for Env1 and Env2 in previous example.","By default JUnit4 runner will be used to execute the tests in one environment but you can use @DelegateRunWith to use another runner.","JUnit 5 configuration is close to JUnit 4 one:","The main difference is you don’t use a runner (it doesn’t exist in JUnit 5) and you replace @Test by @EnvironmentalTest.","the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments instead of running all tests in each environments sequentially. It means, for instance, that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment setup the contextual classloader to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones, you can use EnvironmentConfiguration to customize the system properties used for that environment:","if you set the system property <environment name>.skip=true then the environment related executions will be skipped.","this usage assumes Beam 2.4.0 is in used and the classloader fix about the PipelineOptions is merged.","Dependencies:","These dependencies brings into the test scope the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit.","Then using the fluent DSL to define jobs - which assumes your job is linear and each step sends a single value (no multi-input/multi-output), you can write this kind of test:","It will execute the chain twice:","with a standalone environment to simulate the studio","with a beam (direct runner) environment to ensure the portability of your job"]},{"lang":"en","title":"Providing some actions for consumers/clients","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/services-actions.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Providing some actions for consumers/clients"],"lvl1":["Particular action types"],"text":["In some cases you will desire to add some actions unrelated to the runtime. A simple example is to enable clients - the users of the plugin/library - to test if a connection works. Even more concretely: does my database is up?.","To do so you need to define an @Action which is a method with a name (representing the event name) in a class decorated with @Service:","services are singleton so if you need some thread safety ensure they match that requirement. They shouldn’t store any state too (state is held by the component) since they can be serialized any time.","services are usable in components as well (matched by type) and allow to reuse some shared logic like a client. Here is a sample with a service used to access files:","service is passed to constructor automatically, it can be used as a bean. Only call of service’s method is required.","Some actions are that common and need a clear contract so they are defined as API first citizen, this is the case for wizards or healthchecks for instance. Here is the list of all actions:","API","Type","Description","Return type","Sample returned type","@org.talend.sdk.component.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Values","{\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","HealthCheckStatus","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","@org.talend.sdk.component.api.service.schema.DiscoverSchema","schema","Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with @Discoverable.","Schema","{\"entries\":[{\"name\":\"column1\",\"type\":\"STRING\"}]}","@org.talend.sdk.component.api.service.Action","user","-","any","-","@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","validation","Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can’t use other client side validation to implement it.","ValidationResult","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}"]},{"lang":"en","title":"Registering components","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/component-registering.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Registering components"],"lvl1":["Components metadata"],"lvl2":["Management of configuration versions","@PartitionMapper","@Processor"],"lvl3":["@Emitter"],"text":["As seen in the Getting Started, you need an annotation to register your component through family method. Multiple components can use the same family value but the pair family+name MUST be unique for the system.","If you desire (recommended) to share the same component family name instead of repeating yourself in all family methods, you can use @Components annotation on the root package of you component, it will enable you to define the component family and the categories the component belongs to (default is Misc if not set). Here is a sample package-info.java:","For an existing component it can look like:","Components can require a few metadata to be integrated in Talend Studio or Cloud platform. Here is how to provide these information. These metadata are set on the component class and belongs to org.talend.sdk.component.api.component package.","API","Description","@Icon","Set an icon key used to represent the component. Note you can use a custom key with custom() method but it is not guaranteed the icon will be rendered properly.","@Version","Set the component version, default to 1.","Example:","If some impacting changes happen on the configuration they can be manage through a migration handler at component level (to enable to support trans-model migration).","The @Version annotation supports a migrationHandler method which will take the implementation migrating the incoming configuration to the current model.","For instance if filepath configuration entry from v1 changed to location in v2 you can remap the value to the right key in your MigrationHandler implementation.","it is recommanded to not manage all migrations in the handler but rather split it in services you inject in the migration handler (through constructor):","What is important in this snippet is not much the way the code is organized but rather the fact you organize your migrations the way which fits the best your component. If migrations are not conflicting no need of something fancy, just apply them all but if you need to apply them in order you need to ensure they are sorted. Said otherwise: don’t see this API as a migration API but as a migration callback and adjust the migration code structure you need behind the MigrationHandler based on your component requirements. The service injection enables you to do so.","@PartitionMapper will obviously mark a partition mapper:","@Emitter is a shortcut for @PartitionMapper when you don’t support distribution. Said otherwise it will enforce an implicit partition mapper execution with an assessor size of 1 and a split returning itself.","A method decorated with @Processor will be considered as a producer factory:"]},{"lang":"en","title":"Search","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/search.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Search","Search results"]},{"lang":"en","title":"Secrets/Passwords and Maven","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/testing-maven-passwords.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Secrets/Passwords and Maven"],"text":["If you desire you can reuse your Maven settings.xml servers - including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter will give you the ability to find a server username/password from a server identifier:","It is very useful to not store secrets and test on real systems on a continuous integration platform.","even if you don’t use maven on the platform you can generate the settings.xml and settings-security.xml files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details."]},{"lang":"en","title":"Services and interceptors","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/services-interceptors.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Services and interceptors"],"text":["For common concerns like caching, auditing etc, it can be fancy to use interceptor like API. It is enabled by the framework on services.","An interceptor defines an annotation marked with @Intercepts which defines the implementation of the interceptor (an InterceptorHandler).","Here is an example:","Then handler is created from its constructor and can take service injections (by type). The first parameter, however, can be a BiFunction<Method, Object[], Object> which representes the invocation chain if your interceptor can be used with others.","if you do a generic interceptor it is important to pass the invoker as first parameter. If you don’t do so you can’t combine interceptors at all.","Here is an interceptor implementation for our @Logged API:","This implementation is compatible with interceptor chains since it takes the invoker as first constructor parameter and it also takes a service injection. Then the implementation just does what is needed - logging the invoked method here.","the findAnnotation annotation - inherited from InterceptorHandler is an utility method to find an annotation on a method or class (in this order)."]},{"lang":"en","title":"Talend Component Best Practices","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/best-practices.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Talend Component Best Practices"],"lvl1":["Organize your code","Modelize your configuration","I/O configuration","Processor configuration","I/O recommandations","I/O limitations","Handle UI interactions","Version and component","Don’t forget to test","Contribute to this guide"],"lvl2":["Validations","Completion","Don’t forget the component representation"],"lvl3":["Light validations","Custom validations"],"text":["Few recommandations apply to the way a component packages are organized:","ensure to create a package-info.java with the component family/categories at the root of your component package:","create a package for the configuration","create a package for the actions","create a package for the component and one subpackage by type of component (input, output, processors, …)","It is recommanded to ensure your configuration is serializable since it is likely you will pass it through your components which can be serialized.","The first step to build a component is to identify the way it must be configured.","It is generally split into two main big concepts:","the DataStore which is the way you can access the backend","the DataSet which is the way you interact with the backend","Here are some examples to let you get an idea of what you put in each categories:","Example description","DataStore","DataSet","Accessing a relational database like MySQL","the JDBC driver, url, username and password","the query to execute, row mapper, …","Access a file system","the file pattern (or directory + file extension/prefix/…)","the file format, potentially the buffer size, …","It is common to make the dataset including the datastore since both are required to work. However it is recommanded to replace this pattern by composing both in a higher level configuration model:","Processor configuration is simpler than I/O configuration since it is specific each time. For instance a mapper will take the mapping between the input and output model:","I/O are particular because they can be linked to a set of actions. It is recommanded to wire all the ones you can apply to ensure the consumers of your component can provide a rich experience to their users.","Here are the most common ones:","Type","Action","Description","Configuration example","Action example","DataStore","@Checkable","Expose a way to ensure the datastore/connection works","Until the studio integration is complete, it is recommanded to limit processors to 1 input.","It is also recommanded to provide as much information as possible to let the UI work with the data during its edition.","The light validations are all the validations you can execute on the client side. They are listed in the UI hint part.","This is the ones to use first before going with custom validations since they will be more efficient.","These ones will enforce custom code to be executed, they are more heavy so try to avoid to use them for simple validations you can do with the previous part.","Here you define an action taking some parameters needed for the validation and you link the option you want to validate to this action. Here is an example to validate a dataset. For example for our JDBC driver we could have:","Note that you can also make a class validable and you can use it to validate a form if you put it on your whole configuration:","the parameter binding of the validation method uses the same logic than the component configuration injection. Therefore the @Option specifies the prefix to use to reference a parameter. It is recommanded to use @Option(\"value\") until you know exactly why you don’t use it. This way the consumer can match the configuration model and just prefix it with value. to send the instance to validate.","It can be neat and user friendly to provide completion on some fields. Here an example for the available drivers:","Each component must have its own icon:","you can use talend.surge.sh/icons/ to identify the one you want to use.","Not mandatory for the first version but recommanded: enforce the version of your component.","If you break a configuration entry in a later version ensure to:","upgrade the version","support a migration of the configuration","Testing the components is crucial, you can use unit tests and simple standalone JUnit but it is highly recommanded to have a few Beam tests to ensure your component works in Big Data world.","Don’t hesitate to send your feedback on writing component and best practices you can encounter."]},{"lang":"en","title":"Talend Component Getting Started","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/getting-started.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Talend Component Getting Started"],"lvl1":["Introducing Talend Component","Talend Component System Requirement","Quick Start"],"lvl2":["Dependencies","Inputs","A Processor","An output","Registering our components","Run the quick start example"],"text":["Talend Component intends to simplify the development of connectors at two main levels:","how to inject the specific component code into a job or pipeline. It should unify as much as possible the code required to run in DI and BEAM environments.","unify the code required to be able to render in a browser (web) or the eclipse based Studio (SWT).","Talend Component requires Java 8. You can download it on Oracle website.","To develop a component or the project itself it is recommanded to use Apache Maven 3.5.0. you can download it on Apache Maven website.","For our quick start, we’ll develop three components:","one reading from a file and building Person records","one converting the Person in a User based on the incoming data and conventions","one writing the `User`s in a file","Before we start checking how to implement it, let’s just have a quick look to our data structure (records):","You can note these classes are Serializable. This is mainly for BEAM case but we’ll get back on this point later.","To code a component the only needed dependency is the API:","The inputs often require to open/close a connection and then just work on that connection.","Opening the connection can be done in a method decorated with @PostConstruct:","Now we have a connection we can read records. For our simple case we’ll just read a kind of CSV file containing per row the name and age of a Person. This is done in a method dedicated to read next element which is decorated with @Producer:","if you need to rely on a buffer because you load multiple data at once you can reuse org.talend.sdk.component.api.base.BufferizedProducerSupport class to implement your producer method.","Finally closing the connection once work was done (dataset was completely browsed) can be done in a method decorated with @PreDestroy:","there is another type of input called PartitionMapper which allows to map (in the map/reduce sense) an input but it will be tackled later.","A processor is imply a task taking an input and converting it to another one. In our case it will just take a person and convert it to a user which has a name copied form the person and an id generated from the name and age of the user.","Exactly as the input we just write you can use @PostConstruct and @PreDestroy if you need to do some initializations but a processor also has a particular pair of methods to handle the flow lifecycle: @BeforeGroup and @AfterGroup. This is the same idea but it is to mark smaller chunks of data. It is close to the idea we have of a batch but without any guarantee of the associated size.","it is highly inspired from BEAM bundles.","To get started we don’t need to be so advanced and just need to take a Person and return a User in a method. This can be done decorating a method with @ElementListener:","Now we read our Person, mapped it to a User, we just need to write back the User to another file.","To keep it simple we’ll do the symmetric operation of our input, i.e. writing a kind of CSV file representing the users.","How to implement an output then? An output is just a processor not returning any data.","Same as for our reader, we’ll define an open and close methods to handle the interaction with the output stream:","And the method handling the write will just be an @ElementListener method returning void:","You probably noticed our components have some configuration. Typically the file related components take a File as configuration. To make it work we need to add a factory for these instances which will link the user configuration to the instances.","This is simply done through the component constructor themselves. To instantiate a component, the framework will select the constructor using the most @Option and if not the one with the most parameters.","if your component needs to be serialized (like inputs, processors) don’t forget to ensure you match the java serialization rules like for instance having a protected no-arg constructor if you have a parent which is not Object.","Each type of component has a specific marker annotation taking the name of the component as parameter to declare a component and a component method to declare the name of the component family:","@Emitter for producers (inputs)","@Processor for processors (output or not)","component is a way to group together (logically) components, for instance FlatFile can be used in component and reader/writer as name to have a group of two components related to flat files.","The constructor is responsible to do the link between the configuration and the instance of the component. The configuration is injected through its parameters. Each parameter is marked with @Option which enables you to define a name to the parameter (if not the framework will use the reflection parameter name, ie arg0, arg1, arg2, … if you didn’t activate the -parameters flag at compile time or it will be the actual parameter name otherwise).","The instantiation mechanism will be explained in details later but for this sample we just need to know a File is a valid parameter type.","To run the code we just created you will need the runtime dependency of the framework:","Then you have access to the ComponentManager which handles the research of the components and their instantiation. We’ll dig into the way it finds the plugins later but for our sample we just need to know that using the default constructor the calling jar (the jar containing the Main) will be considered as a plugin if it has some components.","Now we have a component manager, we just need to build our execution chain. For that purpose we can use the ExecutionChainBuilder. This builder provides a DSL enforcing you to configure the job (with a name and if the system properties can override each component configuration), then the input and finally the chain of processors. Once we have that the builder can create a Supplier<ExecutionChain> you can call immediately using get() then execute().","Now if you create a /tmp/input.csv containing:","Then if you run the previous Main you can check there is now a /tmp/output.csv containing as expected:"]},{"lang":"en","title":"Talend Component Javadocs","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/apidocs.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Talend Component Javadocs"],"text":["API Documentation","JUnit API Documentation","HTTP JUnit API Documentation"]},{"lang":"en","title":"Talend Component Kit Changelog","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/changelog.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Talend Component Kit Changelog"],"lvl1":["Version 0.0.1"],"lvl2":["Work Item"],"text":["TCOMP-446: Support Embedded Documentation","TCOMP-650: Ensure component can be executed in beam pipelines","TCOMP-651: Ensure beam components can be wrapped and used through the Talend Component Kit Framework","TCOMP-653: Web Form metamodel service","TCOMP-655: Catalog service","TCOMP-656: UISpec compatibility","TCOMP-658: Add test Source/Sink collectors in JUnit integration","TCOMP-659: Basic job builder API to simplify JUnit tests","TCOMP-662: Validation Mojo","TCOMP-664: Local testing server for dev","TCOMP-675: Select a communication solution for Talend Component Kit server","TCOMP-680: Register components into the Studio Palette","TCOMP-681: Studio parameters form integration","TCOMP-682: Studio Metadata integration","TCOMP-683: Studio Runtime integration","TCOMP-691: Create context menu for Tacokit node in repository panel","TCOMP-719: Support Input Definition","TCOMP-720: Support Output Definition","TCOMP-721: Initial Widget Definitions"]},{"lang":"en","title":"Talend Component REST API Documentation","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/documentation-rest.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Talend Component REST API Documentation"],"lvl1":["HTTP API","Web forms and REST API","Logging","Server Configuration"],"lvl2":["REST resources of Component Runtime :: Server","Deprecated endpoints","WebSocket transport","Use UiSpec model without all the tooling","Javascript integration"],"lvl3":["POST api/v1/action/execute","GET api/v1/action/index","GET api/v1/component/dependencies","GET api/v1/component/dependency/{id}","GET api/v1/component/details","GET api/v1/component/icon/family/{id}","GET api/v1/component/icon/{id}","GET api/v1/component/index","POST api/v1/component/migrate/{id}/{configurationVersion}","GET api/v1/configurationtype/index","POST api/v1/configurationtype/migrate/{id}/{configurationVersion}","GET api/v1/documentation/component/{id}","GET api/v1/environment","POST api/v1/execution/read/{family}/{component}","POST api/v1/execution/write/{family}/{component}"],"text":["The HTTP API intends to expose over HTTP most of Talend Component features, it is a standalone Java HTTP server.","WebSocket protocol is activated for the endpoints as well, instead of /api/v1 they uses the base /websocket/v1, see WebSocket part for more details.","Here is the API:","0.0.1-SNAPSHOT","This endpoint will execute any UI action and serialize the response as a JSON (pojo model). It takes as input the family, type and name of the related action to identify it and its configuration as a flat key value set using the same kind of mapping than for components (option path as key).","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Query Param: action, java.lang.String Query Param: family, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (java.lang.RuntimeException)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","This endpoint returns the list of available actions for a certain falimy and potentially filters the output limiting it to some falimies and types of actions.","No body Query Param: family, java.lang.String Query Param: language, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ActionList)","Returns a list of dependencies for the given components.","don’t forget to add the component itself since it will not be part of the dependencies.","Then you can use /dependency/{id} to download the binary.","No body Query Param: identifier, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.Dependencies)","Return a binary of the dependency represented by id. It can be maven coordinates for dependencies or a component id.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (javax.ws.rs.core.StreamingOutput)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the set of metadata about a few components identified by their 'id'.","No body Query Param: identifiers, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentDetailList)","Response Body: (java.util.Map<java.lang.String, org.talend.sdk.component.server.front.model.error.ErrorPayload>)","Returns a particular family icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns a particular component icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the list of available components.","No body Query Param: includeIconContent, boolean Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentIndices)","Allows to migrate a component configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns all available configuration type - storable models.","No body Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ConfigTypeNodes)","Allows to migrate a configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns an asciidoctor version of the documentation for the component represented by its identifier id.","No body Path Param: id, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.DocumentationContent)","No body","Content-Type: */*","Response Body: (org.talend.sdk.component.server.front.model.Environment)","Read inputs from an instance of mapper. The number of returned records if enforced to be limited to 1000. The format is a JSON based format where each like is a json record.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: size, long","Content-Type: talend/stream","Sends records using a processor instance. Note that the processor should have only an input. Behavior for other processors is undefined. The input format is a JSON based format where each like is a json record - same as for the symmetric endpoint.","Content-Type: talend/stream Request Body: (java.io.InputStream) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: group-size, long","Content-Type: application/json","to ensure the migration can be activated you need to set in the execution configuration you send to the server the version it was created with (component version, it is in component detail endpoint) with the key tcomp::component::version.","If some endpoints are intended to disappear they will be deprecated. In practise it means a header X-Talend-Warning will be returned with some message as value.","You can connect on any endpoint replacing /api by /websocket and appending /<http method> for the URL and formatting the request as:","For instance:","The response is formatted as follow:","if you have a doubt about the endpoint, they are all logged during startup and you can find them in the logs.","If you don’t want to create a pool of connection per endpoint/verb you can use the bus endpoint: /websocket/v1/bus. This endpoint requires that you add the header destinationMethod to each request with the verb value - default would be GET:","component-form library provides a way to build a component REST API facade compatible with react form library.","A trivial facade can be:","the Client can be created using ClientFactory.createDefault(System.getProperty(\"app.components.base\", \"http://localhost:8080/api/v1\")) and the service can be a simple new UiSpecService().","All the conversion between component model (REST API) and uiSpec model is done through the UiSpecService. It is based on the object model which will be mapped to a ui model. The advantage to have a flat model in the component REST API is to make these layers easy to customize.","You can completely control the available components, tune the rendering switching the uiSchema if desired or add/remove part of the form. You can also add custom actions/buttons for specific needs of the application.","the /migrate endpoint has nothing special so was not shown in previous snippet but if you need it you must add it as well.","This maven dependency provides the UISpec model classes. You can use the Ui API (with or without the builders) to create UiSpec representations.","Example:","We extract the JsonSchema from reflection on the class Form1. Note that @JsonSchemaIgnore allows to ignore a field and @JsonSchemaProperty allows to rename a property,","We build programmatically using the builder API a UiSchema,","We pass an instance of the form to let the serializer extracts it JSON model,","We serialize the Ui model which can be used by UiSpec compatible front widgets.","the model uses JSON-B API to define the binding, ensure to have an implementation in your classpath. This can be done adding these dependencies:","Default javascript integration goes through Talend UI Forms library.","It is bundled as a NPM module called component-kit.js. It provides a default trigger implementation for the UIForm.","Here is how to use it:","The logging uses Log4j2, you can specify a custom configuration using the system property -Dlog4j.configurationFile or adding a log4j2.xml file into the classpath.","Here are some common configurations:","Console logging:","This outputs messages looking like:","JSON logging:","Output messages look like:","Rolling file appender","More details are available on RollingFileAppender documentation.","of course you can compose previous layout (message format) and appenders (where logs are written).","The server module contains several configuration you can set in:","Environment variables","System properties","A file located based on the --component-configuration CLI option","the configuration is read from system properties, environment variables, ….","Key","Description","Default","talend.component.server.component.coordinates","A comma separated list of gav to locate the components","-","talend.component.server.component.registry","A property file where the value is a gav of a component to register (complementary with coordinates)","-","talend.component.server.execution.dataset.retriever.timeout","How long the read execution endpoint can last (max)","180","talend.component.server.execution.pool.size","The size of the execution pool for runtime endpoints.","64","talend.component.server.execution.pool.wait","How long the application waits during shutdown for the execution tasks to complete","PT10S","talend.component.server.jaxrs.exceptionhandler.defaultMessage","If set it will replace any message for exceptions. Set to false to use the actual exception message.","false","talend.component.server.maven.repository","The local maven repository used to locate components and their dependencies","${user.home}/.m2/repository","talend.component.server.monitoring.brave.reporter.async","When using url or kafka reporter, you can configure the async reporter with properties passed to this configuration entry.Ex: messageTimeout=5000,closeTimeout=5000.","console","talend.component.server.monitoring.brave.reporter.type","The brave reporter to use to send the spans. Supported values are [auto, console, noop, url]. When configuration is needed,you can use this syntax to configure the repoter if needed: <name>(config1=value1, config2=value2), for example: url(endpoint=http://brave.company.com.","In auto mode, if environment variable TRACING_ON doesn’t exist or is set to false, noop will be selected, and is set to true, TRACING_KAFKA_URL, TRACING_KAFKA_TOPIC and TRACING_SAMPLING_RATE will configure kafka reporter..","auto","talend.component.server.monitoring.brave.sampling.action.rate","The accuracy rate of the sampling for action endpoints.","-1","talend.component.server.monitoring.brave.sampling.component.rate","The accuracy rate of the sampling for component endpoints.","-1","talend.component.server.monitoring.brave.sampling.configurationtype.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.documentation.rate","The accuracy rate of the sampling for documentation endpoint.","-1","talend.component.server.monitoring.brave.sampling.environment.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.execution.rate","The accuracy rate of the sampling for execution endpoints.","1","talend.component.server.monitoring.brave.sampling.rate","The accuracy rate of the sampling.","-1.","talend.component.server.monitoring.brave.service.name","The name used by the brave integration (zipkin)","component-server","talend.component.server.monitoring.documentation.active","Should the /documentation endpoint be activated.","true","talend.component.server.security.command.handler","How to validate a command/request. Accepted values: securityNoopHandler.","securityNoopHandler","talend.component.server.security.connection.handler","How to validate a connection. Accepted values: securityNoopHandler.","securityNoopHandler"]},{"lang":"en","title":"Talend Component Studio Integration","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/studio.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Talend Component Studio Integration"],"lvl1":["Design","Installation","Configuration"],"lvl2":["Random port when running concurrent studio instances"],"text":["The studio integration relies on Component Server (see Web for more details).","When the plugin is deployed it starts a local server the Studio uses to gather data about the components.","Copy org.talend.sdk.component.studio-integration.jar in the $STUDIO_HOME/plugins directory and restart the studio.","Also ensure the component-server dependencies and commons-cli 1.4 are into the Studio maven repository. If you install any component, ensure its dependencies are in the repository as well.","you can set in $STUDIO_HOME/configuration/config.ini the value maven.repository to global to reuse your local maven repository.","The configuration goes into $STUDIO_HOME/configuration/config.ini.","Name","Description","Default","component.debounce.timeout","Specifies timeout in milliseconds before calling listeners in components Text fields","750","component.kit.skip","If true the plugin is not active. Useful if you don’t have any component develop with the framework.","false","component.java.arguments","Component server additional options","-","component.java.m2","The maven repository the server uses to resolve components","default to global Studio configuration","component.java.coordinates","A list of comma separated GAV (groupId:artifactId:version) of components to register","-","component.java.registry","A properties file with values matching component GAV (groupId:artifactId:version) which are registered at startup","-","component.java.port","Set a port to use for the server","random","components.server.beam.active","Active, if set to true, beam support (Experimental). It requires beam sdk java core dependencies to be available.","false","component.server.jul.forceConsole","Adds a console handler to JUL to see logs in the console. This can be helpful in dev since the formatting will be better than the OSGi one in workspace/.metadata/.log.","it uses java.util.logging.SimpleFormatter.format property to define its format. Default is %1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n but for development purposes [%4$s] %5$s%6$s%n is simpler and more readable.","false","to activate the plugin and be able to deploy your component, don’t forget to set component.kit.skip to true.","A common developer configuration/config.ini will use the following specific entries:","If you run multiple Studio instance automatically in parallel you can have some issues with the random port computation (can happen on a CI platform). For that purpose you can create the file $HOME/.talend/locks/org.talend.sdk.component.studio-integration.lock.","When a server will start it will acquire a lock on that file and prevent another one to get a port until it is started. It ensures you can’t get two concurrent processes getting the same allocated port.","it is highly unlikely it happens on a desktop and forcing a different value through component.java.port in your config.ini is likely a better solution for local installations."]},{"lang":"en","title":"Test your components","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/tutorial-test-your-components.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Test your components"],"text":["In a previous tutorial we have created an input component for hazelcast. In this one we will show how to write some unit tests for it.","In this tutorial we will cover :","How to load components in a unit test.","How to create a job pipeline.","How to run the test in standalone mode.","Here is our test class. let’s examine it in details."]},{"lang":"en","title":"Wall of Fame","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/contributors.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Wall of Fame"],"lvl2":["Romain Manni-Bucau","#801 commits","Ivan Gonchar","#188 commits","Anas KHABALI","#135 commits","Chao MENG","#21 commits","Jimmy Somsanith","#9 commits","ypiel","#1 commit"],"text":["Joined the Apache EE family (TomEE, Johnzon, BatchEE...) in 2011. My goal is to make development a detail of an idea becoming reality. Blog: https://rmannibucau.metawerx.net","","I am a software developer at @Talend For my personal projects you can check them @khabali Blog: https://khabali.github.io","R&D","Java and Javascript developer",""]},{"lang":"en","title":"Wrapping a Beam I/O","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/wrapping-a-beam-io.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Wrapping a Beam I/O"],"lvl1":["Limitations","Wrap an input","Wrap an output","Tip","Advanced"],"lvl2":["Coder","Sample"],"text":["This part is limited to particular kinds of Beam PTransform:","the PTransform<PBegin, PCollection<?>> for the inputs","the PTransform<PCollection<?>, PDone> for the outputs. The outputs also must use a single (composite or not) DoFn in their apply method.","Assume you want to wrap an input like this one (based on existing Beam ones):","To wrap the Read in a framework component you create a transform delegating to this one with a @PartitionMapper annotation at least (you likely want to follow the best practices as well adding @Icon and @Version) and using @Option constructor injections to configure the component:","Assume you want to wrap an output like this one (based on existing Beam ones):","You can wrap this output exactly the same way than for the inputs but using @Processor this time:","Note that the class org.talend.sdk.component.runtime.beam.transform.DelegatingTransform fully delegates to another transform the \"expansion\". Therefore you can extend it and just implement the configuration mapping:","In terms of classloading, when you write an IO all the Beam SDK Java core stack is assumed in Talend Component Kit runtime as provided so never include it in compile scope - it would be ignored anyway.","If you need a JSonCoder you can use org.talend.sdk.component.runtime.beam.factory.service.PluginCoderFactory service which gives you access the JSON-P and JSON-B coders.","Here is a sample input based on beam Kafka:","Since the Beam wrapper doesn’t respect the standard Kit programming Model (no @Emitter for instance) you need to set <talend.validation.component>false</talend.validation.component> property in your pom.xml (or equivalent for Gradle) to skip the Kit component programming model validations."]},{"lang":"en","title":"Write an Output component","version":"0.0.1","url":"https://talend.github.io/component-runtime/main/0.0.1/tutorial-create-an-output-component.html","date":"2025-05-27T00:55:02Z","timestamp":1748307302408,"lvl0":["Write an Output component"],"lvl1":["The component configuration","The Output"],"lvl2":["The constructor","The PostConstruct method","The PreDestroy method","The ElementListener method","The full implementation of the Output"],"text":["In this tutorial we will create a complete working output component for hazelcast. This will include :","The component configuration and the UI layout","The output that is responsible for connecting and writing data to the data source.","How to create component configuration has already been described in \"Create an input component\" tutorial. For now we will use the same component configuration. We will only add a couple of fields required for our output component to already described configuration.","We will need those fields to determine key and value attributes for our Hazelcast map.","As our output component needs to work in distributed environments it should implement Serializable interface.","Let’s take a look at the skeleton of our output component.","in real implementation you can desire to bulk write the updates accordingly to groups, see Processor description","Let’s implement all methods required for our output.","We will need Hazelcast instance and Hazelcast map. We add those as attributes to the output. <1> Here we create an instance of hazelcast according to the provided configuration. Here you can notice that we use the injected HazelcastService instance to perform that. This service is implemented in the project. See the implementation in \"Create an input component\" tutorial. <2> We get the Hazelcast map according to the map name from configuration. We use Hazelcast instance for that purpose.","in production you will not want to create one instance per thread/worker but we will cover that in another coming tutorial","We shutdown the instance that we have created in the PostConstruct and we free the Hazelcast map reference.","Here is the full code source for the output to have a global view of it. Read more about output…","We have seen how to create a complete working output in this tutorial. Later we will explain how to create some unit tests for it."]}]