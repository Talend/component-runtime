[{"lang":"en","title":"Advanced: define a custom API","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/services-custom-api.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Advanced: define a custom API","In this article"],"lvl1":["Extending the UI"],"text":["It is possible to extend the Component API for custom front features.","What is important here is to keep in mind you should do it only if it targets not portable components (only used by the Studio or Beam).","In term of organization it is recommended to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI just add an annotation which can be put on @Option fields which is decorated with @Ui. All its members will be put in the metadata of the parameter. Example:"]},{"lang":"en","title":"Beam testing","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/testing-beam.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Beam testing","In this article"],"text":["If you want to ensure your component works in Beam the minimum to do is to try with the direct runner (if you don’t want to use spark).","Check beam.apache.org/contribute/testing/ out for more details."]},{"lang":"en","title":"Best practises","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/testing-best-practices.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Best practises","In this article"],"lvl1":["Parameterized tests"],"lvl2":["JUnit 4","JUnit 5"],"text":["this part is mainly around tools usable with JUnit. You can use most of these techniques with TestNG as well, check out the documentation if you need to use TestNG.","This is a great solution to repeat the same test multiple times. Overall idea is to define a test scenario (I test function F) and to make the input/output data dynamic.","Here is an example. Let’s assume we have this test which validates the connection URI using ConnectionService:","We clearly identify the test method is always the same except the value. It can therefore be rewritter using JUnit Parameterized runner like that:","you don’t have to define a single @Test method, if you define multiple, each of them will be executed with all the data (ie if we add a test in previous example you will get 4 tests execution - 2 per data, ie 2x2)","JUnit 5 reworked this feature to make it way easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference is you can also define inline on the test method that it is a parameterized test and which are the values:","However you can still use the previous behavior using a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is very common to define scenarii.","don’t forget to add junit-jupiter-params dependency to benefit from this feature."]},{"lang":"en","title":"Built in services","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/services-built-in.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Built in services","In this article"],"lvl1":["HttpClient usage"],"lvl2":["Advanced HTTP client request customization"],"text":["The framework provides some built-in services you can inject by type in components and actions out of the box.","Here is the list:","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data which don’t need to be recomputed very often. Commonly used by actions for the UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates.","javax.json.bind.Jsonb","A JSON-B instance. If your model is static and you don’t want to handle the serialization manually using JSON-P you can inject that instance.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommended to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommended to use this one instead of a custom one for memory/speed optimizations.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommended to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommended to use this one instead of a custom one for memory/speed optimizations.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommended to use this one instead of a custom one for memory/speed optimizations.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration which can be used during the design.","it is not recommended to use it for the runtime since the local configuration is generally different and the instances are distincts.","you can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","This let you define an http client in a declarative manner using an annotated interface.","See the HttpClient usage for details.","all these injected instances are serializable which is important for the big data environment, if you create the instances yourself you will not benefit from that features and the memory optimization done by the runtime so try to prefer to reuse the framework instances over custom ones.","Let assume that we have a REST API defined like below, and that it requires a basic authentication header.","GET /api/records/{id}","-","POST /api/records","with a json playload to be created {\"id\":\"some id\", \"data\":\"some data\"}","To create an http client able to consume this REST API, we will define an interface that extends HttpClient,","The HttpClient interface lets you set the base for the http address that our client will hit.","The base is the part of the address that we will need to add to the request path to hit the api.","Every method annotated with @Request of our interface will define an http request. Also every request can have @Codec that let us encode/decode the request/response playloads.","if your payload(s) is(are) String or Void you can ignore the coder/decoder.","The interface should extends HttpClient.","In the codec classes (class that implement Encoder/Decoder) you can inject any of your services annotated with @Service or @Internationalized into the constructor. The i18n services can be useful to have i18n messages for errors handling for example.","This interface can be injected into our Components classes or Services to consume the defined api.","Note: by default /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases you can customize the Connection directly using @UseConfigurer on the method. It will call your custom instance of Configurer. Note that you can use some @ConfigurerOption in the method signature to pass some configurer configuration.","For instance if you have this configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:"]},{"lang":"en","title":"Component Loading","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/component-loading.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Component Loading","In this article"],"lvl1":["Packaging a plugin","Packaging an application","Component scanning rules and default exclusions"],"lvl2":["Dependencies","Listing needed plugins","maven-shade-plugin extensions","Jars Scanning","Package Scanning"],"lvl3":["Create a nested maven repository with maven-shade-plugin","ContainerDependenciesTransformer","PluginTransformer"],"text":["Talend Component scanning is based on a plugin concept. To ensure plugins can be developped in parallel and avoid conflicts it requires to isolate plugins (components or component grouped in a single jar/plugin).","Here we have multiple options which are (high level):","flat classpath: listed for completeness but rejected by design because it doesn’t match at all this requirement.","tree classloading: a shared classloader inherited by plugin classloaders but plugin classloader classes are not seen by the shared classloader nor by other plugins.","graph classloading: this one allows you to link the plugins and dependencies together dynamically in any direction.","If you want to map it to concrete common examples, the tree classloading is commonly used by Servlet containers where plugins are web applications and the graph classloading can be illustrated by OSGi containers.","In the spirit of avoiding a lot of complexity added by this layer, Talend Component relies on a tree classloading. The advantage is you don’t need to define the relationship with other plugins/dependencies (it is built-in).","Here is a representation of this solution:","","The interesting part is the shared area will contain Talend Component API which is the only (by default) shared classes accross the whole plugins.","Then each plugins will be loaded in their own classloader with their dependencies.","this part explains the overall way to handle dependecnies but the Talend Maven plugin provides a shortcut for that.","A plugin is just a jar which was enriched with the list of its dependencies. By default Talend Component runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt location so you just need to ensure your component defines the following plugin:","If you check your jar once built you will see that the file contains something like:","What is important to see is the scope associated to the artifacts:","the API (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (it comes with the framework)","your specific dependencies (awesome-project) is compile: it will be included as a needed dependency by the framework (note that using runtime works too).","the other dependencies will be ignored (test dependencies)","Even if a flat classpath deployment is possible, it is not recommended because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local maven repository layout. As a quick reminder it looks like:","This is all the layout the framework will use. Concretely the logic will convert the t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component runtime has two ways to find an artifact:","from the file system based on a configure maven 2 repository.","from a fatjar (uber jar) with a nested maven repository under MAVEN-INF/repository.","The first option will use either - by default - ${user.home}/.m2/repository or a specific path configured when creating a ComponentManager. The nested repository option will need some configuration during the packaging to ensure the repository is well created.","To create the nested MAVEN-INF/repository repository you can use nested-maven-repository extension:","Plugin are programmatically registered in general but if you want to make some of them automatically available you need to generate a TALEND-INF/plugins.properties which will map a plugin name to coordinates found with the maven mecanism we just talked about.","Here again we can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven shade plugin:","the configuration unrelated to transformers can depend your application.","ContainerDependenciesTransformer is the one to embed a maven repository and PluginTransformer to create a file listing (one per line) a list of artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma separated list of scope to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system, test).","include: a comma separated list of artifact to include in the artifact filtering.","exclude: a comma separated list of artifact to exclude in the artifact filtering.","userArtifacts: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline - mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included, true by default.","includeProjectComponentDependencies: should project component dependencies be included, false by default (normally a job project uses isolation for components so this is not needed).","userArtifacts: set of component artifacts to include.","to use with the component tooling, it is recommended to keep default locations. Also if you feel you need to use project dependencies, you can need to refactor your project structure to ensure you keep component isolation. Talend component let you handle that part but the recommended practise is to use userArtifacts for the components and not the project <dependencies>.","ContainerDependenciesTransformer specific configuration is the following one:","repositoryBase: base repository location (default to MAVEN-INF/repository).","ignoredPaths: a comma separated list of folder to not create in the output jar, this is common for the ones already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties`).","Example: if you want to list only the plugins you use you can configure this transformer like that:","The framework uses two kind of filtering when scanning your component. One based on the jar name and one based on the package name. Ensure your component definitions (including services) are in a scanned module if not registered manually using ComponentManager.instance().addPlugin() and that its package is not excluded.","To find components the framework can scan the classpath but in this case, to avoid to scan the whole classpath which can be really huge an impacts a lot the startup time, several jars are excluded out of the box.","These jars use the following prefix:","ApacheJMeter","FastInfoset","HdrHistogram","HikariCP","PDFBox","RoaringBitmap-","XmlSchema-","accessors-smart","activation-","activeio-","activemq-","aeron","aether-","agrona","akka-","animal-sniffer-annotation","annotation","ant-","antlr-","aopalliance-","apache-el","apacheds-","api-asn1-","api-util-","apiguardian-api-","app-","archaius-core","args4j-","arquillian-","asciidoctorj-","asm-","aspectj","async-http-client-","avalon-framework-","avro-","awaitility-","axis-","axis2-","base64-","batchee-jbatch","batik-","bcpkix","bcprov-","beam-model-","beam-runners-","beam-sdks-","bonecp","bootstrap.jar","brave-","bsf-","build-link","bval","byte-buddy","c3p0-","cache","carrier","cassandra-driver-core","catalina-","catalina.jar","cats","cdi-","cglib-","charsets.jar","chill","classindex","classmate","classutil","classycle","cldrdata","commands-","common-","commons-","component-api","component-form","component-runtime","component-server","component-spi","component-studio","components-api","components-common","compress-lzf","config","constructr","container-core","contenttype","coverage-agent","cryptacular-","cssparser-","curator-","cxf-","daikon","databinding","dataquality","debugger-agent","deltaspike-","deploy.jar","derby-","derbyclient-","derbynet-","dnsns","dom4j","draw2d","ecj-","eclipselink-","ehcache-","el-api","enunciate-core-annotations","error_prone_annotations","expressions","fastutil","feign-core","feign-hystrix","feign-slf4j","filters-helpers","findbugs-","fluentlenium-core","freemarker-","fusemq-leveldb-","gef-","geocoder","geronimo-","gmbal","google-","gpars-","gragent.jar","graph","grizzled-scala","grizzly-","groovy-","grpc-","gson-","guava-","guice-","h2-","hadoop-","hamcrest-","hawtbuf-","hawtdispatch-","hawtio-","hawtjni-runtime","help-","hibernate-","hk2-","howl-","hsqldb-","htmlunit-","htrace-","httpclient-","httpcore-","httpmime","hystrix","iban4j-","icu4j-","idb-","idea_rt.jar","instrumentation-api","istack-commons-runtime-","ivy-","j2objc-annotations","jBCrypt","jaccess","jackson-","janino-","jansi-","jasper-el.jar","jasper.jar","jasypt-","java-atk-wrapper","java-support-","java-xmlbuilder-","javacsv","javaee-","javaee-api","javassist-","javaws.jar","javax.","jaxb-","jaxp-","jbake-","jboss-","jbossall-","jbosscx-","jbossjts-","jbosssx-","jcache","jce.jar","jcip-annotations","jcl-over-slf4j-","jcommander-","jdbcdslog-1","jersey-","jets3t","jettison-","jetty-","jface","jfairy","jffi","jfr.jar","jfxrt.jar","jfxswt","jjwt","jline","jmdns-","jmustache","jna-","jnr-","jobs-","joda-convert","joda-time-","johnzon-","jolokia-","jopt-simple","jruby-","json-","json4s-","jsonb-api","jsoup-","jsp-api","jsr","jsse.jar","jta","jul-to-slf4j-","juli-","junit-","junit5-","jwt","kafka","kahadb-","kotlin-runtime","kryo","leveldb","libphonenumber","lift-json","lmdbjava","localedata","log4j-","logback","logging-event-layout","logkit-","lombok","lucene","lz4","machinist","macro-compat","mail-","management-","mapstruct-","maven-","mbean-annotation-api-","meecrowave-","mesos-","metrics-","mimepull-","mina-","minlog","mockito-core","mqtt-client-","multiverse-core-","mx4j-","myfaces-","mysql-connector-java-","nashorn","neethi-","neko-htmlunit","nekohtml-","netflix","netty-","nimbus-jose-jwt","objenesis-","okhttp","okio","openjpa-","openmdx-","opensaml-","opentest4j-","openwebbeans-","openws-","ops4j-","org.apache.aries","org.apache.commons","org.apache.log4j","org.eclipse.","org.junit.","org.osgi.core-","org.osgi.enterprise","org.talend","orient-commons-","orientdb-core-","orientdb-nativeos-","oro-","osgi","paranamer","pax-url","play","plexus-","plugin.jar","poi-","postgresql","preferences-","prefixmapper","protobuf-","py4j-","pyrolite-","qdox-","quartz-2","quartz-openejb-","reactive-streams","reflectasm-","registry-","resources.jar","ribbon","rmock-","routes-compiler","routines","rt.jar","runners","runtime-","rxjava","rxnetty","saaj-","sac-","scala","scalap","scalatest","scannotation-","selenium","serializer-","serp-","service-common","servlet-api-","servo-","shaded","shrinkwrap-","sisu-guice","sisu-inject","slf4j-","slick","smack-","smackx-","snakeyaml-","snappy-","spark-","specs2","spring-","sshd-","ssl-config-core","stax-api-","stax2-api-","stream","sunec.jar","sunjce_provider","sunpkcs11","surefire-","swagger-","swizzle-","sxc-","system-rules","tachyon-","talend-icon","test-interface","testng-","tomcat","tomee-","tools.jar","twirl","twitter4j-","tyrex","uncommons","unused","validation-api-","velocity-","wagon-","webbeans-","websocket","woodstox-core","workbench","ws-commons-util-","wsdl4j-","wss4j-","wstx-asl-","xalan-","xbean-","xercesImpl-","xml-apis-","xml-resolver-","xmlbeans-","xmlenc-","xmlgraphics-","xmlpull-","xmlrpc-","xmlschema-","xmlsec-","xmltooling-","xmlunit-","xstream-","xz-","zipfs.jar","zipkin-","ziplock-","zkclient","zookeeper-","Since the framework can be used in the case of fatjars or shades, and because it still uses scanning, it is important to ensure we don’t scan the whole classes for performances reason.","Therefore, the following packages are ignored:","avro.shaded","com.codehale.metrics","com.ctc.wstx","com.datastax.driver.core","com.fasterxml.jackson.annotation","com.fasterxml.jackson.core","com.fasterxml.jackson.databind","com.fasterxml.jackson.dataformat","com.fasterxml.jackson.module","com.google.common","com.google.thirdparty","com.ibm.wsdl","com.jcraft.jsch","com.kenai.jffi","com.kenai.jnr","com.sun.istack","com.sun.xml.bind","com.sun.xml.messaging.saaj","com.sun.xml.txw2","com.thoughtworks","io.jsonwebtoken","io.netty","io.swagger.annotations","io.swagger.config","io.swagger.converter","io.swagger.core","io.swagger.jackson","io.swagger.jaxrs","io.swagger.model","io.swagger.models","io.swagger.util","javax","jnr","junit","net.sf.ehcache","net.shibboleth.utilities.java.support","org.aeonbits.owner","org.apache.activemq","org.apache.beam","org.apache.bval","org.apache.camel","org.apache.catalina","org.apache.commons.beanutils","org.apache.commons.cli","org.apache.commons.codec","org.apache.commons.collections","org.apache.commons.compress","org.apache.commons.dbcp2","org.apache.commons.digester","org.apache.commons.io","org.apache.commons.jcs.access","org.apache.commons.jcs.admin","org.apache.commons.jcs.auxiliary","org.apache.commons.jcs.engine","org.apache.commons.jcs.io","org.apache.commons.jcs.utils","org.apache.commons.lang","org.apache.commons.lang3","org.apache.commons.logging","org.apache.commons.pool2","org.apache.coyote","org.apache.cxf","org.apache.geronimo.javamail","org.apache.geronimo.mail","org.apache.geronimo.osgi","org.apache.geronimo.specs","org.apache.http","org.apache.jcp","org.apache.johnzon","org.apache.juli","org.apache.logging.log4j.core","org.apache.logging.log4j.jul","org.apache.logging.log4j.util","org.apache.logging.slf4j","org.apache.meecrowave","org.apache.myfaces","org.apache.naming","org.apache.neethi","org.apache.openejb","org.apache.openjpa","org.apache.oro","org.apache.tomcat","org.apache.tomee","org.apache.velocity","org.apache.webbeans","org.apache.ws","org.apache.wss4j","org.apache.xbean","org.apache.xml","org.apache.xml.resolver","org.bouncycastle","org.codehaus.jackson","org.codehaus.stax2","org.codehaus.swizzle.Grep","org.codehaus.swizzle.Lexer","org.cryptacular","org.eclipse.jdt.core","org.eclipse.jdt.internal","org.fusesource.hawtbuf","org.h2","org.hamcrest","org.hsqldb","org.jasypt","org.jboss.marshalling","org.joda.time","org.jose4j","org.junit","org.jvnet.mimepull","org.metatype.sxc","org.objectweb.asm","org.objectweb.howl","org.openejb","org.opensaml","org.slf4j","org.swizzle","org.terracotta.context","org.terracotta.entity","org.terracotta.modules.ehcache","org.terracotta.statistics","org.tukaani","org.yaml.snakeyaml","serp","it is not recommanded but possible to add in your plugin module a TALEND-INF/scanning.properties file with classloader.includes and classloader.excludes entries to refine the scanning with custom rules. In such a case, exclusions win over inclusions."]},{"lang":"en","title":"Configuring components","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/component-configuration.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Configuring components","In this article"],"lvl1":["Primitives","Complex object mapping","Constraints and validation on the configuration/input","Marking a configuration as a particular type of data","Define links between properties","Add hints about the rendering based on configuration/component knowledge"],"lvl2":["List case","Map case"],"text":["Component are configured through their constructor parameters. They can all be marked with @Option which will let you give a name to parameters (if not it will use the bytecode name which can require you to compile with -parameter flag to not have arg0, arg1, … as names).","The parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","it is recommended to use simple models which can be serialized by components to avoid headaches when implementing serialized components.","Here is an example:","Using this kind of API makes the configuration extensible and component oriented letting the user define all he needs.","The instantiation of the parameters is done from the properties passed to the component (see next part).","What is considered as a primitive in this mecanism is a class which can be directly converted from a String to the expected type.","It obviously includes all java primitives, String type itself but also all the types with a org.apache.xbean.propertyeditor.Converter.","This includes out of the box:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","The conversion from properties to object is using the dotted notation. For instance:","will match","assuming the method parameter was configured with @Option(\"file\").","Lists use the same syntax but to define their elements their rely on an indexed syntax. Assuming the list parameter is named files and the elements are of FileOptions type, here is how to define a list of 2 elements:","Inspired from the list case, the map uses .key[index] and .value[index] to represent its key and values:","don’t abuse of map type. If not needed for your configuration (= if you can configure your component with an object) don’t use it.","It is common to need to add as metadata a field is required, another has a minimum size etc. This is done with the validation in org.talend.sdk.component.api.configuration.constraint package:","API","Name","Parameter Type","Description","Supported Types","Metadata sample","@org.talend.sdk.component.api.configuration.constraint.Max","maxLength","double","Ensure the decorated option size is validated with a higher bound.","CharSequence","{\"validation::maxLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minLength","double","Ensure the decorated option size is validated with a lower bound.","CharSequence","{\"validation::minLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Pattern","pattern","string","Validate the decorated string with a javascript pattern (even into the Studio).","CharSequence","{\"validation::pattern\":\"test\"}","@org.talend.sdk.component.api.configuration.constraint.Max","max","double","Ensure the decorated option size is validated with a higher bound.","Number, int, short, byte, long, double, float","{\"validation::max\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","min","double","Ensure the decorated option size is validated with a lower bound.","Number, int, short, byte, long, double, float","{\"validation::min\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Required","required","-","Mark the field as being mandatory.","Object","{\"validation::required\":\"true\"}","@org.talend.sdk.component.api.configuration.constraint.Max","maxItems","double","Ensure the decorated option size is validated with a higher bound.","Collection","{\"validation::maxItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minItems","double","Ensure the decorated option size is validated with a lower bound.","Collection","{\"validation::minItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Uniques","uniqueItems","-","Ensure the elements of the collection must be distinct (kind of set).","Collection","{\"validation::uniqueItems\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","It is common to classify the incoming data. You can see it as tagging them in several types. The most common ones are the:","datastore: all the data you need to connect to the backend","dataset: a datastore coupled with all the data you need to execute an action","API","Type","Description","Metadata sample","org.talend.sdk.component.api.configuration.type.DataSet","dataset","Mark a model (complex object) as being a dataset.","{\"tcomp::configurationtype::type\":\"dataset\",\"tcomp::configurationtype::name\":\"test\"}","org.talend.sdk.component.api.configuration.type.DataStore","datastore","Mark a model (complex object) as being a datastore (connection to a backend).","{\"tcomp::configurationtype::type\":\"datastore\",\"tcomp::configurationtype::name\":\"test\"}","the component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","Those configuration types can be composed to provide one configuration item. For example a dataset type will often need a datastore type to be provided. and a datastore type (that provides the connection information) will be used to create a dataset type.","Those configuration types will also be used at design time to create shared configuration that can be stored and used at runtime.","For example, we can think about a relational database that support JDBC:","A datastore may provide:","jdbc url, username, password","A dataset may be:","datastore (that will provide the connection data to the database)","table name, data []","The component server will scan all those configuration types and provide a configuration type index. This index can be used for the integration into the targeted platforms (studio, web applications…)","The configuration type index is represented as a flat tree that contains all the configuration types represented as nodes and indexed by their ids.","Also, every node can point to other nodes. This relation is represented as an array of edges that provide the childes ids.","For example, a configuration type index for the above example will be:","It can be needed to define a binding between properties, a set of annotations allows to do it:","API","Name","Description","Metadata Sample","@org.talend.sdk.component.api.configuration.condition.ActiveIf","if","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","{\"condition::if::target\":\"test\",\"condition::if::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.condition.ActiveIfs","ifs","Allows to set multiple visibility conditions on the same property.","{\"condition::if::value::0\":\"value1,value2\",\"condition::if::value::1\":\"SELECTED\",\"condition::if::target::0\":\"sibling1\",\"condition::if::target::1\":\"../../other\"}","Target element location is specified as a relative path to current location using Unix path characters. Configuration class delimiter is /. Parent configuration class is specified by ... Thus ../targetProperty denotes a property, which is located in parent configuration class and has name targetProperty.","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","In some case it can be needed to add some metadata about the configuration to let the UI render properly the configuration. A simple example is a password value must be hidden and not a simple clear input box. For these cases - when the component developper wants to influence the UI rendering - you can use a particular set of annotations:","API","Description","Generated property metadata","@org.talend.sdk.component.api.configuration.ui.DefaultValue","Provide a default value the UI can use - only for primitive fields.","{\"ui::defaultvalue::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.OptionsOrder","Allows to sort a class properties.","{\"ui::optionsorder::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Request the rendered to do what it thinks is best.","{\"ui::autolayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","{\"ui::gridlayout::value1::value\":\"first|second,third\",\"ui::gridlayout::value2::value\":\"first|second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","{\"ui::gridlayout::Advanced::value\":\"another\",\"ui::gridlayout::Main::value\":\"first|second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI an horizontal layout is preferred.","{\"ui::horizontallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","{\"ui::verticallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being represented by some code widget (vs textarea for instance).","{\"ui::code::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a credential. It is typically used to hide the value in the UI.","{\"ui::credential\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a List<String> or Map<String, String> field as being represented as the component data selector (field names generally or field names as key and type as value).","{\"ui::structure::type\":\"null\",\"ui::structure::discoverSchema\":\"test\",\"ui::structure::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.TextArea","Mark a field as being represented by a textarea(multiline text input).","{\"ui::textarea\":\"true\"}","using the programmatic API the metadata are prefixed by tcomp:: but this prefix is stripped in the web for convenience, the previous table uses the web keys.","target support should cover org.talend.core.model.process.EParameterFieldType but we need to ensure web renderers is able to handle the same widgets."]},{"lang":"en","title":"Create an input component","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-create-an-input-component.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Create an input component","In this article"],"lvl1":["The component family registration","The component configuration","The Partition Mapper","The Producer (Source)"],"lvl2":["The constructor","The PostConstruct method","The PreDestroy method","The Assessor method","The Split method","The Emitter method","The full implementation of the Partition Mapper"],"text":["In this tutorial we will create a complete working input component for hazelcast.","This will include :","The component family registration.","The component configuration and the UI layout","The partition mapper that let the input split it self to work in a distributed environment.","The source that is responsible for connecting and reading data from the data source.","Getter and Setter methods are omitted for simplicity in this tutorial","We register the component family via a the package-info.java file in the package of the component.","The component configuration define the configurable part of the component in addition to the configuration type and the UI layout. The configuration is a simple POJO class decorated with annotations from the component framework. Here is the configuration of our component, that we will explain in details.","Read more about the component configuration…","As our component need to work first in distributed environments. Every input component has to define a partition mapper that will be responsible of calculating the number of sources to be created according to the hole dataset size and the requested bundle size by the targeted runner.","Let’s first start examining the skeleton of our partition mapper. Then we will implement every method one by one.","Now that we know what we need to implement and why. Let’s start coding those methods one by one.","Here is the HazelcastService implementation. Every class annotated with @Service can be injected to the component via it’s constructor.","Here is the implementation of the two methods used above","Here is the full code source for the partition mapper to have a global view of it. Read more about partition mapper…","Now that we have setup our component configuration and written our partition mapper that will create our producers. Let implement the source logic that will use the configuration provided by the mapper to read the records from the data source. To implement a source we need to implement the producer method that will produce a record every time it’s invoked.","Read more about source …","We have seen how to create a complete working input in this tutorial. In the next one we will explain how to create some unit tests for it."]},{"lang":"en","title":"Create components for REST API","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-create-components-rest-api.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Create components for REST API","In this article"],"lvl1":["Http client setup","Component Configuration","The component mapper","The component source"],"text":["In this tutorial we will show how to create components that consume a REST API.","As an example, we will develop an input component that will provide a search functionality for Zendesk using there Search API.","We use lambok. to get ride of getters, setters and constructors from our classes.","You can generate a project using the components kit starter as described in this tutorial.","As our input component will relay on Zendesk Search API. We will need an http client to consume it.","Zendesk Search API takes the following query parameters on this endpoint /api/v2/search.json.","query : The search query.","sort_by : One of updated_at, created_at, priority, status, or ticket_type. Defaults to sorting by relevance.","sort_order: One of asc or desc. Defaults to desc.","So let’s create our http client according to that.","Talend component kit provides a built-in service to create an easy to use http client in a declarative manner using java annotations.","And that all what we need to do to create our http client. No implementation is needed for the interface, as it will be provided by the component framework according to what we have defined.","This http client can be injected into a mapper or a processor to perform http requests.","For the sake of simplicity, we will use the basic authentication supported by the API.","Let’s start setting up the configuration for the basic authentication. To be able to consume the Search API, we will need to provide the Zendesk instance URL, the username and the password.","Now that we have our data store configuration. that will provide us with the basic authentication token. We need to setup our data set configuration. i.e the search query that will define the records that our input component will provide.","That’s all for the configuration part. Let’s create the component logic.","We will not split the http calls on many workers. so our mappers will not implement the split part.","Now we create the source that will perform the http request to the search api and convert the result to JsonObject records.","That all you will need to do to create a simple Talend component that consume a REST API.","In a next tutorial, we will show how to test this kind of component and use the component framework API simulation tools to create unit tests."]},{"lang":"en","title":"Creating a job pipeline","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/services-pipeline.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Creating a job pipeline","In this article"],"lvl1":["Job Builder","Beam case"],"lvl2":["Environment/Runner","Key Provider","I/O","Processors","Convert a Beam.io in a component I/O"],"text":["The Job builder let you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, so you can built complex pipelines.","Let’s take a simple use case where we will have 2 data source (employee and salary) that we will format to csv and write the result to a file.","A job is defined based on components (nodes) and links (edges) to connect their branches together.","Every component is defined by an unique id and an URI that identify the component.","The URI follow the form : [family]://[component][?version][&configuration]","family: the name of the component family","component: the name of the component","version : the version of the component, it’s represented in a key=value format. where the key is __version and the value is a number.","configuration: here you can provide the component configuration as key=value tuple where the key is the path of the configuration and the value is the configuration value in string format.","configuration parameters must be URI/URL encoded.","Here is a more concrete job example:","It has some starting components (component that don’t have a from connection and that need to be of type producer).","There is no cyclic connections. as the job pipeline need to be an acyclic graph.","All the components used in connections are already declared.","The connection is used only once. you can’t connect a component input/output branch twice.","In this version, the execution of the job is linear. the component are not executed in parallel even if some steps may be independents.","Depending the configuration you can select which environment you execute your job in.","To select the environment the logic is the following one:","if an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder is passed through the job properties then use it (supported type are a ExecutionBuilder instance, a Class or a String).","if an ExecutionBuilder SPI is present then use it (it is the case if component-runtime-beam is present in your classpath).","else just use a local/standalone execution.","In the case of a Beam execution you can customize the pipeline options using system properties. They have to be prefixed by talend.beam.job.. For instance to set appName option you will set -Dtalend.beam.job.appName=mytest.","The job builder let you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job","If the incoming data has different ids you can provide a complex global key provider relaying on the context that give you the component id and the branch Name.","For beam case, you need to rely on beam pipeline definition and use component-runtime-beam dependency which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and integrate it in the pipeline.","The multiple inputs/outputs are represented by a Map element in beam case to avoid to use multiple inputs/outputs.","you can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, so a kind of Map<String, List<?>>, but materialized as a JsonObject. Input data must be of type JsonObject in this case.","For simple I/O you can get automatic conversion of the Beam.io to a component I/O transparently if you decorated your PTransform with @PartitionMapper or @Processor.","The limitation are:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and just register on the input PCollection a DoFn.","More information on that topic on How to wrap a Beam I/O page."]},{"lang":"en","title":"Gallery","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/gallery.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Gallery","In this article"],"lvl1":["Widgets","Validations"],"text":["Name","Code","Studio Rendering","Web Rendering","Input/Text","Password","Textarea","Checkbox","List","List","Table","Code","Schema","Name","Code","Studio Rendering","Web Rendering","Property validation","Property validation with Pattern","Data store validation","There are also other types of validation similar to @Pattern that you can use :","@Min, @Max for numbers.","@Unique for collection values","@Required for required configuration"]},{"lang":"en","title":"Generate a project using the component starter","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-generate-project-using-starter.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Generate a project using the component starter","In this article"],"lvl1":["Project configuration","Create an input component","Create a Processor component","Create an Output component","Generate and download the final project.","Compile and explore the generated project files"],"text":["The component starter let you design your components configuration and generate a ready to implement project structure.","In this tutorial, we will use the component starter to generate some components for MySQL database.","The starter is available at starter-toolkit.talend.io.","Choose your favorite build tool. we will use maven in this tutorial but you can select gradle if you prefer.","We add the test facet to get some unit tests generated automatically for the component that we will create after.","Complete the component description (family, and category).","Complete the project metadata. the groupId, ArtifactId and the package.","Click ADD A COMPONENT button to start designing your components.","Let’s create an input component that will connect to a MySQL database, execute a SQL query and get the result.","We choose the component type. INPUT in this case.","Give the component a cool name. MySQLInput is good enough.","This button will let us create the required configuration for our component. To be able to execute a SQL query, we will need a connection url, the username and the password for the database and the SQL query to be executed. Click the (+) button on the right to add a field and chose it type.","Our component will be an ordinary (non streaming) component. so just let this toggle button off.","Here we define the record type that this component will produce. we let it generic for now. as our component will generate some json records. You can also choose a custom type to define a POJO that will represent your records.","In this step we will create a very simple processor component that will receive a record, log it and return it at is.","Choose the component type. PROCESSOR/OUTPUT in this case.","Give an explicit name to the component. RecordLogger, as our processor will log the records.","This is the configuration button. this component don’t need any configuration. so we just skip this step.","Here we define the inputs of the component. so click ADD INPUT button to create an input. In this component we will have only one input that will receive the record to be log.","click the input name to access it configuration. you can change the name and define the record model. Here we will use a generic record. otherwise you can use a POJO to represent the record.","Click ADD OUTPUT to create an output for this processor. we will need only one output as our logger only emit the received record. NOTE: the outputs are also configurable in the same way as the inputs (as explained in 5).","Now we will create an output component that will receive a record and insert it into a database table.","Output components are Processors without outputs. In other words, the output is a processor that don’t produce any records.","Choose the component type. PROCESSOR/OUTPUT in this case.","Give the component a name. MySQLOutput","Create the component configuration. in this case we will need the connection url, the credentials of the database and the table name to insert the record in.","Like what we have done for the processor component above. we add an input","We make our input generic as we want to handle generic records in this component.","We don’t create any outputs for this component as it will not produce any records. this is the only difference betweene an output an a processor.","In the previous steps we have configured a project and created 3 components of different types (input, processor and output). Now click the GO TO FINISH button beside the ADD A COMPONENT button. You will be redirected to a summary page that shows :","Project configuration summary.","The list of the created components at the left panel.","You have two options to get the generated project. Download it locally as a zip file using the DOWNLOAD AS ZIP","Create a github repository and push the project to it using the button CREATE ON GITHUB.","Download the project as a zip to your local machine or clone it if you have created a github project.","As we have created a maven project here, we will use maven command to compile the project. In the project directory we execute the command mvn package","If you don’t have Maven installed on your machine, you can use the maven wrapper provided in the generated project. All you need is to execute the command: ./mvnw package","If you have created a gradle project you can compile with gradle build or use the gradle wrapper ./gradlew build","The generated project code contains documentation that will guide you to implement the component logic. so import the project to your favorite IDE and start implementing coding.","In the next tutorial, we will explain how to implement an Input component in details."]},{"lang":"en","title":"Generating data?","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/testing-generating-data.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Generating data?","In this article"],"text":["Several data generator exists if you want to populate objects with a semantic a bit more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","…","A bit more advanced, these ones allow to bind directly generic data on a model - but data quality is not always there:","github.com/devopsfolks/podam","github.com/benas/random-beans","…","Note there are two main kind of implementations:","the one using a pattern and random generated data","a set of precomputed data extrapolated to create new values","Check against your use case to know which one is the best.","an interesting alternative to data generation is to import real data and use Talend Studio to sanitize the data (remove sensitive information replacing them by generated data or anonymized data) and just inject that file into the system.","If you are using JUnit 5, you can have a look to glytching.github.io/junit-extensions/randomBeans which is pretty good on that topic."]},{"lang":"en","title":"Gradle Plugin","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/build-tools-gradle.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Gradle Plugin","In this article"],"text":["gradle-talend-component intends to help you to write components validating components match best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file the SDK uses to build the component classpath. For more information on the configuration you can check out the maven properties matching the attributes.","Here is how to use it:"]},{"lang":"en","title":"How to test a REST API","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-test-rest-api.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["How to test a REST API","In this article"],"text":["Testing code that consume REST API(s) can sometimes presents some difficulties, as you can face allot of constraints when dealing with them, like API rates limit, authentication tokens and passwords sharing, API availability, sandbox that expire or API’s cost that may be high…","As a developer you don’t want to care about all that, as all what you want to achieve is writing some good tests for your code logic. This is why, having the possibility to easily mock the API response is trivial.","The component framework provides an API simulation tool that make it easy to write unit tests. In this tutorial we will show how to use it in unit tests.","In this previous tutorial, we have created a component that consume Zendesk Search API. We will add some unit tests for it.","We have added 4 tickets that have the status open to our Zendesk test instance. that we will use in our tests","In our tutorial we will use some concept from component junit testing. You can refer to this page to read about the SimpleComponentRule …","L’est create a first unit test that will perform a real http request to Zendesk Search API instance. You can read how to create a simple unit test in this tutorial","So here we have created a complete working test. the test is performing real http request to our zendesk instance. but we may don’t want do that every time on the development environment. We may want to execute real http request only on an integration environment and on development environment use some mocked result to develop faster or for any other reasons.","Now we will transform this unit test to a mocked test that will use only mocked response of zendesk Search API. To do that you will need to add 2 junit rules provided by the component framework.","JUnit4HttpApi - this rule will start a simulation server that will act as a proxy and catch all the http requests performed inside the tests. This simulation server (proxy) have 2 modes :","capture : this mode will forward the captured http request to the real server and capture there response.","simulation : this mode will return a mocked response from the already captured responses. This rule need to be added as a class rule","JUnit4HttpApi - this rule have a reference to the first one and it role is to configure the simulation server for every unit test. it provide the simulation server by the running test context. This rule need to be added as a simple (method) rule.","Let’s add those 2 rules to our test to make it run in a simulation mode.","We almost done,","Now we need to run our test in capture mode to catch the real API responses to be able to use them later in the simulated mode.","To do that, we will have to set an environment variable talend.junit.http.capture to true. This will tel the simulation server to run in a capture mode. The captured response will be saved into resources/talend.testing.http package in a json format, then reused to perform API simulation.","Now you know how to easily mock your component that consume REST API."]},{"lang":"en","title":"Internationalization","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/component-internationalization.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Internationalization","In this article"],"lvl1":["Default components keys"],"text":["In the simplest case you should store messages using ResourceBundle properties file in your component module to use internationalization. The location of the properties file should be in the same package as the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties).","Out of the box components are internationalized using the same location logic for the resource bundle and here is the list of supported keys:","Name Pattern","Description","${family}._displayName","the display name of the family","${family}.${configurationType}.${name}._displayName","the display name of a configuration type (dataStore or dataSet)","${family}.${component_name}._displayName","the display name of the component (used by the GUIs)","${property_path}._displayName","the display name of the option.","${simple_class_name}.${property_name}._displayName","the display name of the option using it class name.","${enum_simple_class_name}.${enum_name}._displayName","the display name of the enum_name enum value of the enum enum_simple_class_name.","${property_path}._placeholder","the placeholder of the option.","Example of configuration for a component named list belonging to the family memory (@Emitter(family = \"memory\", name = \"list\")):","Configuration class are also translatable using the simple class name in the messages properties file. This useful when you have some common configuration shared within multiple components.","If you have a configuration class like :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the config class.","If you have a display name using the property path, it will override the display name defined using the simple class name. this rule apply also to placeholders"]},{"lang":"en","title":"Internationalization","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/services-internationalization.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Internationalization","In this article"],"lvl1":["Internationalization API"],"text":["Recommanded practise for internationalization are:","store messages using ResourceBundle properties file in your component module","the location of the properties are in the same package than the related component(s) and is named Messages (ex: org.talend.demo.MyComponent will use org.talend.demo.Messages[locale].properties)","for your own messages use the internationalization API","Overal idea is to design its messages as methods returning String values and back the template by a ResourceBundle located in the same package than the interface defining these methods and named Messages.","this is the mecanism to use to internationalize your own messages in your own components.","To ensure you internationalization API is identified you need to mark it with @Internationalized:"]},{"lang":"en","title":"Mask your configuration sensitive data","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-configuration-sensitive-data.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Mask your configuration sensitive data","In this article"],"lvl1":["The component configuration","Mark sensitive data"],"text":["In this tutorial we will see how to ensure the sensitive data of a component configuration is correctly handled.","It is very common to define credentials in a component configuration. Most known use cases will be:","Passwords,","Secrets,","Potentially keys (it is also common to show them in plain text in a textarea),","Tokens","To illustrate that we will use a REST client configuration which takes a username, password and token to connect to the REST API:","This simple configuration defines three String without any specific widget so they will be represented as plain inputs.","There are two major consequences you probably want to avoid:","The password and token will be clearly readable in all Talend user interfaces (Studio or Web),","The password and token will be potentially stored in clear.","To solve that, Talend Component Kit provides you @Credential marker you can use on any @Option. This marker will have two effects:","Replace the default input widget by a password oriented one (See widgets gallery for screenshots),","Request the Studio or the Talend Cloud products to store the data as sensitive data (as encrypted values).","To ensure our password and token are never stored in clear or shown in the code we migrate our previous model to the following one:","And that it is! Now your password and token will not be accessible by error anymore :).","Read more about the component configuration…"]},{"lang":"en","title":"Maven Plugin","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/build-tools-maven.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Maven Plugin","In this article"],"lvl1":["Dependencies","Validate","Documentation","Web","Generate inputs or outputs","Talend Component Archive"],"lvl2":["Render your documentation"],"lvl3":["HTML","PDF","Include the documentation into a document","More"],"text":["talend-component-maven-plugin intends to help you to write components validating components match best practices and also generating transparently metadata used by Talend Studio.","Here is how to use it:","Note that this plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, dependencies, validate and documentation goals will be set up.","The first goal is a shortcut for the maven-dependency-plugin, it will create the TALEND-INF/dependencies.txt file with the compile and runtime dependencies to let the component use it at runtime:","The most important goal is here to help you to validate the common programming model of the component. Here is the execution definition to activate it:","By default it will be bound to process-classes phase. When executing it will do several validations which can be switched off adding the corresponding flags to false in the <configuration> block of the execution:","Name","Description","Default","validateInternationalization","Validates resource bundle are presents and contain commonly used keys (like _displayName)","true","validateModel","Ensure components pass validations of the ComponentManager and Talend Component runtime","true","validateSerializable","Ensure components are Serializable - note this is a sanity check, the component is not actually serialized here, if you have a doubt ensure to test it. It also checks any @Internationalized class is valid and has its keys.","true","validateMetadata","Ensure components define an @Icon and @Version.","true","validateDataStore","Ensure any @DataStore defines a @HealthCheck.","true","validateComponent","Ensure native programming model is respected, you can disable it when using another programming model like in beam case.","true","validateActions","Validate actions signatures for the ones not tolerating dynamic binding (@HealthCheck, @DynamicValues, …). It is recommended to keep it true.","true","validateFamily","Validate the family, i.e. the package containing the @Components has also a @Icon.","true","validateDocumentation","Ensure all 1. components and 2. @Option properties have a documentation using @Documentation","true","This goal generates an Asciidoc file documenting your component from the configuration model (@Option) and @Documentation you can put on options and the component itself.","Name","Description","Default","level","Which level are the root title","2 which means ==","output","Where to store the output, it is NOT recommended to change it","${classes}/TALEND-INF/documentation.adoc","formats","A map of the renderings to do, keys are the format (pdf or html) and values the output paths","-","attributes","A map of asciidoctor attributes when formats is set","-","templateDir / templateEngine","Template configuration for the rendering","-","title","Document title","${project.name}","attachDocumentations","Should the documentations (.adoc, and formats keys) should be attached to the project (and deployed)","true","if you use the extension you can add the property talend.documentation.htmlAndPdf and set it to true in your project to automatically get a html and PDF rendering of the documentation.","To render the generated documentation you can use the Asciidoctor Maven plugin (or Gradle equivalent):","Will generate in target/classes/TALEND-INF/documentation.adoc the components documentation.","Will render the documenation as an html file in target/documentation/documentation.html.","ensure to execute it after the documentation generation.","If you prefer a PDF rendering you can configure the following execution in the asciidoctor plugin (note that you can configure both executions if you want both HTML and PDF rendering):","If you want to add some more content or add a title, you can include the generated document into another document using Asciidoc include directive.","A common example is:","This assumes you pass to the plugin the attribute generated_doc, this can be done this way:","This is optional but allows to reuse maven placeholders to pass paths which is quite convenient in an automated build.","You can find more customizations on Asciidoctor website.","Testing the rendering of your component(s) configuration into the Studio is just a matter of deploying a component in Talend Studio (you can have a look to link::studio.html[Studio Documentation] page. But don’t forget the component can also be deployed into a Cloud (web) environment. To ease the testing of the related rendering, you can use the goal web of the plugin:","Then you can test your component going on localhost:8080. You need to select which component form you want to see using the treeview on the left, then on the right the form will be displayed.","The two available configurations of the plugin are serverPort which is a shortcut to change the default, 8080, port of the embedded server and serverArguments to pass Meecrowave options to the server. More on that configuration is available at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","this command reads the component jar from the local maven repository so ensure to install the artifact before using it.","The Mojo generate (maven plugin goal) of the same plugin also embeds a generator you can use to bootstrap any input or output component:","It is intended to be used from the command line (or IDE Maven integration):","For this command to work you will need to just register the plugin:","Component ARchive (.car) is the way to bundle a component to share it in Talend ecosystem. It is a plain Java ARchive (.jar) containing a metadata file and a nested maven repository containing the component and its depenencies.","It will create a .car in your build directory which is shareable on Talend platforms.","Note that this CAR is executable and exposes the command studio-deploy which takes as parameter a Talend Studio home location. Executed it will install the dependencies into the studio and register the component in your instance. Here is a sample launch command:","You can also upload the dependencies to your nexus server using the following command:","In this command Nexus Url and repository name are mandatory arguments. All other arguments are optional. If arguments contain spaces or special symbols, you need to quote the whole value of the argument, for example"]},{"lang":"en","title":"Multiple environments for the same tests","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/testing-multiple-envs.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Multiple environments for the same tests","In this article"],"lvl1":["JUnit 4","JUnit 5","Provided environments","Configuring environments"],"lvl2":["Advanced usage"],"text":["JUnit (4 or 5) already provides some ways to parameterized tests and execute the same \"test logic\" against several data. However it is not that convenient to test multiple environments.","For instance, with Beam, you can desire to test against multiple runners your code and it requires to solve conflicts between runner dependencies, setup the correct classloaders etc…It is a lot of work!","To simplify such cases, the framework provides you a multi-environment support for your tests.","It is in the junit module and is usable with JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner will execute the test(s) for each defined environments. It means it will run test1 for Env1 and Env2 in previous example.","By default JUnit4 runner will be used to execute the tests in one environment but you can use @DelegateRunWith to use another runner.","JUnit 5 configuration is close to JUnit 4 one:","The main difference is you don’t use a runner (it doesn’t exist in JUnit 5) and you replace @Test by @EnvironmentalTest.","the main difference with JUnit 4 integration is that the tests are execute one after each other for all environments instead of running all tests in each environments sequentially. It means, for instance, that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment setup the contextual classloader to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones, you can use EnvironmentConfiguration to customize the system properties used for that environment:","if you set the system property <environment name>.skip=true then the environment related executions will be skipped.","this usage assumes Beam 2.4.0 is in used and the classloader fix about the PipelineOptions is merged.","Dependencies:","These dependencies brings into the test scope the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit.","Then using the fluent DSL to define jobs - which assumes your job is linear and each step sends a single value (no multi-input/multi-output), you can write this kind of test:","It will execute the chain twice:","with a standalone environment to simulate the studio","with a beam (direct runner) environment to ensure the portability of your job"]},{"lang":"en","title":"Providing some actions for consumers/clients","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/services-actions.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Providing some actions for consumers/clients","In this article"],"lvl1":["Particular action types"],"text":["In some cases you will desire to add some actions unrelated to the runtime. A simple example is to enable clients - the users of the plugin/library - to test if a connection works. Even more concretely: does my database is up?.","To do so you need to define an @Action which is a method with a name (representing the event name) in a class decorated with @Service:","services are singleton so if you need some thread safety ensure they match that requirement. They shouldn’t store any state too (state is held by the component) since they can be serialized any time.","services are usable in components as well (matched by type) and allow to reuse some shared logic like a client. Here is a sample with a service used to access files:","service is passed to constructor automatically, it can be used as a bean. Only call of service’s method is required.","Some actions are that common and need a clear contract so they are defined as API first citizen, this is the case for wizards or healthchecks for instance. Here is the list of all actions:","API","Type","Description","Return type","Sample returned type","@org.talend.sdk.component.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Values","{\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","HealthCheckStatus","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","@org.talend.sdk.component.api.service.schema.DiscoverSchema","schema","Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with @Structure.","Schema","{\"entries\":[{\"name\":\"column1\",\"type\":\"STRING\"}]}","@org.talend.sdk.component.api.service.Action","user","-","any","-","@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","validation","Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can’t use other client side validation to implement it.","ValidationResult","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}"]},{"lang":"en","title":"Registering components","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/component-registering.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Registering components","In this article"],"lvl1":["Components metadata"],"lvl2":["Management of configuration versions","@PartitionMapper","@Processor"],"lvl3":["@Emitter"],"text":["As seen in the Getting Started, you need an annotation to register your component through family method. Multiple components can use the same family value but the pair family+name MUST be unique for the system.","If you desire (recommended) to share the same component family name instead of repeating yourself in all family methods, you can use @Components annotation on the root package of you component, it will enable you to define the component family and the categories the component belongs to (default is Misc if not set). Here is a sample package-info.java:","For an existing component it can look like:","Components can require a few metadata to be integrated in Talend Studio or Cloud platform. Here is how to provide these information. These metadata are set on the component class and belongs to org.talend.sdk.component.api.component package.","API","Description","@Icon","Set an icon key used to represent the component. Note you can use a custom key with custom() method but it is not guaranteed the icon will be rendered properly.","@Version","Set the component version, default to 1.","Example:","If some impacting changes happen on the configuration they can be manage through a migration handler at component level (to enable to support trans-model migration).","The @Version annotation supports a migrationHandler method which will take the implementation migrating the incoming configuration to the current model.","For instance if filepath configuration entry from v1 changed to location in v2 you can remap the value to the right key in your MigrationHandler implementation.","it is recommended to not manage all migrations in the handler but rather split it in services you inject in the migration handler (through constructor):","What is important in this snippet is not much the way the code is organized but rather the fact you organize your migrations the way which fits the best your component. If migrations are not conflicting no need of something fancy, just apply them all but if you need to apply them in order you need to ensure they are sorted. Said otherwise: don’t see this API as a migration API but as a migration callback and adjust the migration code structure you need behind the MigrationHandler based on your component requirements. The service injection enables you to do so.","@PartitionMapper will obviously mark a partition mapper:","@Emitter is a shortcut for @PartitionMapper when you don’t support distribution. Said otherwise it will enforce an implicit partition mapper execution with an assessor size of 1 and a split returning itself.","A method decorated with @Processor will be considered as a producer factory:"]},{"lang":"en","title":"Search","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/search.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Search"]},{"lang":"en","title":"Secrets/Passwords and Maven","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/testing-maven-passwords.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Secrets/Passwords and Maven","In this article"],"text":["If you desire you can reuse your Maven settings.xml servers - including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter will give you the ability to find a server username/password from a server identifier:","It is very useful to not store secrets and test on real systems on a continuous integration platform.","even if you don’t use maven on the platform you can generate the settings.xml and settings-security.xml files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details."]},{"lang":"en","title":"Services and interceptors","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/services-interceptors.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Services and interceptors","In this article"],"text":["For common concerns like caching, auditing etc, it can be fancy to use interceptor like API. It is enabled by the framework on services.","An interceptor defines an annotation marked with @Intercepts which defines the implementation of the interceptor (an InterceptorHandler).","Here is an example:","Then handler is created from its constructor and can take service injections (by type). The first parameter, however, can be a BiFunction<Method, Object[], Object> which representes the invocation chain if your interceptor can be used with others.","if you do a generic interceptor it is important to pass the invoker as first parameter. If you don’t do so you can’t combine interceptors at all.","Here is an interceptor implementation for our @Logged API:","This implementation is compatible with interceptor chains since it takes the invoker as first constructor parameter and it also takes a service injection. Then the implementation just does what is needed - logging the invoked method here.","the findAnnotation annotation - inherited from InterceptorHandler is an utility method to find an annotation on a method or class (in this order)."]},{"lang":"en","title":"Talend Component Best Practices","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/best-practices.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Talend Component Best Practices","In this article"],"lvl1":["Organize your code","Model your configuration","I/O configuration","Processor configuration","I/O recommendations","I/O limitations","Handle UI interactions","Version and component","Don’t forget to test","Contribute to this guide"],"lvl2":["Validations","Completion","Don’t forget the component representation"],"lvl3":["Light validations","Custom validations"],"text":["Few recommendations apply to the way a component packages are organized:","ensure to create a package-info.java with the component family/categories at the root of your component package:","create a package for the configuration","create a package for the actions","create a package for the component and one subpackage by type of component (input, output, processors, …)","It is recommended to ensure your configuration is serializable since it is likely you will pass it through your components which can be serialized.","The first step to build a component is to identify the way it must be configured.","It is generally split into two main big concepts:","the DataStore which is the way you can access the backend","the DataSet which is the way you interact with the backend","Here are some examples to let you get an idea of what you put in each categories:","Example description","DataStore","DataSet","Accessing a relational database like MySQL","the JDBC driver, url, username and password","the query to execute, row mapper, …","Access a file system","the file pattern (or directory + file extension/prefix/…)","the file format, potentially the buffer size, …","It is common to make the dataset including the datastore since both are required to work. However it is recommended to replace this pattern by composing both in a higher level configuration model:","Processor configuration is simpler than I/O configuration since it is specific each time. For instance a mapper will take the mapping between the input and output model:","I/O are particular because they can be linked to a set of actions. It is recommended to wire all the ones you can apply to ensure the consumers of your component can provide a rich experience to their users.","Here are the most common ones:","Type","Action","Description","Configuration example","Action example","DataStore","@Checkable","Expose a way to ensure the datastore/connection works","Until the studio integration is complete, it is recommended to limit processors to 1 input.","It is also recommended to provide as much information as possible to let the UI work with the data during its edition.","The light validations are all the validations you can execute on the client side. They are listed in the UI hint part.","This is the ones to use first before going with custom validations since they will be more efficient.","These ones will enforce custom code to be executed, they are more heavy so try to avoid to use them for simple validations you can do with the previous part.","Here you define an action taking some parameters needed for the validation and you link the option you want to validate to this action. Here is an example to validate a dataset. For example for our JDBC driver we could have:","Note that you can also make a class validable and you can use it to validate a form if you put it on your whole configuration:","the parameter binding of the validation method uses the same logic than the component configuration injection. Therefore the @Option specifies the prefix to use to reference a parameter. It is recommended to use @Option(\"value\") until you know exactly why you don’t use it. This way the consumer can match the configuration model and just prefix it with value. to send the instance to validate.","It can be neat and user friendly to provide completion on some fields. Here an example for the available drivers:","Each component must have its own icon:","you can use talend.surge.sh/icons/ to identify the one you want to use.","Not mandatory for the first version but recommended: enforce the version of your component.","If you break a configuration entry in a later version ensure to:","upgrade the version","support a migration of the configuration","Testing the components is crucial, you can use unit tests and simple standalone JUnit but it is highly recommended to have a few Beam tests to ensure your component works in Big Data world.","Don’t hesitate to send your feedback on writing component and best practices you can encounter."]},{"lang":"en","title":"Talend Component Getting Started","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/getting-started.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Talend Component Getting Started","In this article"],"lvl1":["Introducing Talend Component","Talend Component System Requirement","Quick Start"],"text":["Talend Component intends to simplify the development of connectors at two main levels:","how to inject the specific component code into a job or pipeline. It should unify as much as possible the code required to run in DI and BEAM environments.","unify the code required to be able to render in a browser (web) or the eclipse based Studio (SWT).","Talend Component requires Java 8. You can download it on Oracle website.","To develop a component or the project itself it is recommended to use Apache Maven 3.5.0. you can download it on Apache Maven website.","Generate a component","Create an input component","Create an output component","Test your components","Configuration and sensitive data","Create components for REST API","How to test a REST API","Dev vs CI setup","Talend Intellij plugin"]},{"lang":"en","title":"Talend Component Javadocs","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/apidocs.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Talend Component Javadocs","In this article"],"text":["API Documentation","JUnit API Documentation","HTTP JUnit API Documentation"]},{"lang":"en","title":"Talend Component Kit Changelog","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/changelog.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Talend Component Kit Changelog","In this article"],"lvl1":["Version 1.0.0","Version 0.0.12","Version 0.0.11","Version 0.0.10","Version 0.0.9","Version 0.0.8","Version 0.0.7","Version 0.0.6","Version 0.0.5","Version 0.0.4","Version 0.0.3","Version 0.0.2","Version 0.0.1"],"lvl2":["Bug","Work Item","New Feature","Work Item","Bug","Work Item","Backlog Task","Bug","New Feature","Work Item","Work Item","Work Item","Work Item","Bug","Work Item","Work Item","Bug","New Feature","Work Item","Bug","Bug","Work Item","Work Item"],"text":["TCOMP-827: Fix Automatic-Module-Name","TCOMP-811: Upgrade to tomcat 9.0.8","TCOMP-826: Extract component model from component server to a new artifact","TCOMP-763: Add a dev mode in the studio for tacokit","TCOMP-802: Add method to upload dependencies from .car to nexus","TCOMP-808: Upgrade to JUnit 5.2.0","TCOMP-809: compress js and css for the starter","TCOMP-810: ui spec service uses a multiselecttag for a proposable on a string field","TCOMP-804: Idea plugin doesn’t render properly configuration inputs","TCOMP-798: intellij plugin - add official starter url","TCOMP-799: @Checkable expects the datastore name to match the validation name","TCOMP-806: Ensure server and starter support gzip","TCOMP-643: Deployment","TCOMP-770: Removing component from web UI causes wrong number of components in summary","TCOMP-775: Starter - Fix properties keys generation","TCOMP-776: component-kit.js ignore credentials","TCOMP-783: ActiveIfs doesn’t make option visible","TCOMP-796: Datastore check (@Checkable) should default meta parameters to \"datastore\" if none is found","TCOMP-773: Extend the http client api to handle more generic use cases","TCOMP-771: ConfigurableClassLoader should skip scala.* classes","TCOMP-772: Upgrade icon set to ui/icons 0.179.0","TCOMP-774: Upgrade xbean to 4.8","TCOMP-768: More tolerance of configuration prefix for implicit migration of configuration node in form core library","TCOMP-756: Setup maven clirr plugin for component-api +testing","TCOMP-762: Starter should only propose a single category level in the ui","TCOMP-767: Ensure the configurationtype endpoints have matching name/path values","TCOMP-761: Merge component-runtime-manager and component-runtime-standalone","TCOMP-764: Clean up component-form-core dependencies","TCOMP-765: Upgrade to batik 1.9.1","TCOMP-752: Fix Advanced settings and Test connection button appearance in repository wizard","TCOMP-757: Duplicate method name \"writeReplace\" with signature \"()Ljava.lang.Object;\" in class file","TCOMP-751: Support gzip compression on component-server","TCOMP-753: Make classpath scanning to find component configurable","TCOMP-758: Support component-server server configuration from system properties","TCOMP-759: Enum must be i18n","TCOMP-738: Component Server should respect ~/.m2/settings.xml local repository if it exists","TCOMP-739: SerializationTransformer shouldn’t use ComponentManager to avoid ClassNotFoundException","TCOMP-740: UISpecService should be reactive and use a CompletionStage based API","TCOMP-741: UISpecService configuration support","TCOMP-742: Configuration Type properties should be rooted","TCOMP-744: Ensure wrapped BeamIO uses the right TCCL","TCOMP-745: [Dependency Upgrade] CXF 3.2.4","TCOMP-746: [Dependency Upgrade] Tomcat 9.0.6","TCOMP-747: [Dependency Upgrade] Log4j2 2.11.0","TCOMP-748: Make configurationtype index endpoint lighter OOTB","TCOMP-749: Intellij Idea plugin","TCOMP-750: Unify @Pattern using javascript regex instead of a mixed mode","TCOMP-734: Add support for context and globalMap values in Tacokit component settings","TCOMP-733: support to use a beam pipeline under the hood for beam components in di","TCOMP-693: Integrate Migration API","TCOMP-737: upgrade to beam 2.4.0","TCOMP-731: Configuration Type migration handler skipped","TCOMP-725: MavenDecrypter doesn’t support comments in settings.xml","TCOMP-726: When a component is not found the error message can be misleading","TCOMP-728: Http client doesn’t ignore empty query parameters","TCOMP-722: WebSocket connection fails with a NPE when the endpoint doesn’t exists","TCOMP-723: Adding configurationByExample utility to create query string for Job DSL","TCOMP-724: Documentation endpoint doesn’t support HTML","TCOMP-446: Support Embedded Documentation","TCOMP-650: Ensure component can be executed in beam pipelines","TCOMP-651: Ensure beam components can be wrapped and used through the Talend Component Kit Framework","TCOMP-653: Web Form metamodel service","TCOMP-655: Catalog service","TCOMP-656: UISpec compatibility","TCOMP-658: Add test Source/Sink collectors in JUnit integration","TCOMP-659: Basic job builder API to simplify JUnit tests","TCOMP-662: Validation Mojo","TCOMP-664: Local testing server for dev","TCOMP-675: Select a communication solution for Talend Component Kit server","TCOMP-680: Register components into the Studio Palette","TCOMP-681: Studio parameters form integration","TCOMP-682: Studio Metadata integration","TCOMP-683: Studio Runtime integration","TCOMP-691: Create context menu for Tacokit node in repository panel","TCOMP-719: Support Input Definition","TCOMP-720: Support Output Definition","TCOMP-721: Initial Widget Definitions"]},{"lang":"en","title":"Talend Component Kit Developer Reference Guide ::","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-dev-vs-ci-setup.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["In this article"],"lvl1":["Credentials setup","Let’s adapt our unit test to use the credentials from maven servers","Set up CI server in passthrough mode"],"text":["Development vs Continuous integration Setup","In a previous tutorial, we have shown how to create a mocked test for our Zendesk search component.","In the test you can notice that we have used our Zendesk credentials directly into the code to do a first capture of the API response, then we have switched to a fake credentials in simulation mode as we do not call the real API anymore.","But what if you want to continue to call the real API on the CI server or on a a specific environment ?","Let’s make our test able to get the credentials depending on the execution mode (simulation/passthrough).","This instructions, need to be done, on the CI server or on any environment that require the real credentials.","We will use Maven servers, that support password encryption as a credentials provider, and the test rule MavenDecrypterRule provided by the framework.","This rule let you get credentials from maven settings using a server id.","So let’s create an encrypted server credential for our zendesk instance.","Create a master password using the command : mvn --encrypt-master-password <password>","Store this master password in settings-security.xml file in ~/.m2 folder.","Encrypt zendesk instance password using the command: mvn --encrypt-password <zendesk-password>","Create a server entry under servers in maven settings.xml file in ~/.m2.","Encryption is optional but recommended.","If you want to store the settings-security.xml and settings.xml files elsewhere that the default location ~/.m2. You can do it by setting the path of the directory containing the files into the environment variable talend.maven.decrypter.m2.location","We start by adding MavenDecrypterRule rule to our test class. This rule will let us inject server information stored in maven settings.xml to our test. The rule will also decrypt the password if they are encrypted.","Now we can inject our Zendesk server to our test. For that we add a new field to our class annotated by @DecryptedServer annotation that will holde the server id to be injected.","The MavenDecrypterRule will be able at runtime to inject the server instance into this class. the server instance contains the username and de decrypted password.","Now we can use the server instance in our test to get the real credential in a secured manner.","Here is the complete test class after modification :","This test will continue to work in simulation mode. as we have our API simulation proxy activated.","Let’s make it work in real mode on a CI server. we will use jenkins in this tutorial","Log in to your jenkins then : Click on New Item to create a new build job","Enter an Item name (Job name) and choose the freestyle job. Then click OK.","In Source Code Management section enter your project repository URL. We are using our github repository in this tutorial. We will build the master branch","In the Build Section click on add build step, then choose Invoke top-level Maven targets","Choose you Maven version, and enter your maven build command. we are using a simple clean install and click save.","You can notice that we have added the option -Dtalend.junit.http.passthrough=true to our build command. This Option will tell the API simulation proxy to run in passthrough mode. So it’s will forward all the http request that we have maded in our test to the real API server.","We also get the real credentials, thanks to our MavenDecrypterRule rule.","You can configure the passthrough mode globally on your CI server by setting the environment variable talend.junit.http.passthrough to true.","6.Test the job. click Build now you can notice that your job have built correctly.","That’s all you need to do, now your tests run in a simulation mode on dev and in a (passthrough) mode on your CI server."]},{"lang":"en","title":"Talend Component REST API Documentation","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/documentation-rest.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Talend Component REST API Documentation","In this article"],"lvl1":["HTTP API","HTTPS activation","Web forms and REST API","Logging","Server Configuration"],"lvl2":["REST resources of Component Runtime :: Server Parent :: Server","Deprecated endpoints","WebSocket transport","Use UiSpec model without all the tooling","Javascript integration"],"lvl3":["POST api/v1/action/execute","GET api/v1/action/index","GET api/v1/component/dependencies","GET api/v1/component/dependency/{id}","GET api/v1/component/details","GET api/v1/component/icon/family/{id}","GET api/v1/component/icon/{id}","GET api/v1/component/index","POST api/v1/component/migrate/{id}/{configurationVersion}","GET api/v1/configurationtype/details","GET api/v1/configurationtype/index","POST api/v1/configurationtype/migrate/{id}/{configurationVersion}","GET api/v1/documentation/component/{id}","GET api/v1/environment","POST api/v1/execution/read/{family}/{component}","POST api/v1/execution/write/{family}/{component}"],"text":["a test environment is available on Heroku and browable using Talend Component Kit Server Restlet Studio instance.","The HTTP API intends to expose over HTTP most of Talend Component features, it is a standalone Java HTTP server.","WebSocket protocol is activated for the endpoints as well, instead of /api/v1 they uses the base /websocket/v1, see WebSocket part for more details.","Here is the API:","1.0.0","This endpoint will execute any UI action and serialize the response as a JSON (pojo model) It takes as input the family, type and name of the related action to identify it and its configuration as a flat key value set using the same kind of mapping than for components (option path as key).","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Query Param: action, java.lang.String Query Param: family, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (java.lang.RuntimeException)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","This endpoint returns the list of available actions for a certain family and potentially filters the \" output limiting it to some families and types of actions.","No body Query Param: family, java.lang.String Query Param: language, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ActionList)","Returns a list of dependencies for the given components.","don’t forget to add the component itself since it will not be part of the dependencies.","Then you can use /dependency/{id} to download the binary.","No body Query Param: identifier, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.Dependencies)","Return a binary of the dependency represented by id. It can be maven coordinates for dependencies or a component id.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (javax.ws.rs.core.StreamingOutput)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the set of metadata about a few components identified by their 'id'.","No body Query Param: identifiers, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentDetailList)","Response Body: (java.util.Map<java.lang.String, org.talend.sdk.component.server.front.model.error.ErrorPayload>)","Returns a particular family icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns a particular component icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the list of available components.","No body Query Param: includeIconContent, boolean Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentIndices)","Allows to migrate a component configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns the set of metadata about a few configurations identified by their 'id'.","No body Query Param: identifiers, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ConfigTypeNodes)","Returns all available configuration type - storable models. Note that the lightPayload flag allows to load all of them at once when you eagerly need to create a client model for all configurations.","No body Query Param: language, java.lang.String Query Param: lightPayload, boolean","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ConfigTypeNodes)","Allows to migrate a configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns an asciidoctor version of the documentation for the component represented by its identifier id.","Format can be either asciidoc or html - if not it will fallback on asciidoc - and if html is selected you get a partial document.","it is recommended to use asciidoc format and handle the conversion on your side if you can, the html flavor handles a limited set of the asciidoc syntax only like plain arrays, paragraph and titles.","The documentation will likely be the family documentation but you can use anchors to access a particular component (_componentname_inlowercase).","No body Path Param: id, java.lang.String Query Param: format, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.DocumentationContent)","Returns the environment of this instance. Useful to check the version or configure a healthcheck for the server.","No body","Content-Type: */*","Response Body: (org.talend.sdk.component.server.front.model.Environment)","deprecated","Read inputs from an instance of mapper. The number of returned records if enforced to be limited to 1000. The format is a JSON based format where each like is a json record.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: size, long","Content-Type: talend/stream","deprecated","Sends records using a processor instance. Note that the processor should have only an input. Behavior for other processors is undefined. The input format is a JSON based format where each like is a json record - same as for the symmetric endpoint.","Content-Type: talend/stream Request Body: (java.io.InputStream) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: group-size, long","Content-Type: application/json","to ensure the migration can be activated you need to set in the execution configuration you send to the server the version it was created with (component version, it is in component detail endpoint) with the key tcomp::component::version.","If some endpoints are intended to disappear they will be deprecated. In practise it means a header X-Talend-Warning will be returned with some message as value.","You can connect on any endpoint replacing /api by /websocket and appending /<http method> for the URL and formatting the request as:","For instance:","The response is formatted as follow:","if you have a doubt about the endpoint, they are all logged during startup and you can find them in the logs.","If you don’t want to create a pool of connection per endpoint/verb you can use the bus endpoint: /websocket/v1/bus. This endpoint requires that you add the header destinationMethod to each request with the verb value - default would be GET:","Using the server zip (or Docker image) you can configure HTTPS adding properties to MEECROWAVE_OPTS. Assuming you have a certificate in /opt/certificates/component.p12 (don’t forget to add/mount it in the Docker image if you use it) you can activate it through:","component-form library provides a way to build a component REST API facade compatible with react form library.","A trivial facade can be:","the Client can be created using ClientFactory.createDefault(System.getProperty(\"app.components.base\", \"http://localhost:8080/api/v1\")) and the service can be a simple new UiSpecService(). The factory uses JAX-RS if the API is available (assuming a JSON-B provider is registered) otherwise it tries to use Spring.","All the conversion between component model (REST API) and uiSpec model is done through the UiSpecService. It is based on the object model which will be mapped to a ui model. The advantage to have a flat model in the component REST API is to make these layers easy to customize.","You can completely control the available components, tune the rendering switching the uiSchema if desired or add/remove part of the form. You can also add custom actions/buttons for specific needs of the application.","the /migrate endpoint has nothing special so was not shown in previous snippet but if you need it you must add it as well.","This maven dependency provides the UISpec model classes. You can use the Ui API (with or without the builders) to create UiSpec representations.","Example:","We extract the JsonSchema from reflection on the class Form1. Note that @JsonSchemaIgnore allows to ignore a field and @JsonSchemaProperty allows to rename a property,","We build programmatically using the builder API a UiSchema,","We pass an instance of the form to let the serializer extracts it JSON model,","We serialize the Ui model which can be used by UiSpec compatible front widgets.","the model uses JSON-B API to define the binding, ensure to have an implementation in your classpath. This can be done adding these dependencies:","Default javascript integration goes through Talend UI Forms library.","It is bundled as a NPM module called component-kit.js. It provides a default trigger implementation for the UIForm.","Here is how to use it:","The logging uses Log4j2, you can specify a custom configuration using the system property -Dlog4j.configurationFile or adding a log4j2.xml file into the classpath.","Here are some common configurations:","Console logging:","This outputs messages looking like:","JSON logging:","Output messages look like:","Rolling file appender","More details are available on RollingFileAppender documentation.","of course you can compose previous layout (message format) and appenders (where logs are written).","The server module contains several configuration you can set in:","Environment variables","System properties","A file located based on the --component-configuration CLI option","the configuration is read from system properties, environment variables, ….","Key","Description","Default","talend.component.server.component.coordinates","A comma separated list of gav to locate the components","-","talend.component.server.component.extend.dependencies","Should the component extensions add required dependencies.","true","talend.component.server.component.registry","A property file where the value is a gav of a component to register (complementary with coordinates)","-","talend.component.server.documentation.active","Should the /documentation endpoint be activated.","true","talend.component.server.execution.dataset.retriever.timeout","How long the read execution endpoint can last (max)","180","talend.component.server.execution.pool.size","The size of the execution pool for runtime endpoints.","64","talend.component.server.execution.pool.wait","How long the application waits during shutdown for the execution tasks to complete","PT10S","talend.component.server.jaxrs.exceptionhandler.defaultMessage","If set it will replace any message for exceptions. Set to false to use the actual exception message.","false","talend.component.server.maven.repository","The local maven repository used to locate components and their dependencies","-","talend.component.server.monitoring.brave.reporter.async","When using url or kafka reporter, you can configure the async reporter with properties passed to this configuration entry.Ex: messageTimeout=5000,closeTimeout=5000.","console","talend.component.server.monitoring.brave.reporter.type","The brave reporter to use to send the spans. Supported values are [log, noop]. When configuration is needed,you can use this syntax to configure the repoter if needed: <name>(config1=value1, config2=value2), for example: url(endpoint=http://brave.company.com.","In log mode, if environment variable TRACING_ON doesn’t exist or is set to false, noop will be selected, and is set to true, TRACING_KAFKA_URL, TRACING_KAFKA_TOPIC and TRACING_SAMPLING_RATE will configure kafka reporter..","noop","talend.component.server.monitoring.brave.sampling.action.rate","The accuracy rate of the sampling for action endpoints.","-1","talend.component.server.monitoring.brave.sampling.component.rate","The accuracy rate of the sampling for component endpoints.","-1","talend.component.server.monitoring.brave.sampling.configurationtype.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.documentation.rate","The accuracy rate of the sampling for documentation endpoint.","-1","talend.component.server.monitoring.brave.sampling.environment.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.execution.rate","The accuracy rate of the sampling for execution endpoints.","1","talend.component.server.monitoring.brave.sampling.rate","The accuracy rate of the sampling.","-1.","talend.component.server.monitoring.brave.service.name","The name used by the brave integration (zipkin)","component-server","talend.component.server.security.command.handler","How to validate a command/request. Accepted values: securityNoopHandler.","securityNoopHandler","talend.component.server.security.connection.handler","How to validate a connection. Accepted values: securityNoopHandler.","securityNoopHandler"]},{"lang":"en","title":"Talend Component Studio Integration","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/studio.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Talend Component Studio Integration","In this article"],"lvl1":["Design","Installation","Configuration"],"lvl2":["Random port when running concurrent studio instances","Developer mode"],"text":["The studio integration relies on Component Server (see Web for more details).","When the plugin is deployed it starts a local server the Studio uses to gather data about the components.","Copy org.talend.sdk.component.studio-integration.jar in the $STUDIO_HOME/plugins directory and restart the studio.","Also ensure the component-server dependencies and commons-cli 1.4 are into the Studio maven repository. If you install any component, ensure its dependencies are in the repository as well.","you can set in $STUDIO_HOME/configuration/config.ini the value maven.repository to global to reuse your local maven repository.","The configuration goes into $STUDIO_HOME/configuration/config.ini.","Name","Description","Default","component.environment","Active the developer mode when set to dev","-","component.debounce.timeout","Specifies timeout in milliseconds before calling listeners in components Text fields","750","component.kit.skip","If true the plugin is not active. Useful if you don’t have any component develop with the framework.","false","component.java.arguments","Component server additional options","-","component.java.m2","The maven repository the server uses to resolve components","default to global Studio configuration","component.java.coordinates","A list of comma separated GAV (groupId:artifactId:version) of components to register","-","component.java.registry","A properties file with values matching component GAV (groupId:artifactId:version) which are registered at startup","-","component.java.port","Set a port to use for the server","random","components.server.beam.active","Active, if set to true, beam support (Experimental). It requires beam sdk java core dependencies to be available.","false","component.server.jul.forceConsole","Adds a console handler to JUL to see logs in the console. This can be helpful in dev since the formatting will be better than the OSGi one in workspace/.metadata/.log.","it uses java.util.logging.SimpleFormatter.format property to define its format. Default is %1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n but for development purposes [%4$s] %5$s%6$s%n is simpler and more readable.","false","to activate the plugin and be able to deploy your component, don’t forget to set component.kit.skip to true.","A common developer configuration/config.ini will use the following specific entries:","If you run multiple Studio instance automatically in parallel you can have some issues with the random port computation (can happen on a CI platform). For that purpose you can create the file $HOME/.talend/locks/org.talend.sdk.component.studio-integration.lock.","When a server will start it will acquire a lock on that file and prevent another one to get a port until it is started. It ensures you can’t get two concurrent processes getting the same allocated port.","it is highly unlikely it happens on a desktop and forcing a different value through component.java.port in your config.ini is likely a better solution for local installations.","The developer mode will add a Talend Component Kit button in the main toolbar:","When clicking on this button, all component developped with the framework will be reloaded. The cache will be invalidated and the component refreshed.","you still need to add/remove the components to see the changes.","This feature is very useful to see some updates in components without having to restart the studio completly."]},{"lang":"en","title":"Test your components","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-test-your-components.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Test your components","In this article"],"text":["In a previous tutorial we have created an input component for hazelcast. In this one we will show how to write some unit tests for it.","In this tutorial we will cover :","How to load components in a unit test.","How to create a job pipeline.","How to run the test in standalone mode.","Here is our test class. let’s examine it in details."]},{"lang":"en","title":"Wall of Fame","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/contributors.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Wall of Fame"],"lvl2":["Romain Manni-Bucau","#1027 commits","Anas KHABALI","#197 commits","Ivan Gonchar","#190 commits","Chao MENG","#22 commits","ypiel","#17 commits","Jimmy Somsanith","#9 commits","","#1 commit"],"text":["Joined the Apache EE family (TomEE, Johnzon, BatchEE...) in 2011. My goal is to make development a detail of an idea becoming reality. Blog: https://rmannibucau.metawerx.net","I am a software developer at @Talend For my personal projects you can check them @khabali Blog: https://khabali.github.io","","R&D","","Java and Javascript developer",""]},{"lang":"en","title":"Wrapping a Beam I/O","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/wrapping-a-beam-io.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Wrapping a Beam I/O","In this article"],"lvl1":["Limitations","Wrap an input","Wrap an output","Tip","Advanced"],"lvl2":["Coder","Sample"],"text":["This part is limited to particular kinds of Beam PTransform:","the PTransform<PBegin, PCollection<?>> for the inputs","the PTransform<PCollection<?>, PDone> for the outputs. The outputs also must use a single (composite or not) DoFn in their apply method.","Assume you want to wrap an input like this one (based on existing Beam ones):","To wrap the Read in a framework component you create a transform delegating to this one with a @PartitionMapper annotation at least (you likely want to follow the best practices as well adding @Icon and @Version) and using @Option constructor injections to configure the component:","Assume you want to wrap an output like this one (based on existing Beam ones):","You can wrap this output exactly the same way than for the inputs but using @Processor this time:","Note that the class org.talend.sdk.component.runtime.beam.transform.DelegatingTransform fully delegates to another transform the \"expansion\". Therefore you can extend it and just implement the configuration mapping:","In terms of classloading, when you write an IO all the Beam SDK Java core stack is assumed in Talend Component Kit runtime as provided so never include it in compile scope - it would be ignored anyway.","If you need a JSonCoder you can use org.talend.sdk.component.runtime.beam.factory.service.PluginCoderFactory service which gives you access the JSON-P and JSON-B coders.","Here is a sample input based on beam Kafka:","Since the Beam wrapper doesn’t respect the standard Kit programming Model (no @Emitter for instance) you need to set <talend.validation.component>false</talend.validation.component> property in your pom.xml (or equivalent for Gradle) to skip the Kit component programming model validations."]},{"lang":"en","title":"Write an Output component","version":"1.0.0","url":"https://talend.github.io/component-runtime/main/1.0.0/tutorial-create-an-output-component.html","date":"2021-10-07T12:13:18Z","timestamp":1633608798856,"lvl0":["Write an Output component","In this article"],"lvl1":["The component configuration","The Output"],"lvl2":["The constructor","The PostConstruct method","The PreDestroy method","The ElementListener method","The full implementation of the Output"],"text":["In this tutorial we will create a complete working output component for hazelcast. This will include :","The component configuration and the UI layout","The output that is responsible for connecting and writing data to the data source.","How to create component configuration has already been described in \"Create an input component\" tutorial. For now we will use the same component configuration. We will only add a couple of fields required for our output component to already described configuration.","We will need those fields to determine key and value attributes for our Hazelcast map.","As our output component needs to work in distributed environments it should implement Serializable interface.","Let’s take a look at the skeleton of our output component.","in real implementation you can desire to bulk write the updates accordingly to groups, see Processor description","Let’s implement all methods required for our output.","We will need Hazelcast instance and Hazelcast map. We add those as attributes to the output. <1> Here we create an instance of hazelcast according to the provided configuration. Here you can notice that we use the injected HazelcastService instance to perform that. This service is implemented in the project. See the implementation in \"Create an input component\" tutorial. <2> We get the Hazelcast map according to the map name from configuration. We use Hazelcast instance for that purpose.","in production you will not want to create one instance per thread/worker but we will cover that in another coming tutorial","We shutdown the instance that we have created in the PostConstruct and we free the Hazelcast map reference.","Here is the full code source for the output to have a global view of it. Read more about output…","We have seen how to create a complete working output in this tutorial. Later we will explain how to create some unit tests for it."]}]