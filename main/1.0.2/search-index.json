[{"lang":"en","title":"Advanced: defining a custom API","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/services-custom-api.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Advanced: defining a custom API"],"lvl1":["Extending the UI"],"text":["It is possible to extend the Component API for custom front features.","What is important here is to keep in mind that you should do it only if it targets not portable components (only used by the Studio or Beam).","It is recommended to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI, add an annotation that can be put on @Option fields, and that is decorated with @Ui. All its members are then put in the metadata of the parameter. For example:"]},{"lang":"en","title":"Beam testing","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/testing-beam.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Beam testing"],"text":["If you want to make sure that your component works in Beam and don’t want to use Spark, you can try with the Direct Runner.","Check beam.apache.org/contribute/testing/ for more details."]},{"lang":"en","title":"Built-in services","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/services-built-in.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Built-in services"],"lvl1":["Using HttpClient"],"lvl2":["Customizing HTTP client requests"],"text":["The framework provides built-in services that you can inject by type in components and actions.","Here is the list:","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data that does not need to be recomputed very often. Commonly used by actions for UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates.","javax.json.bind.Jsonb","A JSON-B instance. If your model is static and you don’t want to handle the serialization manually using JSON-P, you can inject that instance.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration that can be used during the design.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve files from Maven coordinates (like dependencies.txt for component). Note that it assumes that the files are available in the component Maven repository.","org.talend.sdk.component.api.service.injector.Injector","Utility to inject services in fields marked with @Service.","org.talend.sdk.component.api.service.factory.ObjectFactory","Allows to instantiate an object from its class name and properties.","It is not recommended to use it for the runtime because the local configuration is usually different and the instances are distinct.","You can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","Lets you define an HTTP client in a declarative manner using an annotated interface.","See the Using HttpClient for more details.","All these injected services are serializable, which is important for big data environments. If you create the instances yourself, you cannot benefit from these features, nor from the memory optimization done by the runtime. Prefer reusing the framework instances over custom ones.","The HttpClient usage is described in this section by using the REST API example below. It is assume that it requires a basic authentication header.","GET /api/records/{id}","-","POST /api/records","JSON payload to be created: {\"id\":\"some id\", \"data\":\"some data\"}","To create an HTTP client that is able to consume the REST API above, you need to define an interface that extends HttpClient.","The HttpClient interface lets you set the base for the HTTP address that the client will hit.","The base is the part of the address that needs to be added to the request path to hit the API.","Every method annotated with @Request in the interface defines an HTTP request. Every request can have a @Codec parameter that allows to encode or decode the request/response payloads.","You can ignore the encoding/decoding for String and Void payloads.","The interface should extend HttpClient.","In the codec classes (that implement Encoder/Decoder), you can inject any of your service annotated with @Service or @Internationalized into the constructor. Internationalization services can be useful to have internationalized messages for errors handling.","The interface can be injected into component classes or services to consume the defined API.","By default, /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases, you can customize the Connection by directly using @UseConfigurer on the method. It calls your custom instance of Configurer. Note that you can use @ConfigurerOption in the method signature to pass some Configurer configurations.","For example, if you have the following Configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:"]},{"lang":"en","title":"Component Loading","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/component-loading.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Component Loading"],"lvl1":["Packaging a plugin","Packaging an application","Component scanning rules and default exclusions"],"lvl2":["Dependencies","Listing needed plugins","maven-shade-plugin extensions","Jars Scanning","Package Scanning"],"lvl3":["Creating a nested Maven repository with maven-shade-plugin","ContainerDependenciesTransformer","PluginTransformer"],"text":["Talend Component scanning is based on plugins. To make sure that plugins can be developed in parallel and avoid conflicts, plugins need to be isolated (component or group of components in a single jar/plugin).","Multiple options are available:","Graph classloading: this option allows you to link the plugins and dependencies together dynamically in any direction. For example, the graph classloading can be illustrated by OSGi containers.","Tree classloading: a shared classloader inherited by plugin classloaders. However, plugin classloader classes are not seen by the shared classloader, nor by other plugins. For example, he tree classloading is commonly used by Servlet containers where plugins are web applications.","Flat classpath: listed for completeness but rejected by design because it doesn’t comply with this requirement.","In order to avoid much complexity added by this layer, Talend Component Kit relies on a tree classloading. The advantage is that you don’t need to define the relationship with other plugins/dependencies, because it is built-in.","Here is a representation of this solution:","","The shared area contains Talend Component Kit API, which only contains by default the classes shared by the plugins.","Then, each plugin is loaded with its own classloader and dependencies.","This section explains the overall way to handle dependencies but the Talend Maven plugin provides a shortcut for that.","A plugin is a JAR file that was enriched with the list of its dependencies. By default, Talend Component Kit runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt. You just need to make sure that your component defines the following plugin:","Once build, check the JAR file and look for the following lines:","What is important to see is the scope related to the artifacts:","The APIs (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (they come with the framework).","Your specific dependencies (awesome-project in the example above) are marked as compile: they are included as needed dependencies by the framework (note that using runtime works too).","the other dependencies are ignored. For example, test dependencies.","Even if a flat classpath deployment is possible, it is not recommended because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local Maven repository layout. As a quick reminder, it looks like:","This is all the layout the framework uses. The logic converts t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component Kit runtime has two ways to find an artifact:","From the file system based on a configured Maven 2 repository.","From a fat JAR (uber JAR) with a nested Maven repository under MAVEN-INF/repository.","The first option uses either ${user.home}/.m2/repository default) or a specific path configured when creating a ComponentManager. The nested repository option needs some configuration during the packaging to ensure the repository is correctly created.","To create the nested MAVEN-INF/repository repository, you can use the nested-maven-repository extension:","Plugins are usually programmatically registered. If you want to make some of them automatically available, you need to generate a TALEND-INF/plugins.properties file that maps a plugin name to coordinates found with the Maven mechanism described above.","You can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven-shade-plugin:","The configuration unrelated to transformers depends on your application.","ContainerDependenciesTransformer embeds a Maven repository and PluginTransformer to create a file that lists (one per line) artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma-separated list of scopes to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system or test).","include: a comma-separated list of artifacts to include in the artifact filtering.","exclude: a comma-separated list of artifacts to exclude in the artifact filtering.","userArtifacts: a list of artifacts (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline. This parameter is mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included. Set to true by default.","includeProjectComponentDependencies: should project component dependencies be included. Set to false by default. It is not needed when a job project uses isolation for components.","userArtifacts: set of component artifacts to include.","With the component tooling, it is recommended to keep default locations. Also if you need to use project dependencies, you can need to refactor your project structure to ensure component isolation. Talend Component Kit lets you handle that part but the recommended practice is to use userArtifacts for the components instead of project <dependencies>.","ContainerDependenciesTransformer specific configuration is as follows:","repositoryBase: base repository location (MAVEN-INF/repository by default).","ignoredPaths: a comma-separated list of folders not to create in the output JAR. This is common for folders already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties`).","For example, if you want to list only the plugins you use, you can configure this transformer as follows:","The framework uses two kind of filterings when scanning your component. One based on the JAR name and one based on the package name. Make sure that your component definitions (including services) are in a scanned module if they are not registered manually using ComponentManager.instance().addPlugin(), and that the component package is not excluded.","To find components the framework can scan the classpath but in this case, to avoid to scan the whole classpath which can be really huge an impacts a lot the startup time, several jars are excluded out of the box.","These jars use the following prefix:","ApacheJMeter","FastInfoset","HdrHistogram","HikariCP","PDFBox","RoaringBitmap-","XmlSchema-","accessors-smart","activation-","activeio-","activemq-","aeron","aether-","agrona","akka-","animal-sniffer-annotation","annotation","ant-","antlr-","antlr4-","aopalliance-","apache-el","apache-mime4j","apacheds-","api-asn1-","api-common-","api-util-","apiguardian-api-","app-","archaius-core","args4j-","arquillian-","asciidoctorj-","asm-","aspectj","async-http-client-","auto-value-","autoschema-","avalon-framework-","avro-","avro4s-","awaitility-","aws-","axis-","axis2-","base64-","batchee-jbatch","batik-","bcmail","bcpkix","bcprov-","beam-model-","beam-runners-","beam-sdks-","bigtable-client-","bigtable-protos-","boilerpipe-","bonecp","bootstrap.jar","brave-","bsf-","build-link","bval","byte-buddy","c3p0-","cache","carrier","cassandra-driver-core","catalina-","catalina.jar","cats","cdi-","cglib-","charsets.jar","chill","classindex","classmate","classutil","classycle","cldrdata","commands-","common-","commons-","component-api","component-form","component-runtime","component-server","component-spi","component-studio","components-adapter-beam","components-api","components-common","compress-lzf","config","constructr","container-core","contenttype","coverage-agent","cryptacular-","cssparser-","curator-","curvesapi-","cxf-","daikon","databinding","dataquality","dataset-","datastore-","debugger-agent","deltaspike-","deploy.jar","derby-","derbyclient-","derbynet-","dnsns","dom4j","draw2d","easymock-","ecj-","eclipselink-","ehcache-","el-api","enumeratum","enunciate-core-annotations","error_prone_annotations","expressions","fastutil","feign-core","feign-hystrix","feign-slf4j","filters-helpers","findbugs-","fluent-hc","fluentlenium-core","fontbox","freemarker-","fusemq-leveldb-","gax-","gcsio-","gef-","geocoder","geronimo-","gmbal","google-","gpars-","gragent.jar","graph","grizzled-scala","grizzly-","groovy-","grpc-","gson-","guava-","guice-","h2-","hadoop-","hamcrest-","hawtbuf-","hawtdispatch-","hawtio-","hawtjni-runtime","help-","hibernate-","hk2-","howl-","hsqldb-","htmlunit-","htrace-","httpclient-","httpcore-","httpmime","hystrix","iban4j-","icu4j-","idb-","idea_rt.jar","instrumentation-api","ion-java","isoparser-","istack-commons-runtime-","ivy-","j2objc-annotations","jBCrypt","jaccess","jackcess-","jackson-","janino-","jansi-","jasper-el.jar","jasper.jar","jasypt-","java-atk-wrapper","java-libpst-","java-support-","java-xmlbuilder-","javacsv","javaee-","javaee-api","javassist-","javaws.jar","javax.","jaxb-","jaxp-","jbake-","jboss-","jbossall-","jbosscx-","jbossjts-","jbosssx-","jcache","jce.jar","jcip-annotations","jcl-over-slf4j-","jcommander-","jdbcdslog-1","jempbox","jersey-","jets3t","jettison-","jetty-","jface","jfairy","jffi","jfr.jar","jfxrt.jar","jfxswt","jhighlight","jjwt","jline","jmatio-","jmdns-","jmespath-","jms","jmustache","jna-","jnr-","jobs-","joda-convert","joda-time-","johnzon-","jolokia-","jopt-simple","jruby-","json-","json4s-","jsonb-api","jsoup-","jsp-api","jsr","jsse.jar","jta","jul-to-slf4j-","juli-","junit-","junit5-","juniversalchardet","junrar-","jwt","jython","kafka","kahadb-","kotlin-runtime","kryo","leveldb","libphonenumber","lift-json","lmdbjava","localedata","log4j-","logback","logging-event-layout","logkit-","lombok","lucene","lz4","machinist","macro-compat","mail-","management-","mapstruct-","maven-","mbean-annotation-api-","meecrowave-","mesos-","metadata-extractor-","metrics-","microprofile-config-api-","mimepull-","mina-","minlog","mockito-core","mqtt-client-","multitenant-core","multiverse-core-","mx4j-","myfaces-","mysql-connector-java-","nashorn","neethi-","neko-htmlunit","nekohtml-","netflix","netty-","nimbus-jose-jwt","objenesis-","okhttp","okio","opencensus-","openjpa-","openmdx-","opennlp-","opensaml-","opentest4j-","openwebbeans-","openws-","ops4j-","org.apache.aries","org.apache.commons","org.apache.log4j","org.eclipse.","org.junit.","org.osgi.core-","org.osgi.enterprise","org.talend","orient-commons-","orientdb-core-","orientdb-nativeos-","oro-","osgi","paranamer","parquet","pax-url","pdfbox","play","plexus-","plugin.jar","poi-","postgresql","preferences-","prefixmapper","proto-","protobuf-","py4j-","pyrolite-","qdox-","quartz-2","quartz-openejb-","reactive-streams","reflectasm-","reflections","regexp-","registry-","resources.jar","rhino","ribbon","rmock-","rome","routes-compiler","routines","rt.jar","runners","runtime-","rxjava","rxnetty","saaj-","sac-","scala","scalap","scalatest","scannotation-","selenium","serializer-","serp-","service-common","servlet-api-","servo-","shaded","shapeless","shrinkwrap-","sisu-guice","sisu-inject","slf4j-","slick","smack-","smackx-","snakeyaml-","snappy-","spark-","specs2","spring-","sshd-","ssl-config-core","stax-api-","stax2-api-","stream","sunec.jar","sunjce_provider","sunpkcs11","surefire-","swagger-","swizzle-","sxc-","system-rules","tachyon-","tagsoup-","talend-icon","test-agent","test-interface","testng-","threetenbp","tika-","tomcat","tomee-","tools.jar","twirl","twitter4j-","tyrex","uncommons","unused","util","validation-api-","velocity-","wagon-","wandou","webbeans-","websocket","woodstox-core","workbench","ws-commons-util-","wsdl4j-","wss4j-","wstx-asl-","xalan-","xbean-","xercesImpl-","xlsx-streamer-","xml-apis-","xml-resolver-","xmlbeans-","xmlenc-","xmlgraphics-","xmlpcore","xmlpull-","xmlrpc-","xmlschema-","xmlsec-","xmltooling-","xmlunit-","xstream-","xz-","zipfs.jar","zipkin-","ziplock-","zkclient","zookeeper-","Since the framework can be used in the case of fatjars or shades, and because it still uses scanning, it is important to ensure we don’t scan the whole classes for performances reason.","Therefore, the following packages are ignored:","avro.shaded","com.codehale.metrics","com.ctc.wstx","com.datastax.driver.core","com.fasterxml.jackson.annotation","com.fasterxml.jackson.core","com.fasterxml.jackson.databind","com.fasterxml.jackson.dataformat","com.fasterxml.jackson.module","com.google.common","com.google.thirdparty","com.ibm.wsdl","com.jcraft.jsch","com.kenai.jffi","com.kenai.jnr","com.sun.istack","com.sun.xml.bind","com.sun.xml.messaging.saaj","com.sun.xml.txw2","com.thoughtworks","io.jsonwebtoken","io.netty","io.swagger.annotations","io.swagger.config","io.swagger.converter","io.swagger.core","io.swagger.jackson","io.swagger.jaxrs","io.swagger.model","io.swagger.models","io.swagger.util","javax","jnr","junit","net.sf.ehcache","net.shibboleth.utilities.java.support","org.aeonbits.owner","org.apache.activemq","org.apache.beam","org.apache.bval","org.apache.camel","org.apache.catalina","org.apache.commons.beanutils","org.apache.commons.cli","org.apache.commons.codec","org.apache.commons.collections","org.apache.commons.compress","org.apache.commons.dbcp2","org.apache.commons.digester","org.apache.commons.io","org.apache.commons.jcs.access","org.apache.commons.jcs.admin","org.apache.commons.jcs.auxiliary","org.apache.commons.jcs.engine","org.apache.commons.jcs.io","org.apache.commons.jcs.utils","org.apache.commons.lang","org.apache.commons.lang3","org.apache.commons.logging","org.apache.commons.pool2","org.apache.coyote","org.apache.cxf","org.apache.geronimo.javamail","org.apache.geronimo.mail","org.apache.geronimo.osgi","org.apache.geronimo.specs","org.apache.http","org.apache.jcp","org.apache.johnzon","org.apache.juli","org.apache.logging.log4j.core","org.apache.logging.log4j.jul","org.apache.logging.log4j.util","org.apache.logging.slf4j","org.apache.meecrowave","org.apache.myfaces","org.apache.naming","org.apache.neethi","org.apache.openejb","org.apache.openjpa","org.apache.oro","org.apache.tomcat","org.apache.tomee","org.apache.velocity","org.apache.webbeans","org.apache.ws","org.apache.wss4j","org.apache.xbean","org.apache.xml","org.apache.xml.resolver","org.bouncycastle","org.codehaus.jackson","org.codehaus.stax2","org.codehaus.swizzle.Grep","org.codehaus.swizzle.Lexer","org.cryptacular","org.eclipse.jdt.core","org.eclipse.jdt.internal","org.fusesource.hawtbuf","org.h2","org.hamcrest","org.hsqldb","org.jasypt","org.jboss.marshalling","org.joda.time","org.jose4j","org.junit","org.jvnet.mimepull","org.metatype.sxc","org.objectweb.asm","org.objectweb.howl","org.openejb","org.opensaml","org.slf4j","org.swizzle","org.terracotta.context","org.terracotta.entity","org.terracotta.modules.ehcache","org.terracotta.statistics","org.tukaani","org.yaml.snakeyaml","serp","it is not recommanded but possible to add in your plugin module a TALEND-INF/scanning.properties file with classloader.includes and classloader.excludes entries to refine the scanning with custom rules. In such a case, exclusions win over inclusions."]},{"lang":"en","title":"Component internationalization","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/component-internationalization.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Component internationalization"],"lvl1":["Default components keys"],"text":["In common cases, you can store messages using a properties file in your component module to use internationalization.","Store the properties file in the same package as the related components and name it Messages. For example, org.talend.demo.MyComponent uses org.talend.demo.Messages[locale].properties.","Out of the box components are internationalized using the same location logic for the resource bundle. The supported keys are:","Name Pattern","Description","${family}._displayName","Display name of the family","${family}.${configurationType}.${name}._displayName","Display name of a configuration type (dataStore or dataSet)","${family}.${component_name}._displayName","Display name of the component (used by the GUIs)","${property_path}._displayName","Display name of the option.","${simple_class_name}.${property_name}._displayName","Display name of the option using its class name.","${enum_simple_class_name}.${enum_name}._displayName","Display name of the enum_name value of the enum_simple_class_name enumeration.","${property_path}._placeholder","Placeholder of the option.","Example of configuration for a component named list and belonging to the memory family (@Emitter(family = \"memory\", name = \"list\")):","Configuration classes can be translated using the simple class name in the messages properties file. This is useful in case of common configurations shared by multiple components.","For example, if you have a configuration class as follows :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the configuration class.","If you have a display name using the property path, it overrides the display name defined using the simple class name. This rule also applies to placeholders."]},{"lang":"en","title":"Configuring components","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/component-configuration.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Configuring components"],"lvl1":["Primitives","Complex object mapping","Defining Constraints and validations on the configuration","Marking a configuration as a particular type of data","Defining links between properties","Adding hints about the rendering based on configuration/component knowledge"],"lvl2":["List case","Map case"],"text":["Components are configured using their constructor parameters. They can all be marked with the @Option property, which lets you give a name to parameters.","For the name to be correct, you must follow these guidelines:","Use a valid Java name.","Do not include any . character in it.","Do not start the name with a $.","Defining a name is optional. If you don’t set a specific name, it defaults to the bytecode name, which can require you to compile with a -parameter flag to not end up with names such as arg0, arg1, and so on.","Parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","It is recommended to use simple models which can be serialized in order to ease serialized component implementations.","For example:","Using this kind of API makes the configuration extensible and component-oriented, which allows you to define all you need.","The instantiation of the parameters is done from the properties passed to the component.","Examples of option names:","Option name","Valid","myName","","my_name","","my.name","","$myName","","A primitive is a class which can be directly converted from a String to the expected type.","It includes all Java primitives, like the String type itself, but also all types with a org.apache.xbean.propertyeditor.Converter:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","The conversion from property to object uses the Dot notation.","For example, assuming the method parameter was configured with @Option(\"file\"):","matches","Lists rely on an indexed syntax to define their elements.","For example, assuming that the list parameter is named files and that the elements are of the FileOptions type, you can define a list of two elements as follows:","Similarly to the list case, the map uses .key[index] and .value[index] to represent its keys and values:","Avoid using the Map type. For example, if you can configure your component with an object instead.","You can use metadata to specify that a field is required or has a minimum size, and so on. This is done using the validation metadata in the org.talend.sdk.component.api.configuration.constraint package:","API","Name","Parameter Type","Description","Supported Types","Metadata sample","@org.talend.sdk.component.api.configuration.constraint.Max","maxLength","double","Ensure the decorated option size is validated with a higher bound.","CharSequence","{\"validation::maxLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minLength","double","Ensure the decorated option size is validated with a lower bound.","CharSequence","{\"validation::minLength\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Pattern","pattern","string","Validate the decorated string with a javascript pattern (even into the Studio).","CharSequence","{\"validation::pattern\":\"test\"}","@org.talend.sdk.component.api.configuration.constraint.Max","max","double","Ensure the decorated option size is validated with a higher bound.","Number, int, short, byte, long, double, float","{\"validation::max\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","min","double","Ensure the decorated option size is validated with a lower bound.","Number, int, short, byte, long, double, float","{\"validation::min\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Required","required","-","Mark the field as being mandatory.","Object","{\"validation::required\":\"true\"}","@org.talend.sdk.component.api.configuration.constraint.Max","maxItems","double","Ensure the decorated option size is validated with a higher bound.","Collection","{\"validation::maxItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Min","minItems","double","Ensure the decorated option size is validated with a lower bound.","Collection","{\"validation::minItems\":\"12.34\"}","@org.talend.sdk.component.api.configuration.constraint.Uniques","uniqueItems","-","Ensure the elements of the collection must be distinct (kind of set).","Collection","{\"validation::uniqueItems\":\"true\"}","When using the programmatic API, metadata is prefixed by tcomp::. This prefix is stripped in the web for convenience, and the table above uses the web keys.","Also note that these validations are executed before the runtime is started (when loading the component instance) and that the execution will fail if they don’t pass. If somehow it breaks your application you can disable that validation on the JVM by setting the system property talend.component.configuration.validation.skip to true.","It is common to classify the incoming data. It is similar to tagging data with several types. Data can commonly be categorized as follows:","Datastore: The data you need to connect to the backend.","Dataset: A datastore coupled with the data you need to execute an action.","API","Type","Description","Metadata sample","org.talend.sdk.component.api.configuration.type.DataSet","dataset","Mark a model (complex object) as being a dataset.","{\"tcomp::configurationtype::type\":\"dataset\",\"tcomp::configurationtype::name\":\"test\"}","org.talend.sdk.component.api.configuration.type.DataStore","datastore","Mark a model (complex object) as being a datastore (connection to a backend).","{\"tcomp::configurationtype::type\":\"datastore\",\"tcomp::configurationtype::name\":\"test\"}","The component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","Those configuration types can be composed to provide one configuration item. For example, a dataset type often needs a datastore type to be provided. A datastore type (that provides the connection information) is used to create a dataset type.","Those configuration types are also used at design time to create shared configurations that can be stored and used at runtime.","For example, in the case of a relational database that supports JDBC:","A datastore can be made of:","a JDBC URL","a username","a password.","A dataset can be made of:","a datastore (that provides the data required to connect to the database)","a table name","data.","The component server scans all configuration types and returns a configuration type index. This index can be used for the integration into the targeted platforms (Studio, web applications, and so on).","The configuration type index is represented as a flat tree that contains all the configuration types, which themselves are represented as nodes and indexed by ID.","Every node can point to other nodes. This relation is represented as an array of edges that provides the child IDs.","As an illustration, a configuration type index for the example above can be defined as follows:","If you need to define a binding between properties, you can use a set of annotations:","API","Name","Description","Metadata Sample","@org.talend.sdk.component.api.configuration.condition.ActiveIf","if","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","{\"condition::if::target\":\"test\",\"condition::if::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.condition.ActiveIfs","ifs","Allows to set multiple visibility conditions on the same property.","{\"condition::if::value::0\":\"value1,value2\",\"condition::if::value::1\":\"SELECTED\",\"condition::if::target::0\":\"sibling1\",\"condition::if::target::1\":\"../../other\"}","The target element location is specified as a relative path to the current location, using Unix path characters. The configuration class delimiter is /. The parent configuration class is specified by ... Thus, ../targetProperty denotes a property, which is located in the parent configuration class and is named targetProperty.","When using the programmatic API, metadata is prefixed with tcomp::. This prefix is stripped in the web for convenience, and the previous table uses the web keys.","In some cases, you may need to add metadata about the configuration to let the UI render that configuration properly. For example, a password value that must be hidden and not a simple clear input box. For these cases - if you want to change the UI rendering - you can use a particular set of annotations:","API","Description","Generated property metadata","@org.talend.sdk.component.api.configuration.ui.DefaultValue","Provide a default value the UI can use - only for primitive fields.","{\"ui::defaultvalue::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.OptionsOrder","Allows to sort a class properties.","{\"ui::optionsorder::value\":\"value1,value2\"}","@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Request the rendered to do what it thinks is best.","{\"ui::autolayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","{\"ui::gridlayout::value1::value\":\"first|second,third\",\"ui::gridlayout::value2::value\":\"first|second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","{\"ui::gridlayout::Advanced::value\":\"another\",\"ui::gridlayout::Main::value\":\"first|second,third\"}","@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI an horizontal layout is preferred.","{\"ui::horizontallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","{\"ui::verticallayout\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being represented by some code widget (vs textarea for instance).","{\"ui::code::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a credential. It is typically used to hide the value in the UI.","{\"ui::credential\":\"true\"}","@org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a List<String> or Map<String, String> field as being represented as the component data selector (field names generally or field names as key and type as value).","{\"ui::structure::type\":\"null\",\"ui::structure::discoverSchema\":\"test\",\"ui::structure::value\":\"test\"}","@org.talend.sdk.component.api.configuration.ui.widget.TextArea","Mark a field as being represented by a textarea(multiline text input).","{\"ui::textarea\":\"true\"}","When using the programmatic API, metadata is prefixed with tcomp::. This prefix is stripped in the web for convenience, and the previous table uses the web keys.","Target support should cover org.talend.core.model.process.EParameterFieldType but you need to ensure that the web renderer is able to handle the same widgets."]},{"lang":"en","title":"Creating a job pipeline","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/services-pipeline.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Creating a job pipeline"],"lvl1":["Job Builder","Beam case"],"lvl2":["Environment/Runner","Key Provider","Inputs and Outputs","Processors","Converting a Beam.io into a component I/O"],"text":["The Job builder lets you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, allowing you to build complex pipelines.","Let’s take a simple use case where two data sources (employee and salary) are formatted to CSV and the result is written to a file.","A job is defined based on components (nodes) and links (edges) to connect their branches together.","Every component is defined by a unique id and an URI that identify the component.","The URI follows the form [family]://[component][?version][&configuration], where:","family is the name of the component family.","component is the name of the component.","version is the version of the component. It is represented in a key=value format. The key is __version and the value is a number.","configuration is component configuration. It is represented in a key=value format. The key is the path of the configuration and the value is a `string' corresponding to the configuration value.","configuration parameters must be URI/URL encoded.","It has some starting components (components that don’t have a from connection and that need to be of the producer type).","There are no cyclic connections. The job pipeline needs to be an acyclic graph.","All components used in the connections are already declared.","Each connection is used only once. You cannot connect a component input/output branch twice.","In this version, the execution of the job is linear. Components are not executed in parallel even if some steps may be independents.","Depending on the configuration, you can select the environment which you execute your job in.","To select the environment, the logic is the following one:","If an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder class is passed through the job properties, then use it. The supported types are a ExecutionBuilder instance, a Class or a String.","if an ExecutionBuilder SPI is present, use it. It is the case if component-runtime-beam is present in your classpath.","else, use a local/standalone execution.","In the case of a Beam execution, you can customize the pipeline options using system properties. They have to be prefixed with talend.beam.job.. For example, to set the appName option, you need to use -Dtalend.beam.job.appName=mytest.","The job builder lets you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job.","If the incoming data has different IDs, you can provide a complex global key provider that relies on the context given by the component id and the branch name.","For Beam case, you need to rely on Beam pipeline definition and use the component-runtime-beam dependency, which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and to integrate it into the pipeline.","The multiple inputs and outputs are represented by a Map element in Beam case to avoid using multiple inputs and outputs.","You can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, like Map<String, List<?>>, but materialized as a JsonObject. Input data must be of the JsonObject type in this case.","For simple inputs and outputs, you can get an automatic and transparent conversion of the Beam.io into an I/O component, if you decorated your PTransform with @PartitionMapper or @Processor.","However, there are limitations:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and register a DoFn on the input PCollection.","For more information, see the How to wrap a Beam I/O page."]},{"lang":"en","title":"Creating components for REST API","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-create-components-rest-api.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Creating components for REST API"],"lvl1":["Setting up the HTTP client","Configuring the component","Defining the component mapper","Defining the component source"],"lvl2":["Configuring basic authentication","Configuring the dataset"],"text":["This tutorial shows how to create components that consume a REST API.","The component developed as example in this tutorial is an input component that provides a search functionality for Zendesk using its Search API. Lombok is used to avoid writing getter, setter and constructor methods.","You can generate a project using the Talend Components Kit starter, as described in this tutorial.","The input component relies on Zendesk Search API and requires an HTTP client to consume it.","The Zendesk Search API takes the following parameters on the /api/v2/search.json endpoint.","query : The search query.","sort_by : The sorting type of the query result. Possible values are updated_at, created_at, priority, status, ticket_type, or relevance. It defaults to relevance.","sort_order: The sorting order of the query result. Possible values are asc (for ascending) or desc (for descending). It defaults to desc.","Talend Component Kit provides a built-in service to create an easy-to-use HTTP client in a declarative manner, using Java annotations.","No additional implementation is needed for the interface, as it is provided by the component framework, according to what is defined above.","This HTTP client can be injected into a mapper or a processor to perform HTTP requests.","This example uses the basic authentication that supported by the API.","The first step is to set up the configuration for the basic authentication. To be able to consume the Search API, the Zendesk instance URL, the username and the password are needed.","The data store is now configured. It provides a basic authentication token.","Once the data store is configured, you can define the dataset by configuring the search query. It is that query that defines the records processed by the input component.","Your component is configured. You can now create the component logic.","Mappers defined with this tutorial don’t implement the split part because HTTP calls are not split on many workers in this case.","Once the component logic implemented, you can create the source in charge of performing the HTTP request to the search API and converting the result to JsonObject records.","You now have created a simple Talend component that consumes a REST API.","To learn how to test this component, refer to this tutorial."]},{"lang":"en","title":"Generating a project using the Component Kit starter","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-generate-project-using-starter.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Generating a project using the Component Kit starter"],"lvl1":["Configuring the project","Creating an Input component","Creating a Processor component","Creating an Output component","Generating and downloading the final project.","Compiling and exploring the generated project files"],"text":["The Component Kit starter lets you design your components configuration and generates a ready-to-implement project structure.","This tutorial shows you how to use the Component Kit starter to generate new components for MySQL databases. Before starting, make sure that you have correctly setup your environment. See this section.","Before being able to create components, you need to define the general settings of the project:","Create a folder on your local machine to store the resource files of the component you want to create. For example, C:/my_components.","Open the starter in the web browser of your choice.","Select your build tool. This tutorial uses Maven, but you can select Gradle instead.","Add the Talend Component Kit Testing facet to your project to automatically generate unit tests for the components created later in this tutorial.","Enter the Component Family of the components you want to develop in the project. This name must be a valid java name and is recommended to be capitalized, for example 'MySQL'. Once you have implemented your components in the Studio, this name is displayed in the Palette to group all of the MySQL-related components you develop, and is also part of your component name.","Select the Category of the components you want to create in the current project. As MySQL is a kind of database, select Databases in this tutorial. This Databases category is used and displayed as the parent family of the MySQL group in the Palette of the Studio.","Complete the project metadata by entering the Group, Artifact and Package.","Click the ADD A COMPONENT button to start designing your components.","When clicking ADD A COMPONENT in the starter, a new step that allows you to define a new component is created in your project. The intent in this tutorial is to create an input component that connects to a MySQL database, executes a SQL query and gets the result.","Choose the component type. INPUT in this case.","Enter the component name. For example, MySQLInput.","Click CONFIGURATION MODEL. This button lets you specify the required configuration for the component.","For each parameter that you need to add, click the (+) button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes. In this tutorial, to be able to execute a SQL query on the Input MySQL database, the configuration requires the following parameters:+","a connection URL (string)","a username (string)","a password (string)","the SQL query to be executed (string).","Closing the configuration panel on the right does not delete your configuration.","Specify whether the component issues a stream or not. In this tutorial, the MySQL input component created is an ordinary (non streaming) component. In this case, let the toggle button disabled.","Select the Record Type generated by the component. In this tutorial, select Generic because the component is designed to generate JSON records. You can also select Custom to define a POJO that represents your records.","Your input component is now defined. You can add another component or generate and download your project.","When clicking ADD A COMPONENT in the starter, a new step that allows you to define a new component is created in your project. The intent in this tutorial is to create a simple processor component that receives a record, logs it and returns it at it is.","Choose the component type. PROCESSOR/OUTPUT in this case.","Enter the component name. For example, RecordLogger, as the processor created in this tutorial logs the records.","Specify the CONFIGURATION MODEL of the component. In this tutorial, the component doesn’t need any specific configuration. Skip this step.","Define the Input(s) of the component. For each input that you need to define, click ADD INPUT. In this tutorial, only one input is needed to receive the record to log.","Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them. The input in this tutorial is a generic record. Enable the Generic option.","Define the Output(s) of the component. For each output that you need to define, click ADD OUTPUT. In this tutorial, only one generic output is needed to return the received record. Outputs can be configured the same way as inputs (see previous steps).","Make sure to check the configuration of inputs and outputs as they are not set to Generic by default.","Your processor component is now defined. You can add another component or generate and download your project.","When clicking ADD A COMPONENT in the starter, a new step that allows you to define a new component is created in your project. The intent in this tutorial is to create an output component that receives a record and inserts it into a MySQL database table.","Output components are Processors without any output. In other words, the output is a processor that does not produce any records.","Choose the component type. PROCESSOR/OUTPUT in this case.","Enter the component name. For example, MySQLOutput.","Click CONFIGURATION MODEL. This button lets you specify the required configuration for the component.","For each parameter that you need to add, click the (+) button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes. In this tutorial, to be able to insert a record in the output MySQL database, the configuration requires the following parameters:+","a connection URL (string)","a username (string)","a password (string)","the name of the table to insert the record in (string).","Closing the configuration panel on the right does not delete your configuration.","Define the Input(s) of the component. For each input that you need to define, click ADD INPUT. In this tutorial, only one input is needed.","Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them. The input in this tutorial is a generic record. Enable the Generic option.","Do not create any output because the component does not produce any record. This is the only difference between an output an a processor component.","Your output component is now defined. You can add another component or generate and download your project.","Once your project is configured and all the components you need are created, you can generate and download the final project. In this tutorial, the project was configured and three components of different types (input, processor and output) have been defined.","Click GO TO FINISH at the bottom of the page. You are redirected to a page that summarizes the project. On the left panel, you can also see all the components that you added to the project.","Generate the project using one of the two options available:","Download it locally as a ZIP file using the DOWNLOAD AS ZIP button.","Create a Github repository and push the project to it using the CREATE ON GITHUB button.","In this tutorial, the project is downloaded to the local machine as a ZIP file.","Once the package is available on your machine, you can compile it using the build tool selected when configuring the project.","In the tutorial, Maven is the build tool selected for the project. In the project directory, execute the mvn package command. If you don’t have Maven installed on your machine, you can use the Maven wrapper provided in the generated project, by executing the ./mvnw package command.","If you have created a Gradle project, you can compile it using the gradle build command or using the Gradle wrapper: ./gradlew build.","The generated project code contains documentation that can guide and help you implementing the component logic. Import the project to your favorite IDE to start the implementation.","The next tutorial shows how to implement an Input component in details."]},{"lang":"en","title":"Generating data","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/testing-generating-data.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Generating data"],"text":["Several data generators exist if you want to populate objects with a semantic that is more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","etc.","Even more advanced, the following generators allow to directly bind generic data on a model. However, data quality is not always optimal:","github.com/devopsfolks/podam","github.com/benas/random-beans","etc.","There are two main kinds of implementation:","Implementations using a pattern and random generated data.","Implementations using a set of precomputed data extrapolated to create new values.","Check your use case to know which one fits best.","An alternative to data generation can be to import real data and use Talend Studio to sanitize the data, by removing sensitive information and replacing it with generated or anonymized data. Then you just need to inject that file into the system.","If you are using JUnit 5, you can have a look at glytching.github.io/junit-extensions/randomBeans."]},{"lang":"en","title":"Getting started with Talend Component Kit","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/getting-started.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Getting started with Talend Component Kit"],"lvl1":["System Requirements","Main principles"],"text":["Talend Component Kit is a framework designed to simplify the development of components at two levels:","Runtime: Runtime is about injecting the specific component code into a job or pipeline. The framework helps unify as much as possible the code required to run in Data Integration (DI) and BEAM environments.","Graphical interface: The framework helps unify the code required to be able to render the component in a browser (web) or in the Eclipse-based Studio (SWT).","In order to use Talend Component Kit, you need the following tools installed on your machine:","Java JDK 1.8.x. You can download it from Oracle website.","Apache Maven 3.5.x is recommended to develop a component or the project itself. You can download it from Apache Maven website. You can also use Gradle.","A Java Integrated Development Environment such as Eclipse or IntelliJ.","The version of your Studio is 7.0 and onwards.","Developing new components using the framework includes:","Creating a project using the starter or the Talend IntelliJ plugin.","Defining the general configuration model for each component in your project","Generating and downloading the project’s archive from the starter","Compiling the project","Implementing the components","Registering the components family","Defining the layout and configurable part of the components","Defining the partition mapper for Input components","Implementing the source logic for Input components","Defining the processor for Output components","Testing the components","Some additional configuration steps can be necessary according to your requirements:","Generate a component","Create an input component","Create an output component","Test your components","Configuration and sensitive data","Create components for REST API","How to test a REST API","Dev vs CI setup","Talend Intellij plugin"]},{"lang":"en","title":"Gradle Plugin","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/build-tools-gradle.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Gradle Plugin"],"text":["gradle-talend-component helps you write components that match the best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file used by the SDK to build the component classpath. For more information on the configuration, refer to the Maven properties matching the attributes.","You can use it as follows:"]},{"lang":"en","title":"Implementing an Output component","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-create-an-output-component.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Implementing an Output component"],"lvl1":["Defining the configurable part and the layout of the component","Configuring the Output"],"lvl2":["Defining the constructor method","Defining the PostConstruct method","Defining the PreDestroy method","Defining the ElementListener method","Full implementation of the Output"],"text":["This tutorial shows how to create a complete working output component for Hazelcast, including:","Defining the configurable part and the layout of the component.","Defining the output that is responsible for connecting and writing data to the data source.","The methodology to define the component configuration is described in the Implementing an input component tutorial.","In this case, the input component configuration defined in the tutorial mentioned above can be used as a starting point.","Two additional fields are required for the output component:","These fields are used to determine the key and value attributes for the Hazelcast map.","The output component needs to work in distributed environments and should implement a serializable interface.","The skeleton of the output component looks as follows.","If you need to bulk write the updates accordingly to groups, see Processor description.","Each of the methods mentioned above now needs to be created.","To make it work, a Hazelcast instance and a Hazelcast map are required. The corresponding attributes need to be added to the output.","In production, avoid creating one instance per thread/worker.","Shut down the Hazelcast client instance created by the method annotated with @PostConstruct and thus free the Hazelcast map reference.","Once implemented, the Output configuration is as follows. For more information about outputs, refer to this document.","You have now created a complete working output component. You can follow this tutorial to learn how to create unit tests for your new component."]},{"lang":"en","title":"Implementing an input component","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-create-an-input-component.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Implementing an input component"],"lvl1":["Registering the component family","Defining the configurable part and the layout of the component","Configuring The Partition Mapper","Configuring the Producer (Source)"],"lvl2":["Defining the constructor method","Defining the PostConstruct method","Defining the PreDestroy method","Defining the Assessor method","Defining the Split method","The Emitter method","Full implementation of the Partition Mapper"],"text":["This tutorial shows how to create a complete working input component for Hazelcast, including:","Registering the component family.","Defining the configurable part and the layout of the component.","Configuring the partition mapper, to let the input split itself to work in a distributed environment.","Configuring the source that is responsible for connecting and reading data from the data source.","Getter and Setter methods are omitted for simplicity in this tutorial.","The following procedures assume that you have already generated the component package from the Talend Component Kit starter. See this tutorial to learn how to generate this package.","Register the component family via a the package-info.java file in the package of the component.","The component configuration includes defining the part of the components that can be configured once integrated to Talend solutions, in addition to the configuration type and the UI layout.","The configuration is a POJO class decorated with annotations from the component framework. In this case, the component is configured as follows:","Read more about component configuration in this document.","The Hazelcast component created through this tutorial needs to work first in distributed environments.","Every input component has to define a partition mapper class.","At runtime, this class heuristically estimates the size of the data to be handled. Based on this estimation and on the capacity of the execution engine of your component, it divides the work of your component to reduce the overall execution time.","For more information about the partition mapper class, see Partition mapper.","The skeleton of the partition mapper looks as follows:","Configuration parameters are annotated with @Option.","Other parameters are considered as services and are injected by the component framework. Services can be local (classes annotated with @Service) or provided by the component framework.","Each of the methods mentioned above now needs to be created.","The @PostConstruct method is used to initialize a Hazelcast client instance.","The HazelcastService is implemented as follows. Every class annotated with @Service can be injected to the component via its constructor.","The method annotated with @PreDestroy cleans up the resources at the end of the execution of the partition mapper.","The method annotated with @Assessor is used to estimate the volume of the dataset to be handled.","Then, you can Implement the methods annotated with @PreDestroy and @Accessor to create a map of the volumes of the Hazelcast cluster members.","The method annotated with @Split dynamically splits the partition mapper into a collection of sub-mappers according to:","the bundle size required by the execution engine to be used.","to the volume of the dataset to handle.","The method annotated with @Emitter generates producers using the component configuration. It can be used to load data to the processing flow of a Talend Job. Each sub-mapper generates one producer.","Once implemented, the Partition Mapper configuration is as follows. For more information about Partition Mappers, refer to this document.","The component configuration and the partition mapper in charge of creating the producers are now defined. At this point, you can implement the source logic that uses the configuration provided by the mapper to read the records from the data source.","To implement a source, you need to define the producer method that creates a record every time it is invoked.","To learn more about producers, refer to this document.","You have now created a complete working input component. You can follow this tutorial to learn how to create unit tests for your new component."]},{"lang":"en","title":"Integrating components into Talend Studio","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/studio.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Integrating components into Talend Studio"],"lvl1":["Design","Installing the components","Configuring the components"],"lvl2":["Random port when running concurrent studio instances","Developer mode"],"text":["The Studio integration relies on the Component Server (see Web for more details).","When the plugin is deployed, it starts a local server that the Studio uses to gather data about the components.","Copy org.talend.sdk.component.studio-integration.jar in the $STUDIO_HOME/plugins directory of the Studio.","Restart the Studio.","Make sure that the component-server dependencies and commons-cli 1.4 are in the Studio Maven repository. If you install any other component, ensure its dependencies are in the repository as well.","you can set the maven.repository value to global in $STUDIO_HOME/configuration/config.ini to reuse your local Maven repository.","The configuration is done in the $STUDIO_HOME/configuration/config.ini file.","Name","Description","Default","component.environment","Enables the developer mode when set to dev","-","component.debounce.timeout","Specifies the timeout (in milliseconds) before calling listeners in components Text fields","750","component.kit.skip","If set to true, the plugin is not enabled. It is useful if you don’t have any component developed with the framework.","false","component.java.arguments","Component server additional options","-","component.java.m2","Maven repository that the server uses to resolve components","Defaults to the global Studio configuration","component.java.coordinates","A list of comma-separated GAV (groupId:artifactId:version) of components to register","-","component.java.registry","A properties file with values matching component GAV (groupId:artifactId:version) registered at startup","-","component.java.port","Sets the port to use for the server","random","components.server.beam.active","Active, if set to true, beam support (Experimental). It requires beam sdk java core dependencies to be available.","false","component.server.jul.forceConsole","Adds a console handler to JUL to see logs in the console. This can be helpful in development because the formatting is clearer than the OSGi one in workspace/.metadata/.log.","It uses the java.util.logging.SimpleFormatter.format property to define its format. By default, it is %1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n, but for development purposes [%4$s] %5$s%6$s%n is simpler and more readable.","false","To activate the plugin and be able to deploy your component, set component.kit.skip to true.","A common developer configuration/config.ini file uses the following specific entries:","If you run multiple Studio instances automatically in parallel, you can run into some issues with the random port computation. For example on a CI platform. For that purpose, you can create the $HOME/.talend/locks/org.talend.sdk.component.studio-integration.lock file.","Then, when a server starts, it acquires a lock on that file and prevents another server to get a port until it is started. It ensures that you can’t have two concurrent processes getting the same port allocated.","However, it is highly unlikely to happen on a desktop. In that case, forcing a different value through component.java.port in your config.ini file is a better solution for local installations.","The developer mode adds a Talend Component Kit button in the main toolbar:","When clicking this button, all components developed with the Talend Component Kit framework are reloaded. The cache is invalidated and the components refreshed.","You still need to add and remove the components to see the changes.","The developer mode can be very useful to see some updates in components without having to restart entirely the Studio."]},{"lang":"en","title":"Internationalizing services","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/services-internationalization.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Internationalizing services"],"lvl1":["Internationalization API"],"text":["Internationalization requires following several best practices:","Storing messages using ResourceBundle properties file in your component module.","The location of the properties is in the same package than the related components and is named Messages. For example, org.talend.demo.MyComponent uses org.talend.demo.Messages[locale].properties.","Use the internationalization API for your own messages.","The Internationalization API is the mechanism to use to internationalize your own messages in your own components.","The principle of the API is to design messages as methods returning String values and get back a template using a ResourceBundle named Messages and located in the same package than the interface that defines these methods.","To ensure your internationalization API is identified, you need to mark it with the @Internationalized annotation:"]},{"lang":"en","title":"Masking sensitive data in your configuration","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-configuration-sensitive-data.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Masking sensitive data in your configuration"],"lvl1":["Marking sensitive data","Related links"],"text":["This tutorial shows how to correctly mask the sensitive data of a component configuration.","It is very common to define credentials when configuring a component. Most common cases can include passwords, secrets, keys (it is also common to show them in plain text in a textarea), and tokens.","For example, this REST client configuration specifies that a username, a password and a token are needed to connect to the REST API:","This configuration defines that these credentials are three simple String, represented as plain inputs, which causes severe security concerns:","The password and token are clearly readable in all Talend user interfaces (Studio or Web),","The password and token are potentially stored in clear.","To avoid this behavior, you need to mark sensitive data as @Credential.","Talend Component Kit provides you with the @Credential marker, that you can use on any @Option. This marker has two effects:","It Replaces the default input widget by a password oriented widget","It Requests the Studio or the Talend Cloud products to store the data as sensitive data (as encrypted values).","In order to ensure that the password and token are never stored in clear or shown in the code, add the @Credential marker to the sensitive data. For example:","Your password and token (or any other sensitive data that you need to mask) are not accessible by error anymore.","Learn more about configuring a component"]},{"lang":"en","title":"Maven Plugin","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/build-tools-maven.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Maven Plugin"],"lvl1":["Dependencies","Validate","Documentation","Testing a component web rendering","Generating inputs or outputs","Talend Component Archive"],"lvl2":["Rendering your documentation"],"lvl3":["HTML rendering","PDF rendering","Including the documentation into a document"],"text":["talend-component-maven-plugin helps you write components that match best practices and generate transparently metadata used by Talend Studio.","You can use it as follows:","This plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, the dependencies, validate and documentation goals will be set up.","The first goal is a shortcut for the maven-dependency-plugin. It creates the TALEND-INF/dependencies.txt file with the compile and runtime dependencies, allowing the component to use it at runtime:","This goal helps you validate the common programming model of the component. To activate it, you can use following execution definition:","It is bound to the process-classes phase by default. When executed, it performs several validations that can be disabled by setting the corresponding flags to false in the <configuration> block of the execution:","Name","Description","Default","validateInternationalization","Validates that resource bundles are presents and contain commonly used keys (for example, _displayName)","true","validateModel","Ensures that components pass validations of the ComponentManager and Talend Component runtime","true","validateSerializable","Ensures that components are Serializable. This is a sanity check, the component is not actually serialized here. If you have a doubt, make sure to test it. It also checks that any @Internationalized class is valid and has its keys.","true","validateMetadata","Ensures that components have an @Icon and a @Version defined.","true","validateDataStore","Ensures that any @DataStore defines a @HealthCheck.","true","validateComponent","Ensures that the native programming model is respected. You can disable it when using another programming model like Beam.","true","validateActions","Validates action signatures for actions not tolerating dynamic binding (@HealthCheck, @DynamicValues, and so on). It is recommended to keep it set to true.","true","validateFamily","Validates the family by verifying that the package containing the @Components has a @Icon property defined.","true","validateDocumentation","Ensures that all components and @Option properties have a documentation using the @Documentation property.","true","validateLayout","Ensures that the layout is referencing existing options and properties.","true","validateOptionNames","Ensures that the option names are compliant with the framework. It is highly recommended and safer to keep it set to true.","true","This goal generates an Asciidoc file documenting your component from the configuration model (@Option) and the @Documentation property that you can add to options and to the component itself.","Name","Description","Default","level","Level of the root title.","2 (==)","output","Output folder path. It is recommended to keep it to the default value.","${classes}/TALEND-INF/documentation.adoc","formats","Map of the renderings to do. Keys are the format (pdf or html) and values the output paths.","-","attributes","Map of asciidoctor attributes when formats is set.","-","templateDir / templateEngine","Template configuration for the rendering.","-","title","Document title.","${project.name}","attachDocumentations","Allows to attach (and deploy) the documentations (.adoc, and formats keys) to the project.","true","If you use the plugin as an extension, you can add the talend.documentation.htmlAndPdf property and set it to true in your project to automatically get HTML and PDF renderings of the documentation.","To render the generated documentation in HTML or PDF, you can use the Asciidoctor Maven plugin (or Gradle equivalent). You can configure both executions if you want both HTML and PDF renderings.","Make sure to execute the rendering after the documentation generation.","If you prefer a HTML rendering, you can configure the following execution in the asciidoctor plugin. The example below:","Generates the components documentation in target/classes/TALEND-INF/documentation.adoc.","Renders the documentation as an HTML file stored in target/documentation/documentation.html.","If you prefer a PDF rendering, you can configure the following execution in the asciidoctor plugin:","If you want to add some more content or a title, you can include the generated document into another document using Asciidoc include directive.","For example:","To be able to do that, you need to pass the generated_doc attribute to the plugin. For example:","This is optional but allows to reuse Maven placeholders to pass paths, which can be convenient in an automated build.","You can find more customization options on Asciidoctor website.","Testing the rendering of your component configuration into the Studio requires deploying the component in Talend Studio (refer to Studio Documentation.","In the case where you need to deploy your component into a Cloud (web) environment, you can test its web rendering by using the web goal of the plugin:","Run the mvn talend-component:web command.","Open the following URL in a web browser: localhost:8080.","Select the component form you want to see from the treeview on the left. The selected form is displayed on the right.","Two parameters are available with the plugin:","serverPort, which allows to change the default port (8080) of the embedded server.","serverArguments, that you can use to pass Meecrowave options to the server. Learn more about that configuration at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","Make sure to install the artifact before using this command because it reads the component JAR from the local Maven repository.","The Mojo generate (Maven plugin goal) of the same plugin also embeds a generator that you can use to bootstrap any input or output component:","It is intended to be used from the command line (or IDE Maven integration) as follows:","For this command to work, you need to register the plugin as follows:","Component ARchive (.car) is the way to bundle a component to share it in the Talend ecosystem. It is a plain Java ARchive (.jar) containing a metadata file and a nested Maven repository containing the component and its depenencies.","This command creates a .car file in your build directory. This file can be shared on Talend platforms.","This CAR is executable and exposes the studio-deploy command which takes a Talend Studio home path as parameter. When executed, it installs the dependencies into the Studio and registers the component in your instance. For example:","You can also upload the dependencies to your Nexus server using the following command:","In this command, Nexus URL and repository name are mandatory arguments. All other arguments are optional. If arguments contain spaces or special symbols, you need to quote the whole value of the argument. For example:"]},{"lang":"en","title":"Providing actions for consumers","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/services-actions.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Providing actions for consumers"],"lvl1":["Particular action types","Internationalization"],"text":["In some cases you can need to add some actions that are not related to the runtime. For example, enabling clients - the users of the plugin/library - to test if a connection works properly.","To do so, you need to define an @Action, which is a method with a name (representing the event name), in a class decorated with @Service:","Services are singleton. If you need some thread safety, make sure that they match that requirement. Services should not store any status either because they can be serialized at any time. Status are held by the component.","Services can be used in components as well (matched by type). They allow to reuse some shared logic, like a client. Here is a sample with a service used to access files:","The service is automatically passed to the constructor. It can be used as a bean. In that case, it is only necessary to call the service method.","Some common actions need a clear contract so they are defined as API first-class citizen. For example, this is the case for wizards or health checks. Here is the list of the available actions:","API","Type","Description","Return type","Sample returned type","@org.talend.sdk.component.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Values","{\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","HealthCheckStatus","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","@org.talend.sdk.component.api.service.schema.DiscoverSchema","schema","Mark an action as returning a discovered schema. Its parameter MUST be the type decorated with @Structure.","Schema","{\"entries\":[{\"name\":\"column1\",\"type\":\"STRING\"}]}","@org.talend.sdk.component.api.service.completion.Suggestions","suggestions","Mark a method as being useful to fill potential values of a string option. You can link a field as being completable using @Suggestable(value). The resolution of the completion action is then done when the user requests it (generally by clicking on a button or entering the field depending the environment).","SuggestionValues","{\"cacheable\":false,\"items\":[{\"id\":\"value\",\"label\":\"label\"}]}","@org.talend.sdk.component.api.service.Action","user","-","any","-","@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","validation","Mark a method as being used to validate a configuration. IMPORTANT: this is a server validation so only use it if you can’t use other client side validation to implement it.","ValidationResult","{\"comment\":\"Something went wrong\",\"status\":\"KO\"}","Internationalization is supported through the injection of the $lang parameter, which allows you to get the correct locale to use with an @Internationalized service:","You can combine the $lang option with the @Internationalized and @Language parameters."]},{"lang":"en","title":"Registering components","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/component-registering.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Registering components"],"lvl1":["Components metadata"],"lvl2":["Managing version configuration","@PartitionMapper","@Processor"],"lvl3":["@Emitter"],"text":["As you may have read in the Getting Started, you need an annotation to register your component through the family method. Multiple components can use the same family value but the family + name pair must be unique for the system.","In order to share the same component family name and to avoid repetitions in all family methods, you can use the @Components annotation on the root package of your component. It allows you to define the component family and the categories the component belongs to (Misc by default if not set).","Here is a sample package-info.java:","Another example with an existing component:","Components can require metadata to be integrated in Talend Studio or Cloud platforms. Metadata is set on the component class and belongs to the org.talend.sdk.component.api.component package.","API","Description","@Icon","Sets an icon key used to represent the component. You can use a custom key with the custom() method but the icon may not be rendered properly.","@Version","Sets the component version. 1 by default.","Example:","If some changes impact the configuration, they can be managed through a migration handler at the component level (enabling trans-model migration support).","The @Version annotation supports a migrationHandler method which migrates the incoming configuration to the current model.","For example, if the filepath configuration entry from v1 changed to location in v2, you can remap the value in your MigrationHandler implementation.","A best practice is to split migrations into services that you can inject in the migration handler (through constructor) rather than managing all migrations directly in the handler. For example:","What is important to notice in this snippet is not the way the code is organized, but rather the fact that you can organize your migrations the way that best fits your component.","If you need to apply migrations in a specific order, make sure that they are sorted.","Consider this API as a migration callback rather than a migration API. Adjust the migration code structure you need behind the MigrationHandler, based on your component requirements, using service injection.","@PartitionMapper marks a partition mapper:","@Emitter is a shortcut for @PartitionMapper when you don’t support distribution. It enforces an implicit partition mapper execution with an assessor size of 1 and a split returning itself.","A method decorated with @Processor is considered as a producer factory:"]},{"lang":"en","title":"Search Result","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/search.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Search Result","Search results"]},{"lang":"en","title":"Secrets/Passwords and Maven","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/testing-maven-passwords.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Secrets/Passwords and Maven"],"text":["You can reuse Maven settings.xml server files, including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter allows yo to find a username/password from a server identifier:","It is very useful to avoid storing secrets and to perform tests on real systems on a continuous integration platform.","Even if you don’t use Maven on the platform, you can generate the settings.xml and`settings-security.xml` files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details."]},{"lang":"en","title":"Services and interceptors","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/services-interceptors.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Services and interceptors"],"text":["For common concerns such as caching, auditing, and so on, you can use an interceptor-like API. It is enabled on services by the framework.","An interceptor defines an annotation marked with @Intercepts, which defines the implementation of the interceptor (InterceptorHandler).","For example:","The handler is created from its constructor and can take service injections (by type). The first parameter, however, can be BiFunction<Method, Object[], Object>, which represents the invocation chain if your interceptor can be used with others.","If you make a generic interceptor, pass the invoker as first parameter. Otherwise you cannot combine interceptors at all.","Here is an example of interceptor implementation for the @Logged API:","This implementation is compatible with interceptor chains because it takes the invoker as first constructor parameter and it also takes a service injection. Then, the implementation simply does what is needed, which is logging the invoked method in this case.","The findAnnotation annotation, inherited from InterceptorHandler, is an utility method to find an annotation on a method or class (in this order)."]},{"lang":"en","title":"Talend Component Kit Changelog","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/changelog.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Talend Component Kit Changelog"],"lvl1":["Version 1.0.2","Version 1.0.1","Version 1.0.0","Version 0.0.12","Version 0.0.11","Version 0.0.10","Version 0.0.9","Version 0.0.8","Version 0.0.7","Version 0.0.6","Version 0.0.5","Version 0.0.4","Version 0.0.3","Version 0.0.2","Version 0.0.1"],"lvl2":["Bug","New Feature","Work Item","Backlog Task"],"text":["TCOMP-888: Designer pipeline records counter are wrong for tacokit components with multiples outputs","TCOMP-899: Update Beam 2.5.0 compatibility","TCOMP-903: [tacokit studio integration] - Guess schema - better handling of number types recognition","TCOMP-904: [tacokit studio integration] - fix job classpath generation","TCOMP-913: Fix absolute path resolution for child of child use-case","TCOMP-900: [tacokit studio integration] - Handle conditional outputs","TCOMP-898: Ensure starter will be able to auto update its versions to avoid redeployments","TCOMP-905: Enrich scanning exclusion set","TCOMP-906: Minimalist JsonObject to IndexeredRecord utilities for beam","TCOMP-907: Support maxBatchSize as in the studio in Beam","TCOMP-910: Add maxbatchsize as built in parameter to Processor meta model","TCOMP-822: [Windows] deploy-in-studio & car copy jar command in mvn plugin - don’t work if the studio is running","TCOMP-844: Service default method forwarded to interface method instead of implementation one if exists","TCOMP-848: [junit5] implicit mock collector and emitter are not resetted per method","TCOMP-851: [form] UiSchema shouldn’t have a JsonSchema","TCOMP-858: @OptionsOrder not respected by form-core","TCOMP-862: [form-core] \"..\" path is not correctly resolved","TCOMP-863: Job DSL doesn’t support multiple outputs","TCOMP-873: Fix shade junit-http module : remove shaded dependencies from generated artifact","TCOMP-889: [form] arrays are lost in trigger paths","TCOMP-890: Merge the component outputs (by name) from @AfterGroup and @ElementListener","TCOMP-893: Don’t log a warning for services when parameters don’t have i18n support","TCOMP-834: Ensure that component has only one configuration argument.","TCOMP-845: [junit] ComponentsHandler misses findService","TCOMP-846: [junit] allow to inject current plugin services in test class","TCOMP-847: Support gzip in JUnit HTTP tooling","TCOMP-849: [junit http] support to match the request payload","TCOMP-850: MavenDecrypter should tolerate ${env.xxx} syntax","TCOMP-861: Ensure Car Mojo can be skipped","TCOMP-887: [studio] add chunk size advanced common param for processors & output","TCOMP-892: Validate runtime configuration before executing the runtime","TCOMP-829: Configuration Type tree is not correctly computed","TCOMP-830: Move all configuration to Microprofile Config instead of DeltaSpike","TCOMP-832: Provide a way to access lastUpdatedTimestamp in rest api","TCOMP-833: Upgrade gradle+maven for the starter","TCOMP-839: Add an API to load lazily the potential values of a list","TCOMP-840: Upgrade icon bundle to 0.190.2","TCOMP-841: Add validation of option names in the validator","TCOMP-852: [dependency upgrade] Upgrade shrinkwrap-resolver-impl-maven to 3.1.3","TCOMP-855: Support service injections in services","TCOMP-856: [dependency upgrade] OpenWebBeans 2.0.6","TCOMP-857: SimpleCollector must not depend on junit 4","TCOMP-864: Mojo should be thread safe for car/dependencies.txt generation","TCOMP-867: Expose Injector service","TCOMP-868: Create an ObjectFactory service","TCOMP-869: Ensure actions can get injected the requested lang","TCOMP-870: Provide Beam DoFn to simplify the migration from IndexedRecord to JsonObject","TCOMP-876: Allow custom converters in form-core","TCOMP-878: Add beam in the docker image OOTB","TCOMP-879: CarMojo doesn’t use car extension to attach the artifact","TCOMP-880: [dependency upgrade] Maven 3.5.4","TCOMP-881: [dependency upgrade] CXF 3.2.5","TCOMP-882: [dependency upgrade] Tomcat 9.0.10","TCOMP-883: [dependency upgrade] Beam 2.5.0","TCOMP-884: [dependency upgrade] Upgrade to icon bundle 0.197.0","TCOMP-894: [dependency upgrade] Johnzon 1.1.8","TCOMP-895: [dependency upgrade] xbean 4.9","TCOMP-827: Fix Automatic-Module-Name","TCOMP-811: Upgrade to tomcat 9.0.8","TCOMP-826: Extract component model from component server to a new artifact","TCOMP-763: Add a dev mode in the studio for tacokit","TCOMP-802: Add method to upload dependencies from .car to nexus","TCOMP-808: Upgrade to JUnit 5.2.0","TCOMP-809: compress js and css for the starter","TCOMP-810: ui spec service uses a multiselecttag for a proposable on a string field","TCOMP-804: Idea plugin doesn’t render properly configuration inputs","TCOMP-798: intellij plugin - add official starter url","TCOMP-799: @Checkable expects the datastore name to match the validation name","TCOMP-806: Ensure server and starter support gzip","TCOMP-643: Deployment","TCOMP-770: Removing component from web UI causes wrong number of components in summary","TCOMP-775: Starter - Fix properties keys generation","TCOMP-776: component-kit.js ignore credentials","TCOMP-783: ActiveIfs doesn’t make option visible","TCOMP-796: Datastore check (@Checkable) should default meta parameters to \"datastore\" if none is found","TCOMP-773: Extend the http client api to handle more generic use cases","TCOMP-771: ConfigurableClassLoader should skip scala.* classes","TCOMP-772: Upgrade icon set to ui/icons 0.179.0","TCOMP-774: Upgrade xbean to 4.8","TCOMP-768: More tolerance of configuration prefix for implicit migration of configuration node in form core library","TCOMP-756: Setup maven clirr plugin for component-api +testing","TCOMP-762: Starter should only propose a single category level in the ui","TCOMP-767: Ensure the configurationtype endpoints have matching name/path values","TCOMP-761: Merge component-runtime-manager and component-runtime-standalone","TCOMP-764: Clean up component-form-core dependencies","TCOMP-765: Upgrade to batik 1.9.1","TCOMP-752: Fix Advanced settings and Test connection button appearance in repository wizard","TCOMP-757: Duplicate method name \"writeReplace\" with signature \"()Ljava.lang.Object;\" in class file","TCOMP-751: Support gzip compression on component-server","TCOMP-753: Make classpath scanning to find component configurable","TCOMP-758: Support component-server server configuration from system properties","TCOMP-759: Enum must be i18n","TCOMP-738: Component Server should respect ~/.m2/settings.xml local repository if it exists","TCOMP-739: SerializationTransformer shouldn’t use ComponentManager to avoid ClassNotFoundException","TCOMP-740: UISpecService should be reactive and use a CompletionStage based API","TCOMP-741: UISpecService configuration support","TCOMP-742: Configuration Type properties should be rooted","TCOMP-744: Ensure wrapped BeamIO uses the right TCCL","TCOMP-745: [Dependency Upgrade] CXF 3.2.4","TCOMP-746: [Dependency Upgrade] Tomcat 9.0.6","TCOMP-747: [Dependency Upgrade] Log4j2 2.11.0","TCOMP-748: Make configurationtype index endpoint lighter OOTB","TCOMP-749: Intellij Idea plugin","TCOMP-750: Unify @Pattern using javascript regex instead of a mixed mode","TCOMP-734: Add support for context and globalMap values in Tacokit component settings","TCOMP-733: support to use a beam pipeline under the hood for beam components in di","TCOMP-693: Integrate Migration API","TCOMP-737: upgrade to beam 2.4.0","TCOMP-731: Configuration Type migration handler skipped","TCOMP-725: MavenDecrypter doesn’t support comments in settings.xml","TCOMP-726: When a component is not found the error message can be misleading","TCOMP-728: Http client doesn’t ignore empty query parameters","TCOMP-722: WebSocket connection fails with a NPE when the endpoint doesn’t exists","TCOMP-723: Adding configurationByExample utility to create query string for Job DSL","TCOMP-724: Documentation endpoint doesn’t support HTML","TCOMP-446: Support Embedded Documentation","TCOMP-650: Ensure component can be executed in beam pipelines","TCOMP-651: Ensure beam components can be wrapped and used through the Talend Component Kit Framework","TCOMP-653: Web Form metamodel service","TCOMP-655: Catalog service","TCOMP-656: UISpec compatibility","TCOMP-658: Add test Source/Sink collectors in JUnit integration","TCOMP-659: Basic job builder API to simplify JUnit tests","TCOMP-662: Validation Mojo","TCOMP-664: Local testing server for dev","TCOMP-675: Select a communication solution for Talend Component Kit server","TCOMP-680: Register components into the Studio Palette","TCOMP-681: Studio parameters form integration","TCOMP-682: Studio Metadata integration","TCOMP-683: Studio Runtime integration","TCOMP-691: Create context menu for Tacokit node in repository panel","TCOMP-719: Support Input Definition","TCOMP-720: Support Output Definition","TCOMP-721: Initial Widget Definitions"]},{"lang":"en","title":"Talend Component Kit Javadocs","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/apidocs.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Talend Component Kit Javadocs"],"text":["Refer to the following links to access the detailed API reference documentation:","API Documentation","JUnit API Documentation","HTTP JUnit API Documentation"]},{"lang":"en","title":"Talend Component Kit best practices","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/best-practices.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Talend Component Kit best practices"],"lvl1":["Organizing your code","Configuring components","Handling UI interactions","Enforcing versioning on components","Testing components"],"lvl2":["Serializing your configuration","Input and output components","Processor components","Validations","Completion","Component representation"],"lvl3":["About actions","Limitations","Light validations","Custom validations"],"text":["Some recommendations apply to the way component packages are organized:","Make sure to create a package-info.java file with the component family/categories at the root of your component package:","Create a package for the configuration.","Create a package for the actions.","Create a package for the component and one sub-package by type of component (input, output, processors, and so on).","It is recommended to serialize your configuration in order to be able to pass it through other components.","When building a new component, the first step is to identify the way it must be configured.","The two main concepts are:","The DataStore which is the way you can access the backend.","The DataSet which is the way you interact with the backend.","For example:","Example description","DataStore","DataSet","Accessing a relational database like MySQL","JDBC driver, URL, username, password","Query to execute, row mapper, and so on.","Accessing a file system","File pattern (or directory + file extension/prefix/…)","File format, buffer size, and so on.","It is common to have the dataset including the datastore, because both are required to work. However, it is recommended to replace this pattern by defining both dataset and datastore in a higher level configuration model. For example:","Input and output components are particular because they can be linked to a set of actions. It is recommended to wire all the actions you can apply to ensure the consumers of your component can provide a rich experience to their users.","The most common actions are the following ones:","Type","Action","Description","Configuration example","Action example","DataStore","@Checkable","Exposes a way to ensure the datastore/connection works","Until the studio integration is complete, it is recommended to limit processors to one input.","Configuring processor components is simpler than configuring input and output components because it is specific for each component. For example, a mapper takes the mapping between the input and output models:","It is recommended to provide as much information as possible to let the UI work with the data during its edition.","Light validations are all the validations you can execute on the client side. They are listed in the UI hint section.","Use light validations first before going with custom validations because they are more efficient.","Custom validations enforce custom code to be executed, they are more heavy to process, so prefer using light validations when possible.","Define an action with the parameters needed for the validation and link the option you want to validate to this action. For example, to validate a dataset for a JDBC driver:","You can also define a Validable class and use it to validate a form by setting it on your whole configuration:","The parameter binding of the validation method uses the same logic as the component configuration injection. Therefore, the @Option method specifies the prefix to use to reference a parameter. It is recommended to use @Option(\"value\") until you know exactly why you don’t use it. This way, the consumer can match the configuration model and just prefix it with value. to send the instance to validate.","It can be handy and user-friendly to provide completion on some fields. For example, to define completion for available drivers:","Each component must have its own icon:","You can use talend.surge.sh/icons/ to find the icon you want to use.","It is recommended to enforce the version of your component, event though it is not mandatory for the first version.","If you break a configuration entry in a later version; make sure to:","Upgrade the version.","Support a migration of the configuration.","Testing your components is critical. You can use unit and simple standalone JUnit tests, but it is also highly recommended to have Beam tests in order to make sure that your component works in Big Data."]},{"lang":"en","title":"Talend Component REST API Documentation","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/documentation-rest.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Talend Component REST API Documentation"],"lvl1":["HTTP API","HTTPS activation","Web forms and REST API","Logging","UiSpec Server","Docker"],"lvl2":["REST resources of Component Runtime :: Server Parent :: Server","Deprecated endpoints","WebSocket transport","Using the UiSpec model without the tooling","JavaScript integration","Coordinates","Configuring the UiSpec server","HTTP API","Integrating with Play","Configuring the server module","Run","Configure","Maven repository","Logging","Build the image yourself"],"lvl3":["POST api/v1/action/execute","GET api/v1/action/index","GET api/v1/component/dependencies","GET api/v1/component/dependency/{id}","GET api/v1/component/details","GET api/v1/component/icon/family/{id}","GET api/v1/component/icon/{id}","GET api/v1/component/index","POST api/v1/component/migrate/{id}/{configurationVersion}","GET api/v1/configurationtype/details","GET api/v1/configurationtype/index","POST api/v1/configurationtype/migrate/{id}/{configurationVersion}","GET api/v1/documentation/component/{id}","GET api/v1/environment","POST api/v1/execution/read/{family}/{component}","POST api/v1/execution/write/{family}/{component}","Adding custom entries to the forms","Adding custom converters (selecting the widget or rendering)","Client in Play","Defining a dropdown with all root configurations","Reloading the form based on the selected root","Component UiSpec Server","If you are using Guice","Deploy components to the server","default profile","Kafka profile","Tracing (Brave Monitoring)"],"text":["A test environment is available on Heroku and can be browsed using Talend Component Kit Server instance on Restlet Studio.","The HTTP API intends to expose most Talend Component Kit features over HTTP. It is a standalone Java HTTP server.","The WebSocket protocol is activated for the endpoints. Endpoints then use /websocket/v1 as base instead of /api/v1. See WebSocket for more details.","Here is the API:","1.0.2-SNAPSHOT","This endpoint will execute any UI action and serialize the response as a JSON (pojo model) It takes as input the family, type and name of the related action to identify it and its configuration as a flat key value set using the same kind of mapping than for components (option path as key).","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Query Param: action, java.lang.String Query Param: family, java.lang.String Query Param: lang, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (``)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","This endpoint returns the list of available actions for a certain family and potentially filters the \" output limiting it to some families and types of actions.","No body Query Param: family, java.lang.String Query Param: language, java.lang.String Query Param: type, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ActionList)","Returns a list of dependencies for the given components.","don’t forget to add the component itself since it will not be part of the dependencies.","Then you can use /dependency/{id} to download the binary.","No body Query Param: identifier, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.Dependencies)","Return a binary of the dependency represented by id. It can be maven coordinates for dependencies or a component id.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (javax.ws.rs.core.StreamingOutput)","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the set of metadata about a few components identified by their 'id'.","No body Query Param: identifiers, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentDetailList)","Response Body: (java.util.Map<java.lang.String, org.talend.sdk.component.server.front.model.error.ErrorPayload>)","Returns a particular family icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns a particular component icon in raw bytes.","No body Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (byte[])","Response Body: (org.talend.sdk.component.server.front.model.error.ErrorPayload)","Returns the list of available components.","No body Query Param: includeIconContent, boolean Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ComponentIndices)","Allows to migrate a component configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns the set of metadata about a few configurations identified by their 'id'.","No body Query Param: identifiers, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ConfigTypeNodes)","Returns all available configuration type - storable models. Note that the lightPayload flag allows to load all of them at once when you eagerly need to create a client model for all configurations.","No body Query Param: language, java.lang.String Query Param: lightPayload, boolean","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.ConfigTypeNodes)","Allows to migrate a configuration without calling any component execution.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: configurationVersion, int Path Param: id, java.lang.String","Content-Type: application/json","Response Body: (java.util.Map<java.lang.String, java.lang.String>)","Returns an asciidoctor version of the documentation for the component represented by its identifier id.","Format can be either asciidoc or html - if not it will fallback on asciidoc - and if html is selected you get a partial document.","it is recommended to use asciidoc format and handle the conversion on your side if you can, the html flavor handles a limited set of the asciidoc syntax only like plain arrays, paragraph and titles.","The documentation will likely be the family documentation but you can use anchors to access a particular component (_componentname_inlowercase).","No body Path Param: id, java.lang.String Query Param: format, java.lang.String Query Param: language, java.lang.String","Content-Type: application/json","Response Body: (org.talend.sdk.component.server.front.model.DocumentationContent)","Returns the environment of this instance. Useful to check the version or configure a healthcheck for the server.","No body","Content-Type: */*","Response Body: (org.talend.sdk.component.server.front.model.Environment)","deprecated","Read inputs from an instance of mapper. The number of returned records if enforced to be limited to 1000. The format is a JSON based format where each like is a json record.","Content-Type: application/json Request Body: (java.util.Map<java.lang.String, java.lang.String>) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: size, long","Content-Type: talend/stream","deprecated","Sends records using a processor instance. Note that the processor should have only an input. Behavior for other processors is undefined. The input format is a JSON based format where each like is a json record - same as for the symmetric endpoint.","Content-Type: talend/stream Request Body: (java.io.InputStream) Path Param: component, java.lang.String Path Param: family, java.lang.String Query Param: group-size, long","Content-Type: application/json","To make sure that the migration can be enabled, you need to set the version the component was created with in the execution configuration that you send to the server (component version is in component the detail endpoint). To do that, use tcomp::component::version key.","Endpoints that are intended to disappear will be deprecated. A X-Talend-Warning header will be returned with a message as value.","You can connect yo any endpoint by:","Replacing /api with /websocket","Appending /<http method> to the URL","Formatting the request as:","For example:","The response is formatted as follows:","All endpoints are logged at startup. You can then find them in the logs if you have a doubt about which one to use.","If you don’t want to create a pool of connections per endpoint/verb, you can use the bus endpoint: /websocket/v1/bus. This endpoint requires that you add the destinationMethod header to each request with the verb value (GET by default):","Using the server ZIP (or Docker image), you can configure HTTPS by adding properties to MEECROWAVE_OPTS. Assuming that you have a certificate in /opt/certificates/component.p12 (don’t forget to add/mount it in the Docker image if you use it), you can activate it as follows:","The component-form library provides a way to build a component REST API facade that is compatible with React form library.","for example:","the Client can be created using ClientFactory.createDefault(System.getProperty(\"app.components.base\", \"http://localhost:8080/api/v1\")) and the service can be a simple new UiSpecService<>(). The factory uses JAX-RS if the API is available (assuming a JSON-B provider is registered). Otherwise, it tries to use Spring.","The conversion from the component model (REST API) to the uiSpec model is done through UiSpecService. It is based on the object model which is mapped to a UI model. Having a flat model in the component REST API allows to customize layers easily.","You can completely control the available components, tune the rendering by switching the uiSchema, and add or remove parts of the form. You can also add custom actions and buttons for specific needs of the application.","The /migrate endpoint was not shown in the previous snippet but if you need it, add it as well.","This Maven dependency provides the UISpec model classes. You can use the Ui API (with or without the builders) to create UiSpec representations.","For Example:","The model uses the JSON-B API to define the binding. Make sure to have an implementation in your classpath. To do that, add the following dependencies:","Default JavaScript integration goes through the Talend UI Forms library.","It is bundled as a NPM module called component-kit.js. It provides a default trigger implementation for UIForm.","Here is how to use it:","The logging uses Log4j2. You can specify a custom configuration by using the -Dlog4j.configurationFile system property or by adding a log4j2.xml file to the classpath.","Here are some common configurations:","Console logging:","Output messages look like:","JSON logging:","Output messages look like:","Rolling file appender:","More details are available in the RollingFileAppender documentation.","You can compose previous layout (message format) and appenders (where logs are written).","The UiSpec server is a companion application for the Component Server. It provides a client to the Component Server which serves UiSpec payload to integrate with the client JavaScript UiForm library.","the configuration is read from system properties, environment variables, …. If you use playx-microprofile-config, you can also use typesafe configuration.","Key","Description","Default","talend.component.proxy.actions.proposable.cached","If true the proposable (suggestion lists only depending on the server state) will be cached, otherwise they will be requested for each form rendering.","true","talend.component.proxy.application.home","A home location for relative path resolution (optional).","${playx.application.home}","talend.component.proxy.client.providers","List of JAX-RS providers to register on the client, at least a JSON-B one should be here.","-","talend.component.proxy.client.timeouts.connect","The connect timeout for the communication with the server.base in ms.","60000","talend.component.proxy.client.timeouts.read","The read timeout for the communication with the server.base in ms.","600000","talend.component.proxy.jcache.active","Should the server use jcache to store catalog information and refresh it with some polling. If so the keys talend.component.proxy.jcache.caches.$cacheName.expiry.duration, talend.component.proxy.jcache.caches.$cacheName.management.active and talend.component.proxy.jcache.caches.$cacheName.statistics.active will be read to create a JCache MutableConfiguration. Also note that if all the cachesshare the same configuration you can ignore the $cacheName layer.","true","talend.component.proxy.jcache.provider","Caching provider implementation to use (only set it if ambiguous).","-","talend.component.proxy.jcache.refresh.period","Number of seconds used to check if the server must be refreshed.","60","talend.component.proxy.processing.headers","The headers to append to the request when contacting the server. Format is a properties one. You can put a hardcoded value or a placeholder (${key}).In this case it will be read from the request attributes and headers.","-","talend.component.proxy.processing.uiSpec.patch","An optional location (absolute or resolved from APP_HOME environment variable). It can take an optional query parameter force which specifies if the startup should fail if the file is not resolved. The resolution is done per configuration type (datastore, dataset, …) but fallbacks on default type if the file is not found.","The values can be keys in the resource bundle org.talend.sdk.component.proxy.enrichment.i18n.Messages. Use that for display names, placeholders etc…The content","component-uispec-metadata.%s.json?force=false","talend.component.proxy.server.base","The base to contact the remote server (NOTE: it is recommanded to put a load balancer if you have multiple instances.)","-","As shown in the table above, you can customize the forms by type. The format reuses Talend Component Kit REST API (properties model) and defines two main types of extensions:","prependProperties: Lists all the models of properties added to the form before the actual underlying form.","appendProperties: Lists all the models of properties added to the form after the actual underlying form.","If you don’t specify a name, the path is used to deduce the name automatically.","Always make sure to define a root object for these properties. Do not use dots in the path value. It is recommended to prefix it with a $ character.","When developing a org.talend.sdk.component.form.internal.converter.CustomPropertyConverter CDI, the proxy adds it to the UiSpecService service and uses it with a high priority to convert the server model to a UiSpec model.","To make it a CDI bean, add @Dependent to the class and if you use the Play integration, customize the bean array: playx.cdi.beans.customs += {className: org.talend.myapp.MyConverter}.","This allows to use a custom @Ui API and advanced modeling when specific to applications. Converters are sorted respecting to the @Priority value. If the annotation is missing, the priority defaults to 0.","The client to use to connect to the Talend Component Kit server is the CXF client, using HttpClient HC (NIO) transport. When you use the Play module, it can be configured with its standard properties prefixed by talend.component.proxy..","You can find more information on CXF website.","The special dynamic_values action builtin::roots can be used for a dropdown filled with all available root types.","Here is a sample patch file:","The builtin::root::reloadFromId action, with the jsonpatch type, allows to reload the whole form:","It is common to have a dropdown with the list of roots and to reload the form when one is selected.","For example, the UIForm part (JavaScript side) can be implemented as follows:","These endpoints allow to obtain UiSpec representations of the component/configuration types properties.","Version : v1","Contact : Talend Contact Email : contact@talend.com","License : Apache 2.0 License URL : www.apache.org/licenses/LICENSE-2.0.html Terms of service : null","Host : host:port BasePath : /componentproxy/api/v1 Schemes : HTTP, HTTPS","action","configuration","configurations","dataset","datastore","form","icon","persistence","ui spec","uispec","configuration types has action that can be executed using this endpoint","Type","Name","Schema","Query","action optional","string","Query","family optional","string","Query","language optional","string","Query","type optional","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","< string, CompletionStageMapStringObject > map","400","This response is returned when the action is null","ProxyErrorPayload","404","This response is returned when no action is found","ProxyErrorPayload","520","This response is returned when the action raise an unhandled error","ProxyErrorPayload","application/json","application/json","action","configurations","Every configuration has an icon. In the response an icon key is returned. this icon key can be one of the bundled icons or a custom one. The consumer of this endpoint will need to check if the icon key is in the icons bundle otherwise the icon need to be gathered using the familyId from this endpoint configurations/{id}/icon","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","Nodes","application/json","application/json","configurations","datastore","Type","Name","Schema","Path","type required","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","Nodes","application/json","application/json","configurations","dataset","datastore","form","ui spec","Type","Name","Schema","Path","id required","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","UiNode","application/json","application/json","configurations","dataset","datastore","form","ui spec","Type","Name","Schema","Path","id required","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","CompletionStageByte[]","application/json","application/json","application/octet-stream","icon","Type","Name","Schema","Path","id required","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","EntityRef","application/json","application/json","configurations","dataset","datastore","form","persistence","ui spec","Type","Name","Schema","Path","type required","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","EntityRef","application/json","application/json","configurations","dataset","datastore","form","persistence","ui spec","Type","Name","Schema","Path","formId required","string","HTTP Code","Description","Schema","200","successful operation Headers : Talend-Component-Server-Error (boolean) : This header indicate the error origin. true indicate an error from the component server, false indicate that the error is from this proxy.","EntityRef","application/json","application/json","configurations","dataset","datastore","form","persistence","ui spec","Type : object","Type : object","Type : object","Type : object","Type : object","Type : object","Name","Schema","path optional","string","values optional","< object > array","Name","Description","Schema","id optional","The identifier of the entity related to current request. It is generally thecreated entity of updated one.","string","Name","Schema","defaultValue optional","object","description optional","string","enumValues optional","< string > array","id optional","string","items optional","JsonSchema","maxItems optional","integer (int32)","maxLength optional","integer (int32)","maximum optional","number (double)","minItems optional","integer (int32)","minLength optional","integer (int32)","minimum optional","number (double)","pattern optional","string","properties optional","< string, JsonSchema > map","ref optional","string","required optional","< string > array","schema optional","string","title optional","string","type optional","string","uniqueItems optional","boolean","Name","Schema","name optional","string","value optional","string","Name","Description","Schema","children optional","The list of configuration reusing this one as a reference (can be created \"next\").","< string > array","familyId optional","The identifier of the family of this configuration.","string","familyLabel optional","The display name of the family of this configuration.","string","icon optional","The icon of this configuration. If you use an existing bundle (@talend/ui/icon), ensure it is present by default and if not do a request using the family on the related endpoint.","string","id optional","The identifier of this configuration/node.","string","label optional","The display name of this configuration.","string","name optional","The technical name of this node (it is human readable but not i18n friendly), useful for debug purposes.","string","version optional","The version of this configuration for the migration management.","integer (int32)","Name","Description","Schema","nodes optional","The list of nodes matching the request. The key is the node identifier.","< string, Node > map","Name","Schema","path optional","string","type optional","string","Name","Schema","key optional","string","path optional","string","Name","Description","Schema","code optional","The error code independently of the locale and not as precise as a message (not context aware).","string","message optional","A human readable message to help understanding the error","string","Name","Schema","action optional","string","family optional","string","onEvent optional","string","options optional","< Option > array","parameters optional","< Parameter > array","type optional","string","Name","Schema","jsonSchema optional","JsonSchema","properties optional","object","uiSchema optional","< UiSchema > array","Name","Description","Schema","metadata optional","The metadata associated to the node if needed by the UI.","Node","ui optional","The ui specification corresponding to the requested node. It is literally the form representing this configuration.","Ui","Name","Schema","autoFocus optional","boolean","conditions optional","< Condition > array","description optional","string","disabled optional","boolean","itemWidget optional","string","items optional","< UiSchema > array","key optional","string","options optional","< string, string > map","placeholder optional","string","readOnly optional","boolean","required optional","boolean","restricted optional","boolean","title optional","string","titleMap optional","< NameValue > array","triggers optional","< Trigger > array","type optional","string","widget optional","string","There are two ways to call the save endpoint. If you don’t want to pass the form identifier and prefer to use a generic endpoint that simply passes the type of configuration you are configuring, then you need to modify your enrichment configuration to ensure that the form identifier is present and to specify which form field it is.","To do that, add the proxyserver::formId Boolean to the metadata:","Only the first property with proxyserver::formId set to \"true\" is used. The path cannot contain any array.","Thanks to Playx, you can deploy this server in a Play! application.","Import the pre-configuration of the Play integration.","Configure the integration in your application.conf file:","The org.talend.sdk.component.guice.ComponentUiSpecServerModule Guice module allows to import Services from the server and to use some of them locally for the parts that are out of the scope of the endpoint delivery. For example:","Converting JsonObject to Map<String, String> and the other way around.","Getting the properties model for a configuration or component.","Use a Provider<T> injection to keep it lazy.","The server does not handle two layers. It is possible that you need to add:","Security.","Persistence.","For the security layer, it is recommended to create a Play filter that you configure before the proxy (ServletFilter). Make sure that you pass all contextual data in the request attributes to be able to get them back after.","For the persistence layer, the framework fires particular events (OnPersist, OnEdit and OnFindById) that you should observe in order to implement the persistence as you wish. Reusing the CDI context of the server just a plain CDI observer works, but if you used the Guice/CDI setup (using the Play module of the integration) you need to write Guice observers.","OnPersist needs to become identifier-aware of the created entity. Make sure to call composeId. In a similar way, OnFindById requires you to pass the found instance with composeProperties() and composeFormId().","Optionally, you can implement OnFindByFormId, which allows to have completion for references. If your application does not allow to edit references, you can bypass this event. If you implement it, make sure to call composeResult no more than once.","Deletion is not handled by the server because there is no encapsulation of any format at that moment.","The server module contains several configurations that you can set in:","Environment variables.","System properties.","A file located based on the --component-configuration CLI option.","the configuration is read from system properties, environment variables, ….","Key","Description","Default","talend.component.server.component.coordinates","A comma separated list of gav to locate the components","-","talend.component.server.component.extend.dependencies","Should the component extensions add required dependencies.","true","talend.component.server.component.registry","A property file where the value is a gav of a component to register (complementary with coordinates)","-","talend.component.server.documentation.active","Should the /documentation endpoint be activated.","true","talend.component.server.execution.dataset.retriever.timeout","How long the read execution endpoint can last (max)","180","talend.component.server.execution.pool.size","The size of the execution pool for runtime endpoints.","64","talend.component.server.execution.pool.wait","How long the application waits during shutdown for the execution tasks to complete","PT10S","talend.component.server.jaxrs.exceptionhandler.defaultMessage","If set it will replace any message for exceptions. Set to false to use the actual exception message.","false","talend.component.server.maven.repository","The local maven repository used to locate components and their dependencies","-","talend.component.server.monitoring.brave.reporter.async","When using url or kafka reporter, you can configure the async reporter with properties passed to this configuration entry.Ex: messageTimeout=5000,closeTimeout=5000.","console","talend.component.server.monitoring.brave.reporter.type","The brave reporter to use to send the spans. Supported values are [log, noop]. When configuration is needed,you can use this syntax to configure the repoter if needed: <name>(config1=value1, config2=value2), for example: url(endpoint=http://brave.company.com.","In log mode, if environment variable TRACING_ON doesn’t exist or is set to false, noop will be selected, and is set to true, TRACING_KAFKA_URL, TRACING_KAFKA_TOPIC and TRACING_SAMPLING_RATE will configure kafka reporter..","noop","talend.component.server.monitoring.brave.sampling.action.rate","The accuracy rate of the sampling for action endpoints.","-1","talend.component.server.monitoring.brave.sampling.component.rate","The accuracy rate of the sampling for component endpoints.","-1","talend.component.server.monitoring.brave.sampling.configurationtype.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.documentation.rate","The accuracy rate of the sampling for documentation endpoint.","-1","talend.component.server.monitoring.brave.sampling.environment.rate","The accuracy rate of the sampling for environment endpoints.","-1","talend.component.server.monitoring.brave.sampling.execution.rate","The accuracy rate of the sampling for execution endpoints.","1","talend.component.server.monitoring.brave.sampling.rate","The accuracy rate of the sampling.","-1.","talend.component.server.monitoring.brave.service.name","The name used by the brave integration (zipkin)","component-server","talend.component.server.security.command.handler","How to validate a command/request. Accepted values: securityNoopHandler.","securityNoopHandler","talend.component.server.security.connection.handler","How to validate a connection. Accepted values: securityNoopHandler.","securityNoopHandler","The server image is deployed on Docker. Its version is suffixed with a timestamp to ensure images are not overriden and can break your usage. You can check the available version on Docker hub.","You can run the docker image by executing this command :","You can set the env variable MEECROWAVE_OPTS to customize the server, by default it is installed in /opt/talend/component-kit.","The maven repository is the default one of the machine, you can change it setting the system property talend_component_server_maven_repository=/path/to/your/m2.","If you want to deploy some components you can configure which ones in MEECROWAVE_OPTS (see server doc online) and redirect your local m2:","The component server docker image comes with two log4j2 profile default and kafka. The logging profile can be changed by setting the environment variable TALEND_COMPONENT_LOG4J2_PROFILE to kafka the default profile is active by default.","The default profile has file and console logging capabilities. The console logging is off by default and you can activate it by setting CONSOLE_LOG_LEVEL environment variable to DEBUG, INFO, WARN or any other log level supported by log4j2. In practise and during development you will want to see the logs without connecting to the server by activating console logging.","Run docker image with console logging","Kafka profile let you send log to Kafka servers. The log are formatted in json and follow the layout defined by Talend and described here github.com/Talend/daikon/tree/master/daikon-logging/logging-event-layout","This profile require two environment variables","LOG_KAFKA_TOPIC : Kafka topic.","LOG_KAFKA_URL : A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. This list should be in the form url:port separated by ,","Run docker image with kafka profile","Note : LOG_KAFKA_TOPIC will receive the application and the access logs and TRACING_KAFKA_TOPIC will receive brave tracing logs.","The component server use github.com/openzipkin/brave to monitor request.","The tracing can be activated by setting environment variable TRACING_ON to true.","You can choose the reporter type by setting talend_component_server_monitoring_brave_reporter_type environment variable to log (this is the default value in this docker image) or to noop which will deactivate the tracing. Other type of reporter may be added in the future.","The tracing rate is configurable by setting environment variable TRACING_SAMPLING_RATE. This is the default sample rate for all the endpoints and has a default value of 0.1","You can define more accurate rate for every component server endpoint using those environment variables :","Environment variable","Endpoint","talend_component_server_monitoring_brave_sampling_environment_rate","/api/v1/environment","talend_component_server_monitoring_brave_sampling_configurationtype_rate","/api/v1/configurationtype","talend_component_server_monitoring_brave_sampling_component_rate","/api/v1/component","talend_component_server_monitoring_brave_sampling_documentation_rate","/api/v1/documentation","talend_component_server_monitoring_brave_sampling_action_rate","/api/v1/action","talend_component_server_monitoring_brave_sampling_execution_rate","/api/v1/execution","Run docker image with tracing on","You can build component starter server in docker following those instructions :","this assumes the project is built before you run that command."]},{"lang":"en","title":"Testing a REST API","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-test-rest-api.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Testing a REST API"],"lvl1":["Creating the unit test","Transforming the unit test into a mocked test"],"text":["Testing code that consumes REST APIs can sometimes present many constraints: API rate limit, authentication token and password sharing, API availability, sandbox expiration, API costs, and so on.","As a developer, it becomes critical to avoid those constraints and to be able to easily mock the API response.","The component framework provides an API simulation tool that makes it easy to write unit tests.","This tutorial shows how to use this tool in unit tests. As a starting point, the tutorial uses the component that consumes Zendesk Search API and that was created in a previous tutorial. The goal is to add unit tests for it.","For this tutorial, four tickets that have the open status have been added to the Zendesk test instance used in the tests.","To learn more about the testing methodology used in this tutorial, refer to Component JUnit testing.","Create a unit test that performs a real HTTP request to the Zendesk Search API instance. You can learn how to create a simple unit test in this tutorial.","the authentication configuration using Zendesk instance URL and credentials.","the search query configuration to get all the open ticket, ordered by creation date and sorted in descending order.","The test is now complete and working. It performs a real HTTP request to the Zendesk instance.","As an alternative, you can use mock results to avoid performing HTTP requests every time on the development environment. The real HTTP requests would, for example, only be performed on an integration environment.","To transform the unit test into a mocked test that uses a mocked response of the Zendesk Search API:","Add the two following JUnit rules provided by the component framework.","JUnit4HttpApi: This rule starts a simulation server that acts as a proxy and catches all the HTTP requests performed in the tests. This simulation server has two modes :","capture : This mode forwards the captured HTTP request to the real server and captures the response.","simulation : this mode returns a mocked response from the responses already captured. This rule needs to be added as a class rule.","JUnit4HttpApi: This rule has a reference to the first rule. Its role is to configure the simulation server for every unit test. It passes the context of the running test to the simulation server. This rule needs to be added as a simple (method) rule.","Make the test run in capture mode to catch the real API responses that can be used later in the simulated mode. To do that, set a new talend.junit.http.capture environment variable to true. This tells the simulation server to run in a capture mode.","The captured response is saved in the resources/talend.testing.http package in a JSON format, then reused to perform the API simulation."]},{"lang":"en","title":"Testing a component","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-test-your-components.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Testing a component"],"text":["This tutorial focuses on writing unit tests for the input component that was created in this previous tutorial.","This tutorial covers:","How to load components in a unit test.","How to create a job pipeline.","How to run the test in standalone mode.","The test class is as follows:"]},{"lang":"en","title":"Testing best practices","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/testing-best-practices.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Testing best practices"],"lvl1":["Parameterized tests"],"lvl2":["JUnit 4","JUnit 5"],"text":["This section mainly concerns tools that can be used with JUnit. You can use most of these best practices with TestNG as well.","Parameterized tests are a great solution to repeat the same test multiple times. This method of testing requires defining a test scenario (I test function F) and making the input/output data dynamic.","Here is a test example, which validates a connection URI using ConnectionService:","The testing method is always the same. Only values are changing. It can therefore be rewritten using JUnit Parameterized runner, as follows:","You don’t have to define a single @Test method. If you define multiple methods, each of them is executed with all the data. For example, if another test is added to the previous example, four tests are executed - 2 per data).","With JUnit 5, parameterized tests are easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference with JUnit 4 is that you can also define inline that the test method is a parameterized test as well as the values to use:","However, you can still use the previous behavior with a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is common to define scenarios.","Add the junit-jupiter-params dependency to benefit from this feature."]},{"lang":"en","title":"Testing in a Continuous Integration environment","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/tutorial-dev-vs-ci-setup.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Testing in a Continuous Integration environment"],"lvl1":["Setting up credentials","Adapting the unit test","Setting up the CI server in passthrough mode"],"text":["This tutorial shows how to adapt the test configuration of the Zendesk search component that was done in this previous tutorial to make it work in a Continuous Integration environment.","In the test, the Zendesk credentials are used directly in the code to perform a first capture of the API response. Then, fake credentials are used in the simulation mode because the real API is not called anymore.","However, in some cases, you can require to continue calling the real API on a CI server or on a specific environment.","To do that, you can adapt the test to get the credentials depending on the execution mode (simulation/passthrough).","These instructions concern the CI server or on any environment that requires real credentials.","This tutorial uses:","A Maven server that supports password encryption as a credential provider. Encryption is optional but recommended.","The MavenDecrypterRule test rule provided by the framework. This rule lets you get credentials from Maven settings using a server ID.","To create encrypted server credentials for the Zendesk instance:","Create a master password using the command: mvn --encrypt-master-password <password>.","Store this master password in the settings-security.xml file of the ~/.m2 folder.","Encrypt the Zendesk instance password using the command: mvn --encrypt-password <zendesk-password>.","Create a server entry under servers in Maven settings.xml file located in the ~/.m2 folder.","You can store the settings-security.xml and settings.xml files elsewhere that the default location (~/.m2). To do that, set the path of the directory containing the files in the talend.maven.decrypter.m2.location environment variable.","Add the MavenDecrypterRule rule to the test class. This rule allows to inject server information stored in Maven settings.xml file to the test. The rule also decrypts credentials if they are encrypted.","Inject the Zendesk server to the test. To do that, add a new field to the class with the @DecryptedServer annotation, that holds the server ID to be injected.","The MavenDecrypterRule is able to inject the server instance into this class at runtime. The server instance contains the username and the decrypted password.","Use the server instance in the test to get the real credentials in a secured manner.","Once modified, the complete test class looks as follows:","This test will continue to work in simulation mode, because the API simulation proxy is activated.","This tutorial shows how to set up a CI server in passthrough mode using Jenkins.","Log in to Jenkins.","Click New Item to create a new build job.","Enter an Item name (Job name) and choose the freestyle job. Then click OK.","In the Source Code Management section, enter your project repository URL. A GitHub repository is used in this tutorial.","Specify the master branch as Branches to build.","In the Build section, click Add build step and choose Invoke top-level Maven targets.","Choose your Maven version and enter the Maven build command. In this case: clean install. Then, click Save.","The -Dtalend.junit.http.passthrough=true option is part of the build command. This option tells the API simulation proxy to run in passthrough mode. This way, all the HTTP requests made in the test are forwarded to the real API server.","The MavenDecrypterRule rule allows to get the real credentials.","You can configure the passthrough mode globally on your CI server by setting the talend.junit.http.passthrough environment variable to true.","Test the job by selecting Build now, and check that the job has built correctly.","Now your tests run in a simulation mode on your development environment and in a passthrough mode on your CI server."]},{"lang":"en","title":"Testing on multiple environments","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/testing-multiple-envs.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Testing on multiple environments"],"lvl1":["JUnit 4","JUnit 5","Provided environments","Configuring environments"],"lvl2":["Advanced usage"],"text":["JUnit (4 or 5) already provides ways to parameterize tests and execute the same \"test logic\" against several sets of data. However, it is not very convenient for testing multiple environments.","For example, with Beam, you can test your code against multiple runners. But it requires resolving conflicts between runner dependencies, setting the correct classloaders, and so on.","To simplify such cases, the framework provides you a multi-environment support for your tests, through the JUnit module, which works with both JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner executes the tests for each defined environments. With the example above, it means that it runs test1 for Env1 and Env2.","By default, the JUnit4 runner is used to execute the tests in one environment, but you can use @DelegateRunWith to use another runner.","The multi-environment configuration with JUnit 5 is similar to JUnit 4:","The main differences are that no runner is used because they do not exist in JUnit 5, and that you need to replace @Test by @EnvironmentalTest.","With JUnit5, tests are executed one after another for all environments, while tests are ran sequentially in each environments with JUnit 4. For example, this means that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment sets the contextual classloader in order to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","Class","Name","Description","ContextualEnvironment","Contextual","Contextual runner","DirectRunnerEnvironment","Direct","Direct runner","FlinkRunnerEnvironment","Flink","Flink runner","SparkRunnerEnvironment","Spark","Spark runner","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones - you can use EnvironmentConfiguration to customize the system properties used for that environment:","If you set the <environment name>.skip system property to true, the environment-related executions are skipped.","This usage assumes that Beam 2.4.0 is used.","The following dependencies bring the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit into the test scope.","Using the fluent DSL to define jobs, you can write a test as follows:","Your job must be linear and each step must send a single value (no multi-input or multi-output).","It executes the chain twice:","With a standalone environment to simulate the Studio.","With a Beam (direct runner) environment to ensure the portability of your job."]},{"lang":"en","title":"Wall of Fame","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/contributors.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Wall of Fame"],"lvl2":["Romain Manni-Bucau","#1396 commits","Anas KHABALI","#242 commits","Ivan Gonchar","#192 commits","Florent LB","#55 commits","Chao MENG","#22 commits","ypiel","#17 commits","Jean-Michel FRANCOIS","Jimmy Somsanith","#9 commits","Axel MAUMONT","#3 commits","#2 commits"],"text":["Joined the Apache EE family (TomEE, Johnzon, BatchEE...) in 2011. My goal is to make development a detail of an idea becoming reality. Blog: https://rmannibucau.metawerx.net","I am a software developer at @Talend For my personal projects you can check them @khabali Blog: https://khabali.github.io","","","R&D","","","Java and Javascript developer","",""]},{"lang":"en","title":"Widget and validation gallery","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/gallery.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Widget and validation gallery"],"lvl1":["Widgets","Validations"],"text":["Name","Code","Studio Rendering","Web Rendering","Input/Text","Password","Textarea","Checkbox","List","List","Table","Code","Schema","Name","Code","Studio Rendering","Web Rendering","Property validation","Property validation with Pattern","Data store validation","You can also use other types of validation that are similar to @Pattern:","@Min, @Max for numbers.","@Unique for collection values.","@Required for a required configuration."]},{"lang":"en","title":"Wrapping a Beam I/O","version":"1.0.2","url":"https://talend.github.io/component-runtime/main/1.0.2/wrapping-a-beam-io.html","date":"2025-09-29T12:44:49Z","timestamp":1759149889038,"lvl0":["Wrapping a Beam I/O"],"lvl1":["Limitations","Wrapping an input","Wrapping an output","Tip","Advanced"],"lvl2":["Coder","JsonObject to IndexedRecord","Sample"],"text":["This part is limited to specific kinds of Beam PTransform:","PTransform<PBegin, PCollection<?>> for inputs.","PTransform<PCollection<?>, PDone> for outputs. Outputs must use a single (composite or not) DoFn in their apply method.","To illustrate the input wrapping, this procedure uses the following input as a starting point (based on existing Beam inputs):","To wrap the Read in a framework component, create a transform delegating to that Read with at least a @PartitionMapper annotation and using @Option constructor injections to configure the component. Also make sure to follow the best practices and to specify @Icon and @Version.","To illustrate the output wrapping, this procedure uses the following output as a starting point (based on existing Beam outputs):","You can wrap this output exactly the same way you wrap an input, but using @Processor instead of:","Note that the org.talend.sdk.component.runtime.beam.transform.DelegatingTransform class fully delegates the \"expansion\" to another transform. Therefore, you can extend it and implement the configuration mapping:","In terms of classloading, when you write an I/O, the Beam SDK Java core stack is assumed as provided in Talend Component Kit runtime. This way, you don’t need to include it in the compile scope, it would be ignored anyway.","If you need a JSonCoder, you can use the org.talend.sdk.component.runtime.beam.factory.service.PluginCoderFactory service, which gives you access to the JSON-P and JSON-B coders.","There is also an Avro coder, which uses the FileContainer. It ensures it is self-contained for IndexedRecord and it does not require—as the default Apache Beam AvroCoder—to set the schema when creating a pipeline. It consumes more space and therefore is slightly slower, but it is fine for DoFn, since it does not rely on serialization in most cases. See org.talend.sdk.component.runtime.beam.transform.avro.IndexedRecordCoder.","The mainstream model is JsonObject but it is common to have a legacy system using IndexedRecord. To mitigate the transition, you can use the following PTransforms:","IndexedRecordToJson: to convert an IndexedRecord to a JsonObject.","JsonToIndexedRecord: to convert a JsonObject to an IndexedRecord.","SchemalessJsonToIndexedRecord: to convert a JsonObject to an IndexedRecord with AVRO schema inference.","Because the Beam wrapper does not respect the standard Talend Component Kit programming model ( for example, there is no @Emitter), you need to set the <talend.validation.component>false</talend.validation.component> property in your pom.xml file (or equivalent for Gradle) to skip the component programming model validations of the framework."]}]