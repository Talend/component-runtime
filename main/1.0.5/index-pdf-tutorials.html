<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talend Component Kit Developer Reference Guide :: Tutorials</title>
    <link rel="canonical" href="https://talend.github.io/component-runtime/main/1.0.5/index-pdf-tutorials.html">
    <meta name="generator" content="Talend Component Kit Generator">
<meta name="date" content="2018-08-31T15:59:01.372Z" scheme="YYYY-MM-DDTHH:mm:ss.sssZ">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" integrity="sha256-NuCn4IvuZXdBaFKJOAcsU2Q3ZpwbdFisd5dux4jkQ5w=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/2.8.0/instantsearch.min.css" integrity="sha256-vusmcqkVvKdkwoueSJZLlO9y2P+Lp9fN3WwQUV9Uwfw=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/2.8.0/instantsearch-theme-algolia.min.css" integrity="sha256-ZqsS4QagZnfArbOyheCO4qVjzzsMbg/WMvf5tLtId/Q=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css" integrity="sha256-rD61BPsgKHzJPyg7vpXaYOw6tMYuY2fz1p9033NYeM8=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@talend/bootstrap-theme@0.200.1/dist/bootstrap.css">
<link rel="stylesheet" href="../../_/css/talend.css">
<link rel="shortcut icon" href="../../_/images/favicon_0.ico" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PSBN"></script>
    <script>dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)};gtag('js',new Date());gtag('config','GTM-PSBN')</script>
  </head>
  <body>
      <svg xmlns="http://www.w3.org/2000/svg" focusable="false" style="display: none;">
    <symbol id="talend-logo-square">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
            <path fill="#FFF" d="M9.694 14.652a1.076 1.076 0 0 1-.715.421 1.086 1.086 0 1 1-.148-2.158c.235 0 .462.075.652.22.23.173.38.427.42.714a1.07 1.07 0 0 1-.209.803M2.15 2.627A1.084 1.084 0 1 1 .418 1.322 1.084 1.084 0 0 1 2.15 2.627m11.383 2.491a2.46 2.46 0 0 0-1.482.494L8.94 1.798a.59.59 0 1 0-.156.125l3.111 3.816a2.486 2.486 0 0 0-.557.718l-8.84-4.062c.065-.19.086-.394.057-.599A1.274 1.274 0 0 0 2.058.95a1.278 1.278 0 0 0-.952-.247 1.286 1.286 0 0 0 .356 2.544 1.279 1.279 0 0 0 .956-.668l8.838 4.06c-.11.264-.176.55-.187.85H3.563a.788.788 0 0 0-.31-.533.799.799 0 0 0-1.113.155.786.786 0 0 0 .156 1.105.799.799 0 0 0 1.267-.527h7.506c.014.323.088.63.215.91l-1.903.941a.592.592 0 1 0 .089.179l1.904-.94c.162.292.382.548.645.753l-2.473 3.404a1.28 1.28 0 0 0-1.742.291 1.288 1.288 0 0 0 .253 1.8 1.28 1.28 0 0 0 .952.246c.34-.048.64-.225.847-.499.207-.274.294-.612.246-.952a1.276 1.276 0 0 0-.399-.763l2.479-3.41a2.468 2.468 0 1 0 1.352-4.53"></path>
        </svg>
    </symbol>
    <symbol id="talend-component-kit-positive">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
            <g fill="none">
                <path fill="#005695" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path>
                <path fill="#FFF" d="M5.69 10.662a2.3 2.3 0 0 0 1.425.492 2.3 2.3 0 0 0 1.664-.709l-.631-.632 1.005-1.005a.33.33 0 0 0 0-.466.332.332 0 0 0-.467 0L7.68 9.347 6.633 8.3l1.005-1.005a.33.33 0 0 0-.467-.466L6.167 7.832l-.653-.652a2.3 2.3 0 0 0-.71 1.664c0 .54.187 1.037.498 1.43L3.878 11.7a.721.721 0 0 0-.358.027 5.824 5.824 0 0 1-.722-6.368c1.364-2.7 4.612-3.914 7.41-2.777l-.348.69 1.584-.369-.643-1.495-.351.695C7.384.832 3.818 2.15 2.32 5.117a6.359 6.359 0 0 0 .798 6.962.704.704 0 0 0 1.26.631.704.704 0 0 0-.036-.699l1.349-1.349z"></path>
                <path fill="#FFF" d="M12.623 3.031a.706.706 0 0 0-.973.894l-1.296 1.298a2.304 2.304 0 0 0-3.092.215l3.266 3.265a2.304 2.304 0 0 0 .213-3.092l1.299-1.297a.701.701 0 0 0 .504.006 5.838 5.838 0 0 1 .675 6.311c-1.332 2.636-4.524 3.871-7.284 2.826l.339-.67-1.585.368.643 1.494.36-.712c3.028 1.18 6.538-.162 8.005-3.064a6.375 6.375 0 0 0-.758-6.912.703.703 0 0 0-.316-.93z"></path>
            </g>
        </svg>
    </symbol>
</svg>

<header class="global-header">
  <nav class="navbar navbar-default">
      <div class="navbar-text-content nav navbar-nav">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <button aria-label="Go to Portal" id="header-talend-logo" type="button" class="btn-icon-only btn btn-link">
            <svg name="talend-logo-square" focusable="false" aria-hidden="true">
                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#talend-logo-square"></use>
            </svg>
        </button>
        <button aria-label="Kit logo" id="header-kit-logo" type="button" class="btn-icon-only btn btn-link">
          <svg name="talend-component-kit-positive" focusable="false" aria-hidden="true">
            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#talend-component-kit-positive"></use>
          </svg>
        </button>
        <a class="navbar-single-link" href="index.html">Talend Component Kit</a>
        <div class="btn-group navbar-versions">
          <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
              Version 1.0.5 <span class="caret"></span>
          </button>
          <ul class="dropdown-menu">
                <li class="navbar-item version is-current is-latest">
                    <a href="index.html">1.0.5</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.4/index.html">1.0.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.3/index.html">1.0.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.2/index.html">1.0.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.1/index.html">1.0.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.0/index.html">1.0.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.12/index.html">0.0.12</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.11/index.html">0.0.11</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.10/index.html">0.0.10</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.9/index.html">0.0.9</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.8/index.html">0.0.8</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.7/index.html">0.0.7</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.6/index.html">0.0.6</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.5/index.html">0.0.5</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.4/index.html">0.0.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.3/index.html">0.0.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.2/index.html">0.0.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.1/index.html">0.0.1</a>
                </li>
          </ul>
        </div>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul class="nav navbar-nav navbar-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Repositories <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a class="navbar-item" href="https://github.com/talend/component-api" target="_blank">API</a></li>
              <li><a class="navbar-item" href="https://github.com/talend/component-runtime" target="_blank">Runtime</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Community <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a class="navbar-item" href="contributors.html">Contributors</a></li>
              <li><a class="navbar-item" href="https://community.talend.com/t5/Component-Development/bd-p/ComponentDevelopment" target="_blank">Forum</a></li>
              <li><a class="navbar-item" href="https://help.talend.com/" target="_blank">Talend Help Center</a></li>
            </ul>
          </li>
        </ul>
        <form role="search" action="search.html" class="navbar-form navbar-right">
          <div class="input-group">
            <span class="input-group-addon"><i class="fa fa-search"></i></span>
            <input class="form-control" type="text" placeholder="Search" name="query" id="searchInput">
          </div>
        </form>
      </div>
    </nav>
</header>
            <main class="main">
              <div class="navigation-container grey-background hidden-xs col-sm-2" data-component="main" data-version="1.0.5">
  <aside class="navigation" role="navigation">
    <div class="panels">
      <div class="input-group nav-filter-group">
        <span class="input-group-addon"><i class="fa fa-search"></i></span>
        <input class="form-control" type="text" placeholder="Filter menu entries..." id="navFilterInput">
      </div>
      <div class="navigation-menu is-active" data-panel="menu">
        <nav class="nav-menu">
          <!-- <label>Talend Component Kit Developer Reference Guide</label> -->
          <ul class="nav nav-list tree" >
  <li data-depth="0">
      
    <ul class="nav nav-list tree" >
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Getting Started</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-getting-started-with-tck.html">Getting Started overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="methodology-creating-components.html">Development methodology</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tck-framework-overview.html">Framework Overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-execution.html">General component execution logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-my-first-component.html">Creating your first component</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Tutorials</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-tutorials.html">Tutorial overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-my-first-component.html">Creating your first component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-generate-project-using-starter.html">Generating a project from the starter</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-an-input-component.html">Creating a Hazelcast input component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-an-output-component.html">Creating a Hazelcast output component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-components-rest-api.html">Creating a Zendesk REST API connector</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-test-rest-api.html">Testing a Zendesk REST API connector</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-test-your-components.html">Testing a Hazelcast component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-dev-vs-ci-setup.html">Testing in a continuous integration environment</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-handle-talend-component-migration.html">Handle Talend component migration</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Setting up your environment</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-setup-environment.html">Setup overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="system-prerequisites.html">System requirements</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="installing-talend-intellij-plugin.html">Installing the IntelliJ plugin</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Generating a project</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-generating-project.html">Project generation overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-generate-project-using-starter.html">Using the starter</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="generate-project-using-intellij-plugin.html">Using the IntelliJ plugin</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Implementing components</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-creating-components.html">Component implementation overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-registering.html">Defining component metadata</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-define-input.html">Defining an input component logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-define-processor-output.html">Defining a processor/output logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-configuration.html">Defining component configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-internationalization.html">Internationalizing a component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-versions-and-migration.html">Managing component versions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-configuration-sensitive-data.html">Masking sensitive data</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="concept-processor-and-batch-processing.html">Implementing batch processing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="best-practices.html">Best practices</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-loading.html">Loading a component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="build-tools-maven.html">Building components with Maven</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="build-tools-gradle.html">Building components with Gradle</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="wrapping-a-beam-io.html">Wrapping a Beam I/O</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Defining services</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-defining-services.html">Service overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-internationalization.html">Internationalizing a service</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-actions.html">Providing actions through a service</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-built-in.html">Built-in services</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-interceptors.html">Services and interceptors</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-custom-api.html">Defining a custom API</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Testing components</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-testing-components.html">Component testing overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-best-practices.html">Component testing best practices</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="index-sub-testing-runtime.html">Testing component runtime</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-beam.html">Beam testing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-multiple-envs.html">Testing in multiple environments</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-maven-passwords.html">Reusing Maven credentials</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-generating-data.html">Generating data for testing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-pipeline.html">Simple/Test Pipeline API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="https://beam.apache.org/documentation/programming-guide/#creating-a-pipeline">Beam Pipeline API</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Integrating into Talend Studio</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-deploying-components.html">Studio integration overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="studio.html">Deploying to Talend Studio</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Integrating into Talend Cloud</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-cloud-integration.html">Cloud integration overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="documentation-rest.html">Component server and HTTP API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="server-uispec.html">UiSpec Server</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Knowledge base</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-knowledge-base.html">Knowledge base articles</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="changelog.html">Changelog</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Reference Guide</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="gallery.html">Widget and validation gallery</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-actions.html">Actions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-conditions.html">Conditions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-configuration-types.html">Configuration types</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-constraints.html">Constraints</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-junit-environments.html">Junit environments</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-proxy-server-api.html">Proxy server API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-proxy-server-configuration.html">Proxy server configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-rest-resources.html">HTTP API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-scanning-exclusions.html">Scanning exclusions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-server-configuration.html">Server configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-ui.html">UI API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="apidocs.html">Javadocs</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
        </nav>
      </div>
    </div>
  </aside>
</div>
              <div class="col-xs-12 col-sm-10 maincontent">
                <div class="toolbar" role="navigation">

    <ol class="breadcrumb">
      <li class="crumb active"><a href="index-pdf-tutorials.html">Tutorials</a></li>
    </ol>
</div>
                <article class="doc">
        <div class="row">
          <div class="col-sm-9 row">
              <h1>Tutorials</h1>
            <div class="article-content">
              <div class="sect1">
<h2 id="_generating_a_project_using_the_component_kit_starter"><a class="anchor" href="#_generating_a_project_using_the_component_kit_starter"></a>Generating a project using the Component Kit starter</h2>
<div class="sectionbody">
<div id="tutorial-generate-project-using-starter" class="paragraph">
<p>The Component Kit starter lets you design your components configuration and generates a ready-to-implement project structure.</p>
</div>
<div class="paragraph">
<p>This tutorial shows you how to use the Component Kit starter to generate new components for MySQL databases. Before starting, make sure that you have correctly setup your environment. See <a href="getting-started.html#getting-started-system-requirements" class="page">this section</a>.</p>
</div>
<div class="sect2">
<h3 id="_configuring_the_project"><a class="anchor" href="#_configuring_the_project"></a>Configuring the project</h3>
<div class="paragraph">
<p>Before being able to create components, you need to define the general settings of the project:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a folder on your local machine to store the resource files of the component you want to create. For example, <code>C:/my_components</code>.</p>
</li>
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Select your build tool. This tutorial uses Maven, but you can select Gradle instead.</p>
</li>
<li>
<p>Add the <strong>Talend Component Kit Testing</strong> facet to your project to automatically generate unit tests for the components created later in this tutorial.</p>
</li>
<li>
<p>Enter the <strong>Component Family</strong> of the components you want to develop in the project. This name must be a valid java name and is recommended to be capitalized, for example 'MySQL'.<br>
Once you have implemented your components in the Studio, this name is displayed in the Palette to group all of the MySQL-related components you develop, and is also part of your component name.</p>
</li>
<li>
<p>Select the <strong>Category</strong> of the components you want to create in the current project. As MySQL is a kind of database, select <strong>Databases</strong> in this tutorial.<br>
This <strong>Databases</strong> category is used and displayed as the parent family of the MySQL group in the Palette of the Studio.</p>
</li>
<li>
<p>Complete the project metadata by entering the <strong>Group</strong>, <strong>Artifact</strong> and <strong>Package</strong>.</p>
</li>
<li>
<p>Click the <strong>ADD A COMPONENT</strong> button to start designing your components.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/starter/starter_project-config.png" alt="Project configuration">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_input_component"><a class="anchor" href="#_creating_an_input_component"></a>Creating an Input component</h3>
<div class="paragraph">
<p>When clicking <strong>ADD A COMPONENT</strong> in the starter, a new step that allows you to define a new component is created in your project.<br>
The intent in this tutorial is to create an input component that connects to a MySQL database, executes a SQL query and gets the result.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/starter/starter_input-config.png" alt="Input configuration">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>INPUT</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLInput</em>.</p>
</li>
<li>
<p>Click <strong>CONFIGURATION MODEL</strong>. This button lets you specify the required configuration for the component.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes.<br>
In this tutorial, to be able to execute a SQL query on the Input MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a connection URL (string)</p>
</li>
<li>
<p>a username (string)</p>
</li>
<li>
<p>a password (string)</p>
</li>
<li>
<p>the SQL query to be executed (string).<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Specify whether the component issues a stream or not. In this tutorial, the MySQL input component created is an ordinary (non streaming) component. In this case, let the toggle button disabled.</p>
</li>
<li>
<p>Select the <strong>Record Type</strong> generated by the component. In this tutorial, select <strong>Generic</strong> because the component is designed to generate JSON records.<br>
You can also select <strong>Custom</strong> to define a POJO that represents your records.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your input component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_processor_component"><a class="anchor" href="#_creating_a_processor_component"></a>Creating a Processor component</h3>
<div class="paragraph">
<p>When clicking <strong>ADD A COMPONENT</strong> in the starter, a new step that allows you to define a new component is created in your project.<br>
The intent in this tutorial is to create a simple processor component that receives a record, logs it and returns it at it is.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/starter/starter_processor-config.png" alt="Processor configuration">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>PROCESSOR/OUTPUT</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>RecordLogger</em>, as the processor created in this tutorial logs the records.</p>
</li>
<li>
<p>Specify the <strong>CONFIGURATION MODEL</strong> of the component. In this tutorial, the component doesn&#8217;t need any specific configuration. Skip this step.</p>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>ADD INPUT</strong>. In this tutorial, only one input is needed to receive the record to log.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option.</p>
</li>
<li>
<p>Define the <strong>Output(s)</strong> of the component. For each output that you need to define, click <strong>ADD OUTPUT</strong>. In this tutorial, only one generic output is needed to return the received record.<br>
Outputs can be configured the same way as inputs (see previous steps).</p>
</li>
<li>
<p>Make sure to check the configuration of inputs and outputs as they are not set to <strong>Generic</strong> by default.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your processor component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_output_component"><a class="anchor" href="#_creating_an_output_component"></a>Creating an Output component</h3>
<div class="paragraph">
<p>When clicking <strong>ADD A COMPONENT</strong> in the starter, a new step that allows you to define a new component is created in your project.<br>
The intent in this tutorial is to create an output component that receives a record and inserts it into a MySQL database table.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Output</strong> components are <strong>Processors</strong> without any output. In other words, the output is a processor that does not produce any records.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/starter/starter_output-config.png" alt="Output configuration">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>PROCESSOR/OUTPUT</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLOutput</em>.</p>
</li>
<li>
<p>Click <strong>CONFIGURATION MODEL</strong>. This button lets you specify the required configuration for the component.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes.<br>
In this tutorial, to be able to insert a record in the output MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a connection URL (string)</p>
</li>
<li>
<p>a username (string)</p>
</li>
<li>
<p>a password (string)</p>
</li>
<li>
<p>the name of the table to insert the record in (string).<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>ADD INPUT</strong>. In this tutorial, only one input is needed.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option.</p>
</li>
<li>
<p>Do not create any output because the component does not produce any record. This is the only difference between an output an a processor component.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your output component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generating_and_downloading_the_final_project"><a class="anchor" href="#_generating_and_downloading_the_final_project"></a>Generating and downloading the final project</h3>
<div class="paragraph">
<p>Once your project is configured and all the components you need are created, you can generate and download the final project.
In this tutorial, the project was configured and three components of different types (input, processor and output) have been defined.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Click <strong>GO TO FINISH</strong> at the bottom of the page. You are redirected to a page that summarizes the project. On the left panel, you can also see all the components that you added to the project.</p>
<div class="imageblock">
<div class="content">
<img src="_images/starter/starter_project-download.png" alt="Output configuration">
</div>
</div>
</li>
<li>
<p>Generate the project using one of the two options available:</p>
<div class="ulist">
<ul>
<li>
<p>Download it locally as a ZIP file using the <strong>DOWNLOAD AS ZIP</strong> button.</p>
</li>
<li>
<p>Create a GitHub repository and push the project to it using the <strong>CREATE ON GITHUB</strong> button.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this tutorial, the project is downloaded to the local machine as a ZIP file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compiling_and_exploring_the_generated_project_files"><a class="anchor" href="#_compiling_and_exploring_the_generated_project_files"></a>Compiling and exploring the generated project files</h3>
<div class="paragraph">
<p>Once the package is available on your machine, you can compile it using the build tool selected when configuring the project.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the tutorial, <strong>Maven</strong> is the build tool selected for the project.<br>
In the project directory, execute the <code>mvn package</code> command.<br>
If you don&#8217;t have Maven installed on your machine, you can use the Maven wrapper provided in the generated project, by executing the <code>./mvnw package</code> command.</p>
</li>
<li>
<p>If you have created a Gradle project, you can compile it using the <code>gradle build</code> command or using the Gradle wrapper: <code>./gradlew build</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated project code contains documentation that can guide and help you implementing the component logic.
Import the project to your favorite IDE to start the implementation.</p>
</div>
<div class="paragraph">
<p>The next tutorial shows how to implement an Input component in details.</p>
</div>
</div>
<div class="sect2 relatedlinks">
<h3 id="_related_articles"><a class="anchor" href="#_related_articles"></a>Related articles</h3>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology</a></p>
</li>
<li>
<p><a href="tutorial-create-an-input-component.html" class="page">Creating a Hazelcast input component</a></p>
</li>
<li>
<p><a href="tutorial-create-an-output-component.html" class="page">Creating a Hazelcast output component</a></p>
</li>
<li>
<p><a href="tutorial-create-components-rest-api.html" class="page">Creating a Zendesk REST API connector</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_an_input_component"><a class="anchor" href="#_implementing_an_input_component"></a>Implementing an input component</h2>
<div class="sectionbody">
<div id="tutorial-create-an-input-component" class="paragraph">
<p>This tutorial shows how to create a complete working input component for <a href="https://hazelcast.org">Hazelcast</a>, including:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Registering the component family.</p>
</li>
<li>
<p>Defining the configurable part and the layout of the component.</p>
</li>
<li>
<p>Configuring the partition mapper, to let the input split itself to work in a distributed environment.</p>
</li>
<li>
<p>Configuring the source that is responsible for connecting and reading data from the data source.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Getter and Setter methods are omitted for simplicity in this tutorial.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following procedures assume that you have already generated the component package from the Talend Component Kit starter. See <a href="tutorial-generate-project-using-starter.html" class="page">this tutorial</a> to learn how to generate this package.</p>
</div>
<div class="sect2">
<h3 id="_registering_the_component_family"><a class="anchor" href="#_registering_the_component_family"></a>Registering the component family</h3>
<div class="paragraph">
<p>Register the component family via a the <code>package-info.java</code> file in the package of the component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Icon(value = Icon.IconType.CUSTOM, custom = "hazelcast") <i class="conum" data-value="1"></i><b>(1)</b>
@Components(family = "Hazelcast", categories = "IMDG") <i class="conum" data-value="2"></i><b>(2)</b>
package org.talend.hazelcast;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This define the family icon.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In this line we define the component family and the component categories.
Those information are used in the web and studio applications to group the components.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="defining-component-configuration"><a class="anchor" href="#defining-component-configuration"></a>Defining the configurable part and the layout of the component</h3>
<div class="paragraph">
<p>The component configuration includes defining the part of the components that can be configured once integrated to Talend solutions, in addition to the configuration type and the UI layout.</p>
</div>
<div class="paragraph">
<p>The configuration is a POJO class decorated with annotations from the component framework.
In this case, the component is configured as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({ <i class="conum" data-value="1"></i><b>(1)</b>
        @GridLayout.Row({ "hazelcastXml", "mapName" }),
        @GridLayout.Row({ "executorService" }),
})
public class HazelcastConfiguration implements Serializable {

    @Option <i class="conum" data-value="2"></i><b>(2)</b>
    private String hazelcastXml; <i class="conum" data-value="3"></i><b>(3)</b>

    @Option
    private String mapName; <i class="conum" data-value="4"></i><b>(4)</b>

    @Option
    private String executorService = "default"; <i class="conum" data-value="5"></i><b>(5)</b>

    ClientConfig newConfig() throws IOException { <i class="conum" data-value="6"></i><b>(6)</b>
        final ClientConfig newconfig = hazelcastXml == null ? new XmlClientConfigBuilder().build() :
                new XmlClientConfigBuilder(hazelcastXml).build();

        newconfig.setInstanceName(getClass().getSimpleName() + "_" + UUID.randomUUID().toString());
        newconfig.setClassLoader(Thread.currentThread().getContextClassLoader());
        return newconfig;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>UI layout of the configurable part of the component.
This layout is used to show and organize the configuration Talend applications.<br>
In the example above, <strong>hazelcastXml</strong> and <strong>mapName</strong> are displayed on the same row and all rows are displayed in the default basic configuration tab of the component.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>All the attributes annotated with <code>@Option</code> are recognized as configuration elements and are bound to a default widget according to their type, unless a specific widget is explicitly declared. For more details, see the <a href="gallery.html" class="page">widget gallery</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Path of the Hazelcast XML configuration file.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Name of the map to be read.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Executor service name, with a default value set to <code>default</code> in this case.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Utility method that converts the configuration into a Hazelcast client configuration object.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Read more about component configuration in <a href="component-configuration.html" class="page">this document</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_partition_mapper"><a class="anchor" href="#_configuring_the_partition_mapper"></a>Configuring The Partition Mapper</h3>
<div class="paragraph">
<p>The Hazelcast component created through this tutorial needs to work first in distributed environments.</p>
</div>
<div class="paragraph">
<p>Every input component has to define a partition mapper class.</p>
</div>
<div class="paragraph">
<p>At runtime, this class heuristically estimates the size of the data to be handled. Based on this estimation and on the capacity of the execution engine of your component, it divides the work of your component to reduce the overall execution time.</p>
</div>
<div class="paragraph">
<p>For more information about the partition mapper class, see <a href="component-partition-mapper.html" class="page">Partition mapper</a>.</p>
</div>
<div class="paragraph">
<p>The skeleton of the partition mapper looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(1) <i class="conum" data-value="1"></i><b>(1)</b>
@Icon(value = Icon.IconType.CUSTOM, custom = "hazelcastInput") <i class="conum" data-value="2"></i><b>(2)</b>
@PartitionMapper(name = "Input") <i class="conum" data-value="3"></i><b>(3)</b>
public class HazelcastMapper implements Serializable {
    private final HazelcastConfiguration configuration;
    private final JsonBuilderFactory jsonFactory;
    private final Jsonb jsonb;
    private final HazelcastService service;

    public HazelcastMapper(@Option("configuration") final HazelcastConfiguration configuration,
            final JsonBuilderFactory jsonFactory,
            final Jsonb jsonb,
            final HazelcastService service) {} <i class="conum" data-value="4"></i><b>(4)</b>

    @PostConstruct
    public void init() throws IOException {}  <i class="conum" data-value="5"></i><b>(5)</b>

    @PreDestroy
    public void close() {} <i class="conum" data-value="6"></i><b>(6)</b>

    @Assessor
    public long estimateSize() {} <i class="conum" data-value="7"></i><b>(7)</b>

    @Split
    public List&lt;HazelcastMapper&gt; split(@PartitionSize final long bundleSize) {} <i class="conum" data-value="8"></i><b>(8)</b>

    @Emitter
    public HazelcastSource createSource() {}  <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Version</code> annotation specifies the version of the component. it is used to migrate the component configuration if needed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@Icon</code> annotation specifies the icon of the component. In this case, a custom icon is used and needs to be bundled in the component JAR under <code>resources/icons</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>@PartitionMapper</code> annotation indicates that this class is the partition mapper and defines its name.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This constructor of the mapper is responsible for injecting the component configuration and services.
<div class="ulist">
<ul>
<li>
<p>Configuration parameters are annotated with <code>@Option</code>.</p>
</li>
<li>
<p>Other parameters are considered as services and are injected by the component framework. Services can be local (classes annotated with <code>@Service</code>) or provided by the component framework.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The method annotated with <code>@PostConstruct</code> is executed once on the driver node in a distributed environment and can be used for initialization.
Here, the goal is to get the Hazelcast instance according to the provided configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The method annotated with <code>@PreDestroy</code> is used to clean resources at the end of the execution of the partition mapper.<br>
In the context of this tutorial, the Hazelcast instance loaded in the post Construct method is shut down.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The method annotated with <code>@Assessor</code> is responsible for calculating the size of  the dataset containing the Hazelcast members.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The method annotated with <code>@Split</code> is responsible for splitting this mapper according to the bundle size requested by the runner and to the hole dataset size.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The method annotated with <code>@Emitter</code> is responsible for creating the producer instance that reads the data from the data source (Hazelcast in this case).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each of the methods mentioned above now needs to be created.</p>
</div>
<div class="sect3">
<h4 id="_defining_the_constructor_method"><a class="anchor" href="#_defining_the_constructor_method"></a>Defining the constructor method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private final Collection&lt;String&gt; members; <i class="conum" data-value="1"></i><b>(1)</b>

<i class="conum" data-value="2"></i><b>(2)</b>
public HazelcastMapper(@Option("configuration") final HazelcastConfiguration configuration,
        final JsonBuilderFactory jsonFactory,
        final Jsonb jsonb,
        final HazelcastService service) {
    this(configuration, jsonFactory, jsonb, service, emptyList());
}

// internal <i class="conum" data-value="3"></i><b>(3)</b>
protected HazelcastMapper(final HazelcastConfiguration configuration,
        final JsonBuilderFactory jsonFactory,
        final Jsonb jsonb,
        final HazelcastService service,
        final Collection&lt;String&gt; members) {
    this.configuration = configuration;
    this.jsonFactory = jsonFactory;
    this.jsonb = jsonb;
    this.service = service;
    this.members = members;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add a collection attribute to the mapper. The list of Hazelcast members is needed later in the process.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Define the component public constructor, which is responsible for injecting configuration and services.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Add an internal constructor to get the collection of the Hazelcast cluster members.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="post-construct-method"><a class="anchor" href="#post-construct-method"></a>Defining the PostConstruct method</h4>
<div class="paragraph">
<p>The @PostConstruct method is used to initialize a Hazelcast client instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private transient HazelcastInstance instance; <i class="conum" data-value="1"></i><b>(1)</b>

@PostConstruct
The method annotated with @PostConstruct is used to initialize a Hazelcast client instance.

public void init() throws IOException {
    instance = service.findInstance(configuration.newConfig()); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare the Hazelcast instance as an attribute for the mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Create an instance of Hazelcast according to the provided configuration.
In this case, the injected HazelcastService instance is used. This service is implemented in the project.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The HazelcastService is implemented as follows.
Every class annotated with <code>@Service</code> can be injected to the component via its constructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.talend.sdk.component.api.service.Service;

@Service
public class HazelcastService {
    public HazelcastInstance findInstance(final ClientConfig config) {
        return HazelcastClient.newHazelcastClient(config); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new instance of the Hazelcast client.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_predestroy_method"><a class="anchor" href="#_defining_the_predestroy_method"></a>Defining the PreDestroy method</h4>
<div class="paragraph">
<p>The method annotated with @PreDestroy cleans up the resources at the end of the execution of the partition mapper.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private transient IExecutorService executorService; <i class="conum" data-value="1"></i><b>(1)</b>

@PreDestroy
public void close() { <i class="conum" data-value="2"></i><b>(2)</b>
    instance.getLifecycleService().shutdown();
    executorService = null;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare the execution service as an attribute for the mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Shut down the Hazelcast client instance created by the method annotated with <code>@PostConstruct</code> and thus free the <code>executorService</code> reference.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_assessor_method"><a class="anchor" href="#_defining_the_assessor_method"></a>Defining the Assessor method</h4>
<div class="paragraph">
<p>The method annotated with @Assessor is used to estimate the volume of the dataset to be handled.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Assessor
public long estimateSize() {
    return getSizeByMembers() <i class="conum" data-value="1"></i><b>(1)</b>
                    .values().stream()
                    .mapToLong(this::getFutureValue) <i class="conum" data-value="2"></i><b>(2)</b>
                    .sum(); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>getSizeByMembers()</code> method submits a task to each Hazelcast member to calculate the member size locally and asynchronously..</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>mapToLong()</code> method gets the size calculated by that task.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>sum()</code> method calculates the total size of all the members.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then, you can Implement the methods annotated with @PreDestroy and @Accessor to create a map of the volumes of the Hazelcast cluster members.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private Map&lt;Member, Future&lt;Long&gt;&gt; getSizeByMembers() {
    final IExecutorService executorService = getExecutorService();
    final SerializableTask&lt;Long&gt; sizeComputation = new SerializableTask&lt;Long&gt;() {

        @Override
        public Long call() throws Exception {

            return localInstance.getMap(configuration.getMapName()).getLocalMapStats().getHeapCost();
        }
    };
    if (members.isEmpty()) { // == if no specific members defined, apply on all the cluster
        return executorService.submitToAllMembers(sizeComputation);
    }
    final Set&lt;Member&gt; members = instance.getCluster().getMembers().stream()
            .filter(m -&gt; this.members.contains(m.getUuid()))
            .collect(toSet());
    return executorService.submitToMembers(sizeComputation, members);
}

private IExecutorService getExecutorService() {
    return executorService == null ?
            executorService = instance.getExecutorService(configuration.getExecutorService()) :
            executorService;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_split_method"><a class="anchor" href="#_defining_the_split_method"></a>Defining the Split method</h4>
<div class="paragraph">
<p>The method annotated with <code>@Split</code> dynamically splits the partition mapper into a collection of sub-mappers according to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the bundle size required by the execution engine to be used.</p>
</li>
<li>
<p>to the volume of the dataset to handle.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Split
public List&lt;HazelcastMapper&gt; split(@PartitionSize final long bundleSize) {
    final List&lt;HazelcastMapper&gt; partitions = new ArrayList&lt;&gt;();
    final Collection&lt;Member&gt; members = new ArrayList&lt;&gt;();
    long current = 0;
    for (final Map.Entry&lt;Member, Future&lt;Long&gt;&gt; entries : getSizeByMembers().entrySet()) {
        final long memberSize = getFutureValue(entries.getValue());
        if (members.isEmpty()) {
            members.add(entries.getKey());
            current += memberSize;
        } else if (current + memberSize &gt; bundleSize) {
            partitions.add(
                    new HazelcastMapper(configuration, jsonFactory, jsonb, service, toIdentifiers(members)));
            // reset current iteration
            members.clear();
            current = 0;
        }
    }
    if (!members.isEmpty()) {
        partitions.add(new HazelcastMapper(configuration, jsonFactory, jsonb, service, toIdentifiers(members)));
    }

    if (partitions.isEmpty()) { // just execute this if no plan (= no distribution)
        partitions.add(this);
    }
    return partitions;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_emitter_method"><a class="anchor" href="#_the_emitter_method"></a>The Emitter method</h4>
<div class="paragraph">
<p>The method annotated with <code>@Emitter</code> generates producers using the component configuration. It can be used to load data to the processing flow of a Talend Job. Each sub-mapper generates one producer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Emitter
public HazelcastSource createSource() {
    return new HazelcastSource(configuration, jsonFactory, jsonb, service, members); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After splitting the mapper, every mapper creates a producer that reads the records according to the provided configuration.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_full_implementation_of_the_partition_mapper"><a class="anchor" href="#_full_implementation_of_the_partition_mapper"></a>Full implementation of the Partition Mapper</h4>
<div class="paragraph">
<p>Once implemented, the Partition Mapper configuration is as follows. For more information about Partition Mappers, refer to <a href="component-partition-mapper.html" class="page">this document</a>.</p>
</div>
<div class="listingblock initial-block-closed">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(1) <i class="conum" data-value="1"></i><b>(1)</b>
@Icon(Icon.IconType.DB_INPUT) <i class="conum" data-value="2"></i><b>(2)</b>
@PartitionMapper(name = "Input") <i class="conum" data-value="3"></i><b>(3)</b>
public class HazelcastMapper implements Serializable {
    private final HazelcastConfiguration configuration;
    private final JsonBuilderFactory jsonFactory;
    private final Jsonb jsonb;
    private final HazelcastService service;

    private final Collection&lt;String&gt; members;
    private transient HazelcastInstance instance;
    private transient IExecutorService executorService;

    // framework API
    public HazelcastMapper(@Option("configuration") final HazelcastConfiguration configuration,
            final JsonBuilderFactory jsonFactory,
            final Jsonb jsonb,
            final HazelcastService service) {
        this(configuration, jsonFactory, jsonb, service, emptyList());
    }

    // internal
    protected HazelcastMapper(final HazelcastConfiguration configuration,
            final JsonBuilderFactory jsonFactory,
            final Jsonb jsonb,
            final HazelcastService service,
            final Collection&lt;String&gt; members) {
        this.configuration = configuration;
        this.jsonFactory = jsonFactory;
        this.jsonb = jsonb;
        this.service = service;
        this.members = members;
    }

    @PostConstruct
    public void init() throws IOException {
        // Creates an instance of Hazelcast according to the provided configuration.
        // Uses the injected HazelcastService instance to perform that.
        // This service is implemented in the project. See the implementation in &lt;1&gt;.
        instance = service.findInstance(configuration.newConfig());
    }

    @PreDestroy
    public void close() {
        // Shuts down the instance created in the PostConstruct and frees the executorService reference.
        instance.getLifecycleService().shutdown();
        executorService = null;
    }

    @Assessor
    public long estimateSize() {
        // Calculates the whole size of all members.
        return getSizeByMembers().values().stream()
                .mapToLong(this::getFutureValue)
                .sum();
    }

    // This method returns a map of size by member of Hazelcast cluster
    private Map&lt;Member, Future&lt;Long&gt;&gt; getSizeByMembers() {
        final IExecutorService executorService = getExecutorService();
        final SerializableTask&lt;Long&gt; sizeComputation = new SerializableTask&lt;Long&gt;() {

            @Override
            public Long call() throws Exception {

                return localInstance.getMap(configuration.getMapName()).getLocalMapStats().getHeapCost();
            }
        };
        if (members.isEmpty()) { // == if no specific memebers defined, applies to all the cluster
            return executorService.submitToAllMembers(sizeComputation);
        }
        final Set&lt;Member&gt; members = instance.getCluster().getMembers().stream()
                .filter(m -&gt; this.members.contains(m.getUuid()))
                .collect(toSet());
        return executorService.submitToMembers(sizeComputation, members);
    }

    // This method creates a collection of mappers according to the requested bundleSize and the dataset size.
    @Split
    public List&lt;HazelcastMapper&gt; split(@PartitionSize final long bundleSize) {
        final List&lt;HazelcastMapper&gt; partitions = new ArrayList&lt;&gt;();
        final Collection&lt;Member&gt; members = new ArrayList&lt;&gt;();
        long current = 0;
        for (final Map.Entry&lt;Member, Future&lt;Long&gt;&gt; entries : getSizeByMembers().entrySet()) {
            final long memberSize = getFutureValue(entries.getValue());
            if (members.isEmpty()) {
                members.add(entries.getKey());
                current += memberSize;
            } else if (current + memberSize &gt; bundleSize) {
                partitions.add(
                        new HazelcastMapper(configuration, jsonFactory, jsonb, service, toIdentifiers(members)));
                // Resets current iteration
                members.clear();
                current = 0;
            }
        }
        if (!members.isEmpty()) {
            partitions.add(new HazelcastMapper(configuration, jsonFactory, jsonb, service, toIdentifiers(members)));
        }

        if (partitions.isEmpty()) { // just executes this if no plan (= no distribution)
            partitions.add(this);
        }
        return partitions;
    }

    //After splitting the mapper, every mappers creates an emitter that
    // reads the records according to the provided configuration.
    @Emitter
    public HazelcastSource createSource() {
        return new HazelcastSource(configuration, jsonFactory, jsonb, service, members);
    }

    private Set&lt;String&gt; toIdentifiers(final Collection&lt;Member&gt; members) {
        return members.stream().map(Member::getUuid).collect(toSet());
    }

    private long getFutureValue(final Future&lt;Long&gt; future) {
        try {
            return future.get(configuration.getTimeout(), SECONDS);
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException(e);
        } catch (final ExecutionException | TimeoutException e) {
            throw new IllegalArgumentException(e);
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = instance.getExecutorService(configuration.getExecutorService()) :
                executorService;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_producer_source"><a class="anchor" href="#_configuring_the_producer_source"></a>Configuring the Producer (Source)</h3>
<div class="paragraph">
<p>The component configuration and the partition mapper in charge of creating the producers are now defined. At this point, you can implement the source logic that uses the configuration provided by the mapper to read the records from the data source.</p>
</div>
<div class="paragraph">
<p>To implement a source, you need to define the producer method that creates a record every time it is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HazelcastSource implements Serializable {
    private final HazelcastConfiguration configuration;
    private final JsonBuilderFactory jsonFactory;
    private final Jsonb jsonb;
    private final HazelcastService service;
    private final Collection&lt;String&gt; members;
    private transient HazelcastInstance instance;
    private transient BufferizedProducerSupport&lt;JsonObject&gt; buffer; <i class="conum" data-value="1"></i><b>(1)</b>

    // The constructor is omitted on purpose to reduce the length of this sample code

    @PostConstruct <i class="conum" data-value="2"></i><b>(2)</b>
    public void createInstance() throws IOException {
        instance = service.findInstance(configuration.newConfig());
        final Iterator&lt;Member&gt; memberIterators = instance.getCluster().getMembers().stream()
                .filter(m -&gt; members.isEmpty() || members.contains(m.getUuid()))
                .collect(toSet())
                .iterator();

        buffer = new BufferizedProducerSupport&lt;&gt;(() -&gt; {
            if (!memberIterators.hasNext()) {
                return null;
            }
            final Member member = memberIterators.next();
            // Note: this works if this JAR is deployed on the Hazelcast cluster
            try {
                return instance.getExecutorService(configuration.getExecutorService())
                        .submitToMember(new SerializableTask&lt;Map&lt;String, String&gt;&gt;() {

                            @Override
                            public Map&lt;String, String&gt; call() throws Exception {
                                final IMap&lt;Object, Object&gt; map = localInstance.getMap(configuration.getMapName());
                                final Set&lt;?&gt; keys = map.localKeySet();
                                return keys.stream().collect(toMap(jsonb::toJson, e -&gt; jsonb.toJson(map.get(e))));
                            }
                        }, member).get(configuration.getTimeout(), SECONDS).entrySet().stream()
                        .map(entry -&gt; {
                            final JsonObjectBuilder builder = jsonFactory.createObjectBuilder();
                            if (entry.getKey().startsWith("{")) {
                                builder.add("key", jsonb.fromJson(entry.getKey(), JsonObject.class));
                            } else { // plain string
                                builder.add("key", entry.getKey());
                            }
                            if (entry.getValue().startsWith("{")) {
                                builder.add("value", jsonb.fromJson(entry.getValue(), JsonObject.class));
                            } else { // plain string
                                builder.add("value", entry.getValue());
                            }
                            return builder.build();
                        })
                        .collect(toList())
                        .iterator();
            } catch (final InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new IllegalStateException(e);
            } catch (final ExecutionException | TimeoutException e) {
                throw new IllegalArgumentException(e);
            }
        });
    }

    @Producer <i class="conum" data-value="3"></i><b>(3)</b>
    public JsonObject next() {
        return buffer.next();
    }

    @PreDestroy <i class="conum" data-value="4"></i><b>(4)</b>
    public void destroyInstance() {
        // Shutdown of the Hazelcast instance
        instance.getLifecycleService().shutdown();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>BufferizedProducerSupport is a utility class that encapsulates the buffering logic. It allows to only provide instructions on how to load the data rather than the logic to iterate on it. In this case, the buffer is created in the <code>@PostConstruct</code> method and loaded once, and is then used to produce records one by one.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The method annotated with <code>@PostConstruct</code> is invoked once on the node. It allows to create some connections and to initialize the buffering.
In this case, the BufferizedProducerSupport class is used to create a buffer of records in this method.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method annotated with <code>@Producer</code> is responsible for producing records. This method returns <code>null</code> when there is no more record to read.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The method annotated with <code>@PreDestroy</code> is called before the Source destruction and is used to clean up all the resources used in the Source.
In this case, the Hazelcast instance created in the post construct method is shut down.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To learn more about producers, refer to <a href="component-producer.html" class="page">this document</a>.</p>
</div>
<div class="paragraph">
<p>You have now created a complete working input component. You can follow  <a href="tutorial-test-your-components.html" class="page">this tutorial</a> to learn how to create unit tests for your new component.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_an_output_component"><a class="anchor" href="#_implementing_an_output_component"></a>Implementing an Output component</h2>
<div class="sectionbody">
<div id="tutorial-create-an-output-component" class="paragraph">
<p>This tutorial shows how to create a complete working output component for <a href="https://hazelcast.org">Hazelcast</a>, including:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Defining the configurable part and the layout of the component.</p>
</li>
<li>
<p>Defining the output that is responsible for connecting and writing data to the data source.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_defining_the_configurable_part_and_the_layout_of_the_component"><a class="anchor" href="#_defining_the_configurable_part_and_the_layout_of_the_component"></a>Defining the configurable part and the layout of the component</h3>
<div class="paragraph">
<p>The methodology to define the component configuration is described in the <a href="tutorial-create-an-input-component.html#defining-component-configuration" class="page">Implementing an input component</a> tutorial.</p>
</div>
<div class="paragraph">
<p>In this case, the input component configuration defined in the tutorial mentioned above can be used as a starting point.</p>
</div>
<div class="paragraph">
<p>Two additional fields are required for the output component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
private String keyAttribute;

@Option
private String valueAttribute;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These fields are used to determine the key and value attributes for the Hazelcast map.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_output"><a class="anchor" href="#_configuring_the_output"></a>Configuring the Output</h3>
<div class="paragraph">
<p>The output component needs to work in distributed environments and should implement a serializable interface.</p>
</div>
<div class="paragraph">
<p>The skeleton of the output component looks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version <i class="conum" data-value="1"></i><b>(1)</b>
@Icon(custom = "hazelcastOutput", value = CUSTOM) <i class="conum" data-value="2"></i><b>(2)</b>
@Processor(name = "Output") <i class="conum" data-value="3"></i><b>(3)</b>
public class HazelcastOutput implements Serializable {
    private final HazelcastConfiguration configuration;
    private final JsonBuilderFactory jsonFactory;
    private final Jsonb jsonb;
    private final HazelcastService service;


    public HazelcastOutput(@Option("configuration") final HazelcastConfiguration configuration,
                           final JsonBuilderFactory jsonFactory,
                           final Jsonb jsonb,
                           final HazelcastService service) {} <i class="conum" data-value="4"></i><b>(4)</b>

    @PostConstruct
    public void init() {} <i class="conum" data-value="5"></i><b>(5)</b>

    @PreDestroy
    public void release() {} <i class="conum" data-value="6"></i><b>(6)</b>

    @ElementListener
    public void onElement(final JsonObject defaultInput) {} <i class="conum" data-value="7"></i><b>(7)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Version</code> annotation indicates the version of the component. It is used to migrate the component configuration if needed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@Icon</code> annotation indicates the icon of the component. Here, the icon is a custom icon that needs to be bundled in the component JAR under <code>resources/icons</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>@Processor</code> annotation indicates that this class is the processor (output) and defines the name of the component.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This constructor of the processor is responsible for injecting the component configuration and services. Configuration parameters are annotated with <code>@Option</code>.<br>
The other parameters are considered as services and are injected by the component framework. Services can be local (class annotated with <code>@Service</code>) or provided by the component framework.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The method annotated with <code>@PostConstruct</code> is executed once by instance and can be used for initialization.
Here, the goal is to get the Hazelcast instance according to the provided configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The method annotated with <code>@PreDestroy</code> is used to clean resources at the end of the execution of the output.<br>
In the context of this tutorial, the Hazelcast instance loaded in the post Construct method is shut down.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Data is passed to the method annotated with <code>@ElementListener</code>. That method is responsible for handling the data output. You can define all the related logic in this method.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you need to bulk write the updates accordingly to groups, see <a href="concept-processor-and-batch-processing.html" class="page">Processors and batch processing</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each of the methods mentioned above now needs to be created.</p>
</div>
<div class="sect3">
<h4 id="_defining_the_constructor_method_2"><a class="anchor" href="#_defining_the_constructor_method_2"></a>Defining the constructor method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public HazelcastOutput(@Option("configuration") final HazelcastConfiguration configuration,
                       final JsonBuilderFactory jsonFactory,
                       final Jsonb jsonb,
                       final HazelcastService service) {
    this.configuration = configuration;
    this.jsonFactory = jsonFactory;
    this.jsonb = jsonb;
    this.service = service;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_postconstruct_method"><a class="anchor" href="#_defining_the_postconstruct_method"></a>Defining the PostConstruct method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private transient HazelcastInstance instance;
private transient IMap&lt;Object, Object&gt; map;

@PostConstruct
public void init() {
    instance = service.findInstance(configuration.newConfig()); <i class="conum" data-value="1"></i><b>(1)</b>
    map = instance.getMap(configuration.getMapName()); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make it work, a Hazelcast instance and a Hazelcast map are required. The corresponding attributes need to be added to the output.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create an instance of Hazelcast according to the provided configuration.
In this case, the injected HazelcastService instance is used. This service is implemented in the project. See the implementation in the <a href="tutorial-create-an-input-component.html#post-construct-method" class="page">Implementing an input component</a> tutorial.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get the Hazelcast map according to the map name provided in the configuration, using the Hazelcast instance.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In production, avoid creating one instance per thread/worker.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_predestroy_method_2"><a class="anchor" href="#_defining_the_predestroy_method_2"></a>Defining the PreDestroy method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PreDestroy
public void close() {
    instance.getLifecycleService().shutdown();
    map = null;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Shut down the Hazelcast client instance created by the method annotated with <code>@PostConstruct</code> and thus free the Hazelcast map reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_elementlistener_method"><a class="anchor" href="#_defining_the_elementlistener_method"></a>Defining the ElementListener method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public void onElement(final JsonObject defaultInput) { <i class="conum" data-value="1"></i><b>(1)</b>
    final Object key = toValue(defaultInput.get(configuration.getKeyAttribute()));
    final Object value = toValue(defaultInput.get(configuration.getValueAttribute()));
    map.put(key, value);
}

private Object toValue(final JsonValue jsonValue) { <i class="conum" data-value="2"></i><b>(2)</b>
    if (jsonValue == null) {
        return null;
    }
    if (jsonValue.getValueType() == STRING) {
        return JsonString.class.cast(jsonValue).getString();
    }
    if (jsonValue.getValueType() == NUMBER) {
        return JsonNumber.class.cast(jsonValue).doubleValue();
    }
    return jsonValue.asJsonObject();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This method is used to pass the incoming data to the output. Every object passed should be a JsonObject instance. This method can include any logic required to write data to the data source.<br>
In this tutorial, the data is passed to the Hazelcast map.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is the inner method used to transform incoming values into the format required to pass data to the Hazelcast map.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_full_implementation_of_the_output"><a class="anchor" href="#_full_implementation_of_the_output"></a>Full implementation of the Output</h4>
<div class="paragraph">
<p>Once implemented, the Output configuration is as follows. For more information about outputs, refer to <a href="component-define-processor-output.html" class="page">this document</a>.</p>
</div>
<div class="listingblock initial-block-closed">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version <i class="conum" data-value="1"></i><b>(1)</b>
@Icon(custom = "hazelcastOutput", value = CUSTOM) <i class="conum" data-value="2"></i><b>(2)</b>
@Processor(name = "Output") <i class="conum" data-value="3"></i><b>(3)</b>
public class HazelcastOutput implements Serializable {
    private final HazelcastConfiguration configuration;
    private final JsonBuilderFactory jsonFactory;
    private final Jsonb jsonb;
    private final HazelcastService service;

    private transient HazelcastInstance instance;
    private transient IMap&lt;Object, Object&gt; map;

    public HazelcastOutput(@Option("configuration") final HazelcastConfiguration configuration,
                           final JsonBuilderFactory jsonFactory,
                           final Jsonb jsonb,
                           final HazelcastService service) {
        this.configuration = configuration;
        this.jsonFactory = jsonFactory;
        this.jsonb = jsonb;
        this.service = service;
    }

    @PostConstruct
    public void init() {
        instance = service.findInstance(configuration.newConfig());
        map = instance.getMap(configuration.getMapName());
    }

    @ElementListener
    public void onElement(final JsonObject defaultInput) {
        final Object key = toValue(defaultInput.get(configuration.getKeyAttribute()));
        final Object value = toValue(defaultInput.get(configuration.getValueAttribute()));
        map.put(key, value);
    }

    @PreDestroy
    public void release() {
        instance.getLifecycleService().shutdown();
        map = null;
    }

    private Object toValue(final JsonValue jsonValue) {
        if (jsonValue == null) {
            return null;
        }
        if (jsonValue.getValueType() == STRING) {
            return JsonString.class.cast(jsonValue).getString();
        }
        if (jsonValue.getValueType() == NUMBER) {
            return JsonNumber.class.cast(jsonValue).doubleValue();
        }
        return jsonValue.asJsonObject();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You have now created a complete working output component. You can follow  <a href="tutorial-test-your-components.html" class="page">this tutorial</a> to learn how to create unit tests for your new component.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_components_for_a_rest_api"><a class="anchor" href="#_creating_components_for_a_rest_api"></a>Creating components for a REST API</h2>
<div class="sectionbody">
<div id="tutorial-create-components-rest-api" class="paragraph">
<p>This tutorial shows how to create components that consume a REST API.</p>
</div>
<div class="paragraph">
<p>The component developed as example in this tutorial is an input component that provides a search functionality for Zendesk using its <a href="https://developer.zendesk.com/rest_api/docs/core/search">Search API</a>.<br>
<a href="https://projectlombok.org/">Lombok</a> is used to avoid writing getter, setter and constructor methods.</p>
</div>
<div class="paragraph">
<p>You can generate a project using the Talend Components Kit starter, as described in
<a href="tutorial-generate-project-using-starter.html" class="page">this tutorial</a>.</p>
</div>
<div class="sect2">
<h3 id="_setting_up_the_http_client"><a class="anchor" href="#_setting_up_the_http_client"></a>Setting up the HTTP client</h3>
<div class="paragraph">
<p>The input component relies on Zendesk Search API and requires an HTTP client to consume it.</p>
</div>
<div class="paragraph">
<p>The Zendesk Search API takes the following parameters on the <code>/api/v2/search.json</code> endpoint.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>query</strong>     : The search query.</p>
</li>
<li>
<p><strong>sort_by</strong>   : The sorting type of the query result. Possible values are <code>updated_at</code>, <code>created_at</code>, <code>priority</code>, <code>status</code>, <code>ticket_type</code>, or <code>relevance</code>. It defaults to <code>relevance</code>.</p>
</li>
<li>
<p><strong>sort_order</strong>: The sorting order of the query result. Possible values are <code>asc</code> (for ascending) or <code>desc</code> (for descending). It defaults to <code>desc</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Talend Component Kit provides a built-in service to create an easy-to-use HTTP client in a declarative manner, using Java annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SearchClient extends HttpClient { <i class="conum" data-value="1"></i><b>(1)</b>

    @Request(path = "api/v2/search.json", method = "GET") <i class="conum" data-value="2"></i><b>(2)</b>
    Response&lt;JsonObject&gt; search(@Header("Authorization") String auth,<i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
            @Header("Content-Type") String contentType, <i class="conum" data-value="5"></i><b>(5)</b>
            @Query("query") String query, <i class="conum" data-value="6"></i><b>(6)</b>
            @Query("sort_by") String sortBy,
            @Query("sort_order") String sortOrder,
            @Query("page") Integer page
    );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The interface needs to extend <code>org.talend.sdk.component.api.service.http.HttpClient</code> to be recognized as an HTTP client by the component framework.
This interface also provides the <code>void base(String base)</code> method, that allows to set the base URI for the HTTP request. In this tutorial, it is the Zendesk instance URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@Request</code> annotation allows to define the HTTP request path and method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, and so on).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method return type and a header parameter are defined.<br>
The method return type is a JSON object: <code>Response&lt;JsonObject&gt;</code>. The <code>Response</code> object allows to access the HTTP response status code, headers, error payload and the response body that are of the <code>JsonObject</code> type in this case.<br>
The response body is decoded according to the content type returned by the API. The component framework provides the codec to decode JSON content.<br>
If you want to consume specific content types, you need to specify your custom codec using the <code>@Codec</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>Authorization</code> HTTP request header allows to provide the authorization token.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Another HTTP request header defined to provide the content type.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Query parameters are defined using the <code>@Query</code> annotation that provides the parameter name.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>No additional implementation is needed for the interface, as it is provided by the component framework, according to what is defined above.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This HTTP client can be injected into a mapper or a processor to perform HTTP requests.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_component"><a class="anchor" href="#_configuring_the_component"></a>Configuring the component</h3>
<div class="paragraph">
<p>This example uses the basic authentication that supported by the API.</p>
</div>
<div class="sect3">
<h4 id="_configuring_basic_authentication"><a class="anchor" href="#_configuring_basic_authentication"></a>Configuring basic authentication</h4>
<div class="paragraph">
<p>The first step is to set up the configuration for the basic authentication.
To be able to consume the Search API, the Zendesk instance URL, the username and the password are needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
@DataStore <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
        @GridLayout.Row({ "url" }),
        @GridLayout.Row({ "username", "password" })
})
@Documentation("Basic authentication for Zendesk API")
public class BasicAuth {

    @Option
    @Documentation("Zendesk instance url")
    private final String url;

    @Option
    @Documentation("Zendesk account username (e-mail).")
    private final String username;

    @Option
    @Credential <i class="conum" data-value="3"></i><b>(3)</b>
    @Documentation("Zendesk account password")
    private final String password;

    public String getAuthorizationHeader() { <i class="conum" data-value="4"></i><b>(4)</b>
        try {
            return "Basic " + Base64.getEncoder()
                    .encodeToString((this.getUsername() + ":" + this.getPassword()).getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This configuration class provides the authentication information. Type it as <code>Datastore</code> so that it can be validated using services (similar to connection test) and used by Talend Studio or web application metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@GridLayout</code> defines the UI layout of this configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The password is marked as <code>Credential</code> so that it is handled as sensitive data in Talend Studio and web applications. <a href="tutorial-configuration-sensitive-data.html" class="page">Read more about sensitive data handling</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This method generates a basic authentication token using the username and the password. This token is used to authenticate the HTTP call on the Search API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The data store is now configured. It provides a basic authentication token.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_the_dataset"><a class="anchor" href="#_configuring_the_dataset"></a>Configuring the dataset</h4>
<div class="paragraph">
<p>Once the data store is configured, you can define the dataset by configuring the search query. It is that query that defines the records processed by the input component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
@DataSet <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
        @GridLayout.Row({ "dataStore" }),
        @GridLayout.Row({ "query" }),
        @GridLayout.Row({ "sortBy", "sortOrder" })
})
@Documentation("Data set that defines a search query for Zendesk Search API. See API reference https://developer.zendesk.com/rest_api/docs/core/search")
public class SearchQuery {

    @Option
    @Documentation("Authentication information.")
    private final BasicAuth dataStore;

    @Option
    @TextArea <i class="conum" data-value="3"></i><b>(3)</b>
    @Documentation("Search query.") <i class="conum" data-value="4"></i><b>(4)</b>
    private final String query;

    @Option
    @DefaultValue("relevance") <i class="conum" data-value="5"></i><b>(5)</b>
    @Documentation("One of updated_at, created_at, priority, status, or ticket_type. Defaults to sorting by relevance")
    private final String sortBy;

    @Option
    @DefaultValue("desc")
    @Documentation("One of asc or desc. Defaults to desc")
    private final String sortOrder;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The configuration class is marked as a <code>DataSet</code>. <a href="component-configuration.html#dataset-and-datastore" class="page">Read more about configuration types</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@GridLayout</code> defines the UI layout of this configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A text area widget is bound to the <strong>Search query</strong> field. <a href="gallery.html" class="page">See all the available widgets</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>@Documentation</code> annotation is used to document the component (configuration in this scope).
A Talend Component Kit Maven plugin can be used to generate the component documentation with all the configuration description and the default values.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A default value is defined for sorting the query result.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your component is configured. You can now create the component logic.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_component_mapper"><a class="anchor" href="#_defining_the_component_mapper"></a>Defining the component mapper</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Mappers defined with this tutorial don&#8217;t implement the split part because HTTP calls are not split on many workers in this case.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version
@Icon(value = Icon.IconType.CUSTOM, custom = "zendesk")
@PartitionMapper(name = "search")
@Documentation("Search component for zendesk query")
public class SearchMapper implements Serializable {

    private final SearchQuery configuration; <i class="conum" data-value="1"></i><b>(1)</b>
    private final SearchClient searchClient; <i class="conum" data-value="2"></i><b>(2)</b>

    public SearchMapper(@Option("configuration") final SearchQuery configuration, final SearchClient searchClient) {
        this.configuration = configuration;
        this.searchClient = searchClient;
    }

    @PostConstruct
    public void init() {
        searchClient.base(configuration.getDataStore().getUrl()); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Assessor
    public long estimateSize() {
        return 1L;
    }

    @Split
    public List&lt;SearchMapper&gt; split(@PartitionSize final long bundles) {
        return Collections.singletonList(this); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Emitter
    public SearchSource createWorker() {
        return new SearchSource(configuration, searchClient); <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component configuration that is injected by the component framework</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The HTTP client created earlier in this tutorial. It is also injected by the framework via the mapper constructor.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The base URL of the HTTP client is defined using the configuration URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The mapper is returned in the split method because HTTP requests are not split.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A source is created to perform the HTTP request and return the search result.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_component_source"><a class="anchor" href="#_defining_the_component_source"></a>Defining the component source</h3>
<div class="paragraph">
<p>Once the component logic implemented, you can create the source in charge of performing the HTTP request to the search API and converting the result to <code>JsonObject</code> records.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchSource implements Serializable {

    private final SearchQuery config; <i class="conum" data-value="1"></i><b>(1)</b>
    private final SearchClient searchClient; <i class="conum" data-value="2"></i><b>(2)</b>
    private BufferizedProducerSupport&lt;JsonValue&gt; bufferedReader; <i class="conum" data-value="3"></i><b>(3)</b>

    private transient int page = 0;
    private transient int previousPage = -1;

    public SearchSource(final SearchQuery configuration, final SearchClient searchClient) {
        this.config = configuration;
        this.searchClient = searchClient;
    }

    @PostConstruct
    public void init() { <i class="conum" data-value="4"></i><b>(4)</b>
        bufferedReader = new BufferizedProducerSupport&lt;&gt;(() -&gt; {
            JsonObject result = null;
            if (previousPage == -1) {
                result = search(config.getDataStore().getAuthorizationHeader(),
                        config.getQuery(), config.getSortBy(),
                        config.getSortBy() == null ? null : config.getSortOrder(), null);
            } else if (previousPage != page) {
                result = search(config.getDataStore().getAuthorizationHeader(),
                        config.getQuery(), config.getSortBy(),
                        config.getSortBy() == null ? null : config.getSortOrder(), page);
            }
            if (result == null) {
                return null;
            }
            previousPage = page;
            String nextPage = result.getString("next_page", null);
            if (nextPage != null) {
                page++;
            }

            return result.getJsonArray("results").iterator();
        });
    }

    @Producer
    public JsonObject next() { <i class="conum" data-value="5"></i><b>(5)</b>
        final JsonValue next = bufferedReader.next();
        return next == null ? null : next.asJsonObject();
    }

    <i class="conum" data-value="6"></i><b>(6)</b>
    private JsonObject search(String auth, String query, String sortBy, String sortOrder, Integer page) {
        final Response&lt;JsonObject&gt; response = searchClient.search(auth, "application/json",
                query, sortBy, sortOrder, page);
        if (response.status() == 200 &amp;&amp; response.body().getInt("count") != 0) {
            return response.body();
        }

        final String mediaType = extractMediaType(response.headers());
        if (mediaType != null &amp;&amp; mediaType.contains("application/json")) {
            final JsonObject error = response.error(JsonObject.class);
            throw new RuntimeException(error.getString("error") + "\n" + error.getString("description"));
        }
        throw new RuntimeException(response.error(String.class));
    }

    <i class="conum" data-value="7"></i><b>(7)</b>
    private String extractMediaType(final Map&lt;String, List&lt;String&gt;&gt; headers) {
        final String contentType = headers == null || headers.isEmpty()
                || !headers.containsKey(HEADER_Content_Type) ? null :
                headers.get(HEADER_Content_Type).iterator().next();

        if (contentType == null || contentType.isEmpty()) {
            return null;
        }
        // content-type contains charset and/or boundary
        return ((contentType.contains(";")) ? contentType.split(";")[0] : contentType).toLowerCase(ROOT);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component configuration injected from the component mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The HTTP client injected from the component mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A utility used to buffer search results and iterate on them one after another.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The record buffer is initialized with the <code>init</code> by providing the logic to iterate on the search result. The logic consists in getting the first result page and converting the result into JSON records. The buffer then retrieves the next result page, if needed, and so on.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>next</code> method returns the next record from the buffer. When there is no record left, the buffer returns <code>null</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>In this method, the HTTP client is used to perform the HTTP request to the search API.<br>
Depending on the HTTP response status code, the results are retrieved or an error is thrown.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The <code>extractMediaType</code> method allows to extract the media type returned by the API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You now have created a simple Talend component that consumes a REST API.</p>
</div>
<div class="paragraph">
<p>To learn how to test this component, refer to <a href="tutorial-test-rest-api.html" class="page">this tutorial</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_a_rest_api"><a class="anchor" href="#_testing_a_rest_api"></a>Testing a REST API</h2>
<div class="sectionbody">
<div id="tutorial-test-rest-api" class="paragraph">
<p>Testing code that consumes REST APIs can sometimes present many constraints: API rate limit, authentication token and password sharing, API availability, sandbox expiration, API costs, and so on.</p>
</div>
<div class="paragraph">
<p>As a developer, it becomes critical to avoid those constraints and to be able to easily mock the API response.</p>
</div>
<div class="paragraph">
<p>The component framework provides an API simulation tool that makes it easy to write unit tests.</p>
</div>
<div class="paragraph">
<p>This tutorial shows how to use this tool in unit tests.
As a starting point, the tutorial uses the component that consumes Zendesk Search API and that was created in <a href="tutorial-create-components-rest-api.html" class="page">a previous tutorial</a>. The goal is to add unit tests for it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For this tutorial, four <strong>tickets</strong> that have the <strong>open</strong> status have been added to the Zendesk test instance used in the tests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To learn more about the testing methodology used in this tutorial, refer to <a href="testing-junit.html#_junit_4" class="page">Component JUnit testing</a>.</p>
</div>
<div class="sect2">
<h3 id="_creating_the_unit_test"><a class="anchor" href="#_creating_the_unit_test"></a>Creating the unit test</h3>
<div class="paragraph">
<p>Create a unit test that performs a real HTTP request to the Zendesk Search API instance.
You can learn how to create a simple unit test in <a href="tutorial-test-your-components.html" class="page">this tutorial</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    @Test
    public void searchQuery() {
        // Initiating the component test configuration <i class="conum" data-value="1"></i><b>(1)</b>
        BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com", "username", "password");
        final SearchQuery searchQuery = new SearchQuery(basicAuth, "type:ticket status:open", "created_at", "desc");

        // We convert our configuration instance to URI configuration <i class="conum" data-value="2"></i><b>(2)</b>
        final String uriConfig = SimpleFactory.configurationByExample()
                        .forInstance(searchQuery)
                        .configured().toQueryString();

        // We create our job test pipeline <i class="conum" data-value="3"></i><b>(3)</b>
        Job.components()
                .component("search", "zendesk://search?" + uriConfig)
                .component("collector", "test://collector")
                .connections()
                .from("search").to("collector")
                .build()
                .run();

        final List&lt;JsonObject&gt; res = component.getCollectedData(JsonObject.class);
        assertEquals(4, res.size());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initiating:
<div class="ulist">
<ul>
<li>
<p>the authentication configuration using Zendesk instance URL and credentials.</p>
</li>
<li>
<p>the search query configuration to get all the open ticket, ordered by creation date and sorted in descending order.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Converting the configuration to a URI format that will be used in the job test pipeline,
using the <code>SimpleFactory</code> class provided by the component framework. <a href="services-pipeline.html#_job_builder" class="page">Read more about job pipeline</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating the job test pipeline. The pipeline executes the <code>search</code> component and redirects the result to the test <code>collector</code> component, that collects the search result.
The pipeline is then executed.
Finally, the job result is retrieved to check that the four tickets have been received. You can also check that the tickets have the <code>open</code> status.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The test is now complete and working. It performs a real HTTP request to the Zendesk instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transforming_the_unit_test_into_a_mocked_test"><a class="anchor" href="#_transforming_the_unit_test_into_a_mocked_test"></a>Transforming the unit test into a mocked test</h3>
<div class="paragraph">
<p>As an alternative, you can use mock results to avoid performing HTTP requests every time on the development environment. The real HTTP requests would, for example, only be performed on an integration environment.</p>
</div>
<div class="paragraph">
<p>To transform the unit test into a mocked test that uses a mocked response of the Zendesk Search API:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the two following JUnit rules provided by the component framework.</p>
<div class="ulist">
<ul>
<li>
<p><code>JUnit4HttpApi</code>: This rule starts a simulation server that acts as a proxy and catches all the HTTP requests performed in the tests.
This simulation server has two modes :</p>
<div class="ulist">
<ul>
<li>
<p><strong>capture</strong>    : This mode forwards the captured HTTP request to the real server and captures the response.</p>
</li>
<li>
<p><strong>simulation</strong> : this mode returns a mocked response from the responses already captured. This rule needs to be added as a class rule.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>JUnit4HttpApi</code>: This rule has a reference to the first rule. Its role is to configure the simulation server for every unit test. It passes the context of the running test to the simulation server. This rule needs to be added as a simple (method) rule.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Example to run in a simulation mode</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    private final MavenDecrypter mavenDecrypter = new MavenDecrypter();

    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi() <i class="conum" data-value="1"></i><b>(1)</b>
                                                        .activeSsl(); <i class="conum" data-value="2"></i><b>(2)</b>

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API); <i class="conum" data-value="3"></i><b>(3)</b>

    @Test
    public void searchQuery() {
        // the exact same code as above
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creating and starting a simulation server for this test class.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Activating SSL on the simulation server by calling the <code>activeSsl()</code> method. This step is required because the consumed API uses SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding the simulation server configuration provider that provides the test context to the simulation server.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Make the test run in <strong>capture</strong> mode to catch the real API responses that can be used later in the simulated mode.<br>
To do that, set a new <code>talend.junit.http.capture</code> environment variable to <code>true</code>.
This tells the simulation server to run in a capture mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The captured response is saved in the <code>resources/talend.testing.http</code> package in a JSON format, then reused to perform the API simulation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_a_component"><a class="anchor" href="#_testing_a_component"></a>Testing a component</h2>
<div class="sectionbody">
<div id="tutorial-test-your-components" class="paragraph">
<p>This tutorial focuses on writing unit tests for the input component that was created in this <a href="tutorial-create-an-input-component.html" class="page">previous tutorial</a>.</p>
</div>
<div class="paragraph">
<p>This tutorial covers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>How to load components in a unit test.</p>
</li>
<li>
<p>How to create a job pipeline.</p>
</li>
<li>
<p>How to run the test in standalone mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The test class is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HazelcastMapperTest {

    @ClassRule
    public static final SimpleComponentRule COMPONENTS = new SimpleComponentRule(HazelcastMapperTest.class
                                                                                    .getPackage().getName()); <i class="conum" data-value="1"></i><b>(1)</b>

    private static HazelcastInstance instance; <i class="conum" data-value="2"></i><b>(2)</b>

    @BeforeClass
    public static void startInstanceWithData() { <i class="conum" data-value="3"></i><b>(3)</b>
        instance = Hazelcast.newHazelcastInstance();
        final IMap&lt;Object, Object&gt; map = instance.getMap(HazelcastMapperTest.class.getSimpleName());
        IntStream.range(0, 100).forEach(i -&gt; map.put("test_" + i, "value #" + i));
    }

    @AfterClass
    public static void stopInstance() { <i class="conum" data-value="4"></i><b>(4)</b>
        instance.getLifecycleService().shutdown();
    }

    @Test
    public void run() { <i class="conum" data-value="5"></i><b>(5)</b>
        Job.components() <i class="conum" data-value="6"></i><b>(6)</b>
                .component("source", "Hazelcast://Input?configuration.mapName=" + HazelcastMapperTest.class.getSimpleName())
                .component("output", "test://collector")
            .connections()
                .from("source").to("output")
            .build()
            .run();

        final List&lt;JsonObject&gt; outputs = COMPONENTS.getCollectedData(JsonObject.class); <i class="conum" data-value="7"></i><b>(7)</b>
        assertEquals(100, outputs.size());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SimpleComponentRule</code> is a JUnit rule that lets you load your component from a package. This rule also provides some test components like <code>emitter</code> and <code>collector</code>. Learn more about JUnit in <a href="testing-junit.html#_component_runtime_junit" class="page">this section</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using an embedded Hazelcast instance to test the input component.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating an embedded Hazelcast instance and filling it with some test data. A map with the name of the test class is created and data is added to it.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Cleaning up the instance after the end of the tests.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Defining the unit test. It first creates a job pipeline that uses our input component.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <a href="services-pipeline.html" class="page">pipeline builder</a> <code>Job</code> is used to create a job. It contains two components: the input component and the test collector component. The input component is connected to the collector component. Then the job is built and ran locally.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>After the job has finished running. The <code>COMPONENTS</code> rule instance is used to get the collected data from the <code>collector</code> component.
Once this is done, it is possible to do some assertion on the collected data.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_in_a_continuous_integration_environment"><a class="anchor" href="#_testing_in_a_continuous_integration_environment"></a>Testing in a Continuous Integration environment</h2>
<div class="sectionbody">
<div id="tutorial-dev-vs-ci-setup.adoc" class="paragraph">
<p>This tutorial shows how to adapt the test configuration of the Zendesk search component that was done in <a href="tutorial-test-rest-api.html" class="page">this previous tutorial</a> to make it work in a Continuous Integration environment.</p>
</div>
<div class="paragraph">
<p>In the test, the Zendesk credentials are used directly in the code to perform a first capture of the API response. Then, fake credentials are used in the simulation mode because the real API is not called anymore.</p>
</div>
<div class="paragraph">
<p>However, in some cases, you can require to continue calling the real API on a CI server or on a specific environment.</p>
</div>
<div class="paragraph">
<p>To do that, you can adapt the test to get the credentials depending on the execution mode (simulation/passthrough).</p>
</div>
<div class="sect2">
<h3 id="_setting_up_credentials"><a class="anchor" href="#_setting_up_credentials"></a>Setting up credentials</h3>
<div class="paragraph">
<p>These instructions concern the CI server or on any environment that requires real credentials.</p>
</div>
<div class="paragraph">
<p>This tutorial uses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="https://maven.apache.org/guides/mini/guide-encryption.html">Maven server</a> that supports password encryption as a credential provider. Encryption is optional but recommended.</p>
</li>
<li>
<p>The <code>MavenDecrypterRule</code> test rule provided by the framework. This rule lets you get credentials from Maven settings using a server ID.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To create encrypted server credentials for the Zendesk instance:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a master password using the command: <code>mvn --encrypt-master-password &lt;password&gt;</code>.</p>
</li>
<li>
<p>Store this master password in the <code>settings-security.xml</code> file of the <code>~/.m2</code> folder.</p>
</li>
<li>
<p>Encrypt the Zendesk instance password using the command: <code>mvn --encrypt-password &lt;zendesk-password&gt;</code>.</p>
</li>
<li>
<p>Create a server entry under <strong>servers</strong> in Maven <code>settings.xml</code> file located in the <code>~/.m2</code> folder.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;server&gt;
  &lt;id&gt;zendesk&lt;/id&gt;
  &lt;username&gt;username@email.com&lt;/username&gt;
  &lt;password&gt;The encrypted password {oL37x/xiSvwtlhrMQ=}&lt;/password&gt;
&lt;/server&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can store the <code>settings-security.xml</code> and <code>settings.xml</code> files elsewhere that the default location (<code>~/.m2</code>). To do that, set the path of the directory containing the files
in the <code>talend.maven.decrypter.m2.location</code> environment variable.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_adapting_the_unit_test"><a class="anchor" href="#_adapting_the_unit_test"></a>Adapting the unit test</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the <code>MavenDecrypterRule</code> rule to the test class. This rule allows to inject server information stored in Maven <code>settings.xml</code> file to the test. The rule also decrypts credentials if they are encrypted.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Inject the Zendesk server to the test. To do that, add a new field to the class with the <code>@DecryptedServer</code> annotation, that holds the server ID to be injected.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);

    @DecryptedServer("zendesk")
    private Server server;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MavenDecrypterRule</code> is able to inject the server instance into this class at runtime. The server instance contains the username and the decrypted password.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Use the <code>server</code> instance in the test to get the real credentials in a secured manner.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com",
                            server.getUsername(),
                            server.getPassword());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once modified, the complete test class looks as follows:</p>
</div>
<div class="listingblock initial-block-closed">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    private final MavenDecrypter mavenDecrypter = new MavenDecrypter();

    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi()
                                                        .activeSsl();

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);

    @DecryptedServer("zendesk")
    private Server server;

    @Test
    public void searchQuery() {
        // Initiating the component test configuration
        BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com", server.getUsername(), server.getPassword());
        final SearchQuery searchQuery = new SearchQuery(basicAuth, "type:ticket status:open", "created_at", "desc");

        // We convert our configuration instance to URI configuration
        final String uriConfig = SimpleFactory.configurationByExample()
                        .forInstance(searchQuery)
                        .configured().toQueryString();

        // We create our job test pipeline
        Job.components()
                .component("search", "zendesk://search?" + uriConfig)
                .component("collector", "test://collector")
                .connections()
                .from("search").to("collector")
                .build()
                .run();

        final List&lt;JsonObject&gt; res = component.getCollectedData(JsonObject.class);
        assertEquals(4, res.size());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>This test will continue to work in simulation mode</strong>, because the API simulation proxy is activated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up_the_ci_server_in_passthrough_mode"><a class="anchor" href="#_setting_up_the_ci_server_in_passthrough_mode"></a>Setting up the CI server in passthrough mode</h3>
<div class="paragraph">
<p>This tutorial shows how to set up a CI server in passthrough mode using <a href="https://jenkins.io/">Jenkins</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Log in to Jenkins.</p>
</li>
<li>
<p>Click <strong>New Item</strong> to create a new build job.</p>
<div class="imageblock">
<div class="content">
<img src="_images/jenkins/1_jenkins_new_item.png" alt="Create a new job">
</div>
</div>
</li>
<li>
<p>Enter an Item name (Job name) and choose the freestyle job. Then click OK.</p>
<div class="imageblock">
<div class="content">
<img src="_images/jenkins/2_jenkins_new_item.png" alt="Create a new job">
</div>
</div>
</li>
<li>
<p>In the <strong>Source Code Management</strong> section, enter your project repository URL. A GitHub repository is used in this tutorial.</p>
</li>
<li>
<p>Specify the <code>master</code> branch as <strong>Branches to build</strong>.</p>
<div class="imageblock">
<div class="content">
<img src="_images/jenkins/4_jenkins_source_code.png" alt="Source Code Management">
</div>
</div>
</li>
<li>
<p>In the <strong>Build</strong> section, click <strong>Add build step</strong> and choose <strong>Invoke top-level Maven targets</strong>.</p>
<div class="imageblock">
<div class="content">
<img src="_images/jenkins/6_jenkins_build_cmd.png" alt="Build Section">
</div>
</div>
</li>
<li>
<p>Choose your Maven version and enter the Maven build command. In this case: <code>clean install</code>. Then, click <strong>Save</strong>.</p>
<div class="imageblock">
<div class="content">
<img src="_images/jenkins/6_jenkins_build_cmd_2.png" alt="Build Section">
</div>
</div>
<div class="paragraph">
<p>The <code>-Dtalend.junit.http.passthrough=true</code> option is part of the build command.
This option tells the API simulation proxy to run in <code>passthrough</code> mode. This way, all the HTTP requests made in the test are forwarded to the real API server.</p>
</div>
<div class="paragraph">
<p>The <code>MavenDecrypterRule</code> rule allows to get the real credentials.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can configure the <strong>passthrough</strong> mode globally on your CI server by setting the <code>talend.junit.http.passthrough</code> environment variable to <code>true</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Test the job by selecting <strong>Build now</strong>, and check that the job has built correctly.</p>
<div class="imageblock">
<div class="content">
<img src="_images/jenkins/7_jenkins_build_result.png" alt="Test the job">
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now your tests run in a simulation mode on your development environment and in a passthrough mode on your CI server.</p>
</div>
</div>
</div>
</div>
            </div>
          </div>
          <div class="col-sm-3 container article-side-panel">
            <nav class="article-anchors">
              <div class="article-side-actions">

                <ul>
                    <li>
                      <a class="article-side-actions-link" target="_blank" href="https://github.com/Talend/component-runtime/edit/master/documentation/src/main/antora/modules/ROOT/pages/index-pdf-tutorials.adoc">
                        <i class="fa fa-edit"></i> &nbsp; &nbsp; Suggest an edit
                      </a>
                    </li>

                    <li>
                                <a class="article-side-actions-link" target="_blank"
                                   href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2F1.0.5%2Findex-pdf-tutorials.html&text=Talend%20Component%20Kit%20%3E%3E%20Tutorials%20%3E%3E%20&tw_p=tweetbutton&url=https%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2F1.0.5%2Findex-pdf-tutorials.html">
                                    <i class="fab fa-twitter"></i> &nbsp; &nbsp; Tweet
                                </a>
                            </li>
                            <li>
                                <a class="article-side-actions-link"
                                   href="mailto:?subject=Talend%20Component%20Kit%3A%20Tutorials&body=Talend%20Component%20Kit%3A%20Tutorials%0A%0Ahttps%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2F1.0.5%2Findex-pdf-tutorials.html">
                                    <i class="far fa-envelope"></i> &nbsp; &nbsp; Mail
                                </a>
                            </li>

                </ul>
              </div>
              <h1 class="article-side-toc">In this article</h1>
            </nav>
          </div>
          <a href="#top" class="top">Scroll to top</a>
        </div>
        <script>(window.talend = (window.talend || {})).article = true;</script>
    </article>
              </div>
            </main>
      </main>
      <footer class="footer ">
    <div class="footer-with-copyright footer-with-links">
        <ul class="footer-links pull-left">
            <li><a class="gwt-Anchor" href="http://www.talend.com/">Talend</a></li>
            <li><a class="gwt-Anchor" href="http://www.talend.com/contact">Contact</a></li>
            <li><a class="gwt-Anchor" href="http://www.talend.com/legal-terms/us-eula">Talend EULA</a></li>
        </ul>
        <div class="footer-copyright pull-right" style="">&copy; 2018 Talend Inc. All rights reserved.</div>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/rmannibucau/00206484a54ac569e091513e6d2a1c01/raw/46cd5d77ba1abe678f83d11490e12a327b62d7ee/anchorific.js"></script>
<script src="../../_/js/talend.js"></script>
  </body>
</html>
