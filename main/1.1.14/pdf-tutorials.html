<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talend Component Kit Developer Reference Guide :: Tutorials</title>
    <link rel="canonical" href="https://talend.github.io/component-runtime/main/latest/pdf-tutorials.html">
    <meta name="generator" content="Talend Component Kit Generator">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Tutorials :: Talend Component Kit Developer Reference Guide</title>
    <link rel="canonical" href="https://talend.github.io/component-runtime/main/latest/pdf-tutorials.html">
    <meta name="generator" content="Antora 3.0.1">
<meta name="date" content="2025-05-27T00:54:39.329Z" scheme="YYYY-MM-DDTHH:mm:ss.sssZ">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" integrity="sha256-NuCn4IvuZXdBaFKJOAcsU2Q3ZpwbdFisd5dux4jkQ5w=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css" integrity="sha256-rD61BPsgKHzJPyg7vpXaYOw6tMYuY2fz1p9033NYeM8=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@talend/bootstrap-theme@0.200.1/dist/bootstrap.css">
<link rel="stylesheet" href="../../_/css/talend.css">
<link rel="shortcut icon" href="../../_/images/favicon_0.ico" />


<script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                  messageStyle: "none",
                  tex2jax: {
                    inlineMath: [["\\(", "\\)"]],
                    displayMath: [["\\[", "\\]"]],
                    ignoreClass: "nostem|nolatexmath"
                  },
                  asciimath2jax: {
                    delimiters: [["\\$", "\\$"]],
                    ignoreClass: "nostem|noasciimath"
                  },
                  TeX: { equationNumbers: { autoNumber: "none" } }
                });
                </script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PSBN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-PSBN')</script>
  </head>
  <body>
      <svg xmlns="http://www.w3.org/2000/svg" focusable="false" style="display: none;">
    <symbol id="talend-logo-square">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
            <path fill="#FFF" d="M8,5.32907052e-14 C12.4182648,5.32907052e-14 16,3.58173516 16,8 C16,12.4188737 12.4182648,16.0006088 8,16.0006088 C3.58173516,16.0006088 0,12.4188737 0,8 C0,3.58173516 3.58173516,5.32907052e-14 8,5.32907052e-14 Z M7.86070588,3.63987227 C7.41418487,4.67207395 6.53747899,5.46891429 5.4532437,5.80834286 C5.4532437,5.80834286 5.23179832,5.86098151 5.28867227,6.09271261 C5.29532773,6.11267899 5.30137815,6.13264538 5.31105882,6.15261176 C5.34191597,6.21735126 5.37942857,6.25062857 5.42359664,6.25607395 L6.13391597,6.25607395 L6.13391597,10.6517042 C6.13391597,11.2755025 6.32329412,11.7117378 6.70205042,11.959805 C7.08020168,12.2072672 7.58843697,12.3306958 8.22554622,12.3306958 C8.42521008,12.3306958 8.65633613,12.2937882 8.91952941,12.218763 C9.18272269,12.1431328 9.43078992,12.0469311 9.66312605,11.9295529 C9.89606723,11.8127798 10.0672941,11.6941916 10.1780168,11.5737882 C10.2046387,11.5568471 10.2046387,11.5090487 10.1780168,11.4316034 C10.151395,11.354158 10.1138824,11.282158 10.0648739,11.2162084 C10.0164706,11.1496538 9.97895798,11.1230319 9.95233613,11.1363429 C9.78413445,11.2198387 9.60020168,11.2912336 9.40114286,11.3487126 C9.20208403,11.4061916 9.02904202,11.4352336 8.88322689,11.4352336 C8.7192605,11.4352336 8.59401681,11.397721 8.50810084,11.325721 C8.42157983,11.2525109 8.35986555,11.1169815 8.32235294,10.9203429 C8.28423529,10.7237042 8.26547899,10.4363092 8.26547899,10.0599731 L8.26547899,6.24276303 L9.69337815,6.24276303 C9.74178151,6.24276303 9.78715966,6.19617479 9.82951261,6.10239328 C9.8712605,6.01042689 9.89243697,5.89546891 9.89243697,5.75812437 C9.89243697,5.70004034 9.87791597,5.64861176 9.84887395,5.60504874 C9.82043697,5.56088067 9.78171429,5.53667899 9.73331092,5.5324437 L8.26547899,5.5324437 L8.26547899,3.6792 C8.26547899,3.60235966 8.21465546,3.54790588 8.1245042,3.51099832 C7.95811765,3.45896471 7.86070588,3.63987227 7.86070588,3.63987227 Z"</path>
        </svg>
    </symbol>
    <symbol id="talend-component-kit-positive">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
            <g fill="none">
                <path fill="#005695" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path>
                <path fill="#FFF" d="M5.69 10.662a2.3 2.3 0 0 0 1.425.492 2.3 2.3 0 0 0 1.664-.709l-.631-.632 1.005-1.005a.33.33 0 0 0 0-.466.332.332 0 0 0-.467 0L7.68 9.347 6.633 8.3l1.005-1.005a.33.33 0 0 0-.467-.466L6.167 7.832l-.653-.652a2.3 2.3 0 0 0-.71 1.664c0 .54.187 1.037.498 1.43L3.878 11.7a.721.721 0 0 0-.358.027 5.824 5.824 0 0 1-.722-6.368c1.364-2.7 4.612-3.914 7.41-2.777l-.348.69 1.584-.369-.643-1.495-.351.695C7.384.832 3.818 2.15 2.32 5.117a6.359 6.359 0 0 0 .798 6.962.704.704 0 0 0 1.26.631.704.704 0 0 0-.036-.699l1.349-1.349z"></path>
                <path fill="#FFF" d="M12.623 3.031a.706.706 0 0 0-.973.894l-1.296 1.298a2.304 2.304 0 0 0-3.092.215l3.266 3.265a2.304 2.304 0 0 0 .213-3.092l1.299-1.297a.701.701 0 0 0 .504.006 5.838 5.838 0 0 1 .675 6.311c-1.332 2.636-4.524 3.871-7.284 2.826l.339-.67-1.585.368.643 1.494.36-.712c3.028 1.18 6.538-.162 8.005-3.064a6.375 6.375 0 0 0-.758-6.912.703.703 0 0 0-.316-.93z"></path>
            </g>
        </svg>
    </symbol>
</svg>

<header class="global-header">
  <nav class="navbar navbar-default">
      <div class="navbar-text-content nav navbar-nav">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <button aria-label="Go to Portal" id="header-talend-logo" type="button" class="btn-icon-only btn btn-link">
            <svg name="talend-logo-square" focusable="false" aria-hidden="true">
                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#talend-logo-square"></use>
            </svg>
        </button>
        <button aria-label="Kit logo" id="header-kit-logo" type="button" class="btn-icon-only btn btn-link">
          <svg name="talend-component-kit-positive" focusable="false" aria-hidden="true">
            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#talend-component-kit-positive"></use>
          </svg>
        </button>
        <a class="navbar-single-link" href="https://talend.github.io/component-runtime/main/latest/index.html">Talend Component Kit</a>
        <div class="btn-group navbar-versions">
          <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                1.1.14
              <span class="caret"></span>
          </button>
          <ul class="dropdown-menu">
                <li class="navbar-item version">
                    <a href="../latest/index.html">1.82.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.81.0/index.html">1.81.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.80.1/index.html">1.80.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.80.0/index.html">1.80.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.79.0/index.html">1.79.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.78.1/index.html">1.78.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.78.0/index.html">1.78.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.67.0/index.html">1.67.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.66.0/index.html">1.66.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.65.0/index.html">1.65.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.8/index.html">1.64.8</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.7/index.html">1.64.7</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.6/index.html">1.64.6</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.5/index.html">1.64.5</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.4/index.html">1.64.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.3/index.html">1.64.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.2/index.html">1.64.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.1/index.html">1.64.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.64.0/index.html">1.64.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.63.0/index.html">1.63.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.62.1/index.html">1.62.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.62.0/index.html">1.62.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.61.2/index.html">1.61.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.61.1/index.html">1.61.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.61.0/index.html">1.61.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.60.0/index.html">1.60.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.59.0/index.html">1.59.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.58.0/index.html">1.58.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.57.2/index.html">1.57.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.57.1/index.html">1.57.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.57.0/index.html">1.57.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.56.3/index.html">1.56.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.56.2/index.html">1.56.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.56.1/index.html">1.56.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.56.0/index.html">1.56.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.55.2/index.html">1.55.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.55.1/index.html">1.55.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.55.0/index.html">1.55.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.54.1/index.html">1.54.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.53.1/index.html">1.53.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.51.4/index.html">1.51.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.51.3/index.html">1.51.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.51.2/index.html">1.51.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.50.4/index.html">1.50.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.49.1/index.html">1.49.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.48.1/index.html">1.48.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.47.1/index.html">1.47.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.46.1/index.html">1.46.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.45.2/index.html">1.45.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.44.3/index.html">1.44.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.43.1/index.html">1.43.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.42.0/index.html">1.42.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.41.1/index.html">1.41.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.40.0/index.html">1.40.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.39.3/index.html">1.39.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.16/index.html">1.38.16</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.15/index.html">1.38.15</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.14/index.html">1.38.14</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.13/index.html">1.38.13</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.12/index.html">1.38.12</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.11/index.html">1.38.11</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.10/index.html">1.38.10</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.38.9/index.html">1.38.9</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.37.1/index.html">1.37.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.36.1/index.html">1.36.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.35.1/index.html">1.35.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.34.1/index.html">1.34.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.33.2/index.html">1.33.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.32.2/index.html">1.32.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.31.2/index.html">1.31.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.30.0/index.html">1.30.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.29.2/index.html">1.29.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.28.2/index.html">1.28.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.27/index.html">1.1.27</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.26/index.html">1.1.26</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.25/index.html">1.1.25</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.24/index.html">1.1.24</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.23/index.html">1.1.23</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.22/index.html">1.1.22</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.21/index.html">1.1.21</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.20/index.html">1.1.20</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.19/index.html">1.1.19</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.18/index.html">1.1.18</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.17/index.html">1.1.17</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.16/index.html">1.1.16</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.15/index.html">1.1.15</a>
                </li>
                <li class="navbar-item version">
                    <a href="index.html">1.1.14</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.13/index.html">1.1.13</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.12/index.html">1.1.12</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.11/index.html">1.1.11</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.10/index.html">1.1.10</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.9/index.html">1.1.9</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.8/index.html">1.1.8</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.7/index.html">1.1.7</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.6/index.html">1.1.6</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.5/index.html">1.1.5</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.4/index.html">1.1.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.3/index.html">1.1.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.2/index.html">1.1.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.1/index.html">1.1.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.0/index.html">1.1.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.4/index.html">1.0.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.3/index.html">1.0.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.2/index.html">1.0.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.1/index.html">1.0.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.13/index.html">0.0.13</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.12/index.html">0.0.12</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.11/index.html">0.0.11</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.10/index.html">0.0.10</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.9/index.html">0.0.9</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.8/index.html">0.0.8</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.7/index.html">0.0.7</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.6/index.html">0.0.6</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.5/index.html">0.0.5</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.4/index.html">0.0.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.3/index.html">0.0.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.2/index.html">0.0.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../0.0.1/index.html">0.0.1</a>
                </li>
          </ul>
        </div>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul class="nav navbar-nav navbar-right">
          <li><a href="changelog.html" class="navbar-single-link">CHANGELOG</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Community<span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a class="navbar-item" href="https://github.com/talend/component-runtime" target="_blank">GitHub Repository</a></li>
              <li><a class="navbar-item" href="contributors.html">Contributors</a></li>
              <li><a class="navbar-item" href="https://community.talend.com/t5/Component-Development/bd-p/ComponentDevelopment" target="_blank">Forum</a></li>
              <li><a class="navbar-item" href="https://help.talend.com/" target="_blank">Talend Help Center</a></li>
            </ul>
          </li>
        </ul>
        <form role="search" action="search.html" class="navbar-form navbar-right">
          <div class="input-group">
            <span class="input-group-addon"><i class="fa fa-search"></i></span>
            <input class="form-control" type="text" placeholder="Search" name="query" id="searchInput">
          </div>
        </form>
      </div>
    </nav>
</header>
            <main class="main">
              <div class="navigation-container grey-background hidden-xs col-sm-2" data-component="main" data-version="1.1.14">
  <aside class="navigation" role="navigation">
    <div class="panels">
      <div class="input-group nav-filter-group">
        <span class="input-group-addon"><i class="fa fa-search"></i></span>
        <input class="form-control" type="text" placeholder="Filter menu entries..." id="navFilterInput">
      </div>
      <div class="navigation-menu is-active" data-panel="menu">
        <nav class="nav-menu">
          <!-- <label>Talend Component Kit Developer Reference Guide</label> -->
          <ul class="nav nav-list tree" >
  <li data-depth="0">
      
    <ul class="nav nav-list tree" >
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>First steps</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="getting-started.html">Getting Started</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-my-first-component.html">Creating your first component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="record-types.html">Record types</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Tutorials</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-tutorials.html">Tutorial overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-my-first-component.html">Creating your first component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-generate-project-using-starter.html">Generating a project from the starter</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-an-input-component.html">Creating a Hazelcast input component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-an-output-component.html">Creating a Hazelcast output component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-components-rest-api.html">Creating a Zendesk REST API connector</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-test-rest-api.html">Testing a Zendesk REST API connector</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-test-your-components.html">Testing a Hazelcast component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-dev-vs-ci-setup.html">Testing in a continuous integration environment</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-handle-talend-component-migration.html">Handling component version migration</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Setting up your environment</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-setup-environment.html">Setup overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="#system-prerequisites.adoc.adoc">System requirements</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="installing-talend-intellij-plugin.html">Installing the IntelliJ plugin</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Generating a project</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-generating-project.html">Project generation overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-generate-project-using-starter.html">Using the Starter</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="generate-project-using-intellij-plugin.html">Using the IntelliJ plugin</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Implementing components</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-creating-components.html">Component implementation overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-registering.html">Defining component metadata</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="creating-dataset-datastore.html">Defining datasets and datastores</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-define-input.html">Defining an input component logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-define-processor-output.html">Defining a processor/output logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-configuration.html">Defining component configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-execution.html">Component execution logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-internationalization.html">Internationalizing a component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-versions-and-migration.html">Managing component versions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-configuration-sensitive-data.html">Masking sensitive data</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="concept-processor-and-batch-processing.html">Implementing batch processing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-implementing-streaming.html">Implementing streaming on a component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-loading.html">Component loading</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="build-tools-maven.html">Building components with Maven</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="build-tools-gradle.html">Building components with Gradle</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="wrapping-a-beam-io.html">Wrapping a Beam I/O</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Defining services</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-defining-services.html">Service overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-internationalization.html">Internationalizing a service</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-actions.html">Providing actions through a service</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-built-in.html">Built-in services</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-interceptors.html">Services and interceptors</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-custom-api.html">Defining a custom API</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Testing components</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-testing-components.html">Component testing overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-best-practices.html">Component testing best practices</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="index-sub-testing-runtime.html">Testing component runtime</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-beam.html">Beam testing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-multiple-envs.html">Testing in multiple environments</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-maven-passwords.html">Reusing Maven credentials</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-generating-data.html">Generating data for testing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-pipeline.html">Simple/Test Pipeline API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="https://beam.apache.org/documentation/programming-guide/#creating-a-pipeline">Beam Pipeline API</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Integrating into Talend Studio</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-deploying-components.html">Studio integration overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="studio.html">Iterating on component development</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="studio-from-car.html">Installing components from a CAR file</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="compatibility.html">Version compatibility</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="javajet-to-componentkit.html">From Javajet to the Component Kit</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Integrating into Talend Cloud</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-cloud-integration.html">Cloud integration overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="documentation-rest.html">Component server and HTTP API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="vault-proxy.html">Component Server Vault Proxy</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Knowledge base</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-knowledge-base.html">Knowledge base articles</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="changelog.html">Changelog</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Reference Guide</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="gallery.html">Widget and validation gallery</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-actions.html">List of available actions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-conditions.html">List of conditions for binding properties</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-configuration-types.html">Component data configuration types</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-constraints.html">Component field constraints and validations</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-junit-environments.html">Provided JUnit testing environments</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-rest-resources.html">Component Server HTTP API reference</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-scanning-exclusions.html">Scanning exclusions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-server-configuration.html">Server configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-ui.html">UI API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="apidocs.html">Javadocs</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
        </nav>
      </div>
    </div>
  </aside>
</div>
              <div class="col-xs-12 col-sm-10 maincontent">
                <div class="toolbar" role="navigation">

    <ol class="breadcrumb">
      <li class="crumb active"><a href="pdf-tutorials.html">Tutorials</a></li>
    </ol>
</div>
                <article class="doc">
        <div class="row">
          <div class="col-sm-9 row">
              <h1>Tutorials</h1>
            <div class="article-content">
              <div class="sect1">
<h2 id="_creating_your_first_component"><a class="anchor" href="#_creating_your_first_component"></a>Creating your first component</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial walks you through all the required steps to get started with <strong>Talend Component Kit</strong>, from the creation of a simple component to its integration into <strong>Talend Open Studio</strong>.</p>
</div>
<div class="paragraph">
<p>The component created in this tutorial is a simple processor component that receives data from the previous component and displays it in the logs, along with an extra information entered by a user.</p>
</div>
<div class="paragraph">
<p>Once the prerequisites completed, this tutorial should take you about 20 minutes.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The component designed in this tutorial is a processor and does not require nor show any <a href="component-configuration.html#dataset-and-datastore" class="xref page">datastore and dataset</a> configuration. Datasets and datastores are required only for input and output components.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
<div class="sect2">
<h3 id="_prerequisites"><a class="anchor" href="#_prerequisites"></a>Prerequisites</h3>
<div class="paragraph">
<p>This tutorial aims at helping you to create your very first component. But before, get your development environment ready:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Download and install a Java JDK 1.8 or greater.</p>
</li>
<li>
<p>Download and install Talend Open Studio. For example, from <a href="https://sourceforge.net/projects/talend-studio">Sourceforge</a>.</p>
</li>
<li>
<p>Download and install <a href="https://www.jetbrains.com/idea/download">IntelliJ</a>.</p>
</li>
<li>
<p>Download the Talend Component Kit plugin for IntelliJ. The detailed installation steps for the plugin are available in <a href="installing-talend-intellij-plugin.html" class="xref page">this document</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_generating_a_simple_component_project"><a class="anchor" href="#_generating_a_simple_component_project"></a>Generating a simple component project</h3>
<div class="paragraph">
<p>The first step in this tutorial is to generate a project containing a simple output component using the <strong>Starter</strong> included in the Talend Component Kit plugin for IntelliJ.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start IntelliJ and create a new project. In the available options, you should see <strong>Talend Component</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/intellij_new_component_project.png" target="_blank" rel="noopener"><img src="_images/intellij_new_component_project.png" alt="New project"></a>
</div>
</div>
</li>
<li>
<p>Make sure that a <strong>Project SDK</strong> is selected. Then, select <strong>Talend Component</strong> and click <strong>Next</strong>.<br>
The <strong>Talend Component Kit Starter</strong> opens.</p>
</li>
<li>
<p>Enter the project details. The goal here is to define the component and project metadata. Change the default values as follows:<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/intellij_tutorial_project_metadata.png" target="_blank" rel="noopener"><img src="_images/intellij_tutorial_project_metadata.png" alt="Project metadata"></a>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <strong>Component Family</strong> and the <strong>Category</strong> will be used later in Talend Open Studio to find the new component.</p>
</li>
<li>
<p>The project metadata are mostly used to identify the project structure. A common practice is to replace 'company' in the default value by a value of your own, like your domain name.<br></p>
</li>
</ul>
</div>
</li>
<li>
<p>Once the metadata is filled, select <strong>Add a component</strong>. A new screen is displayed in the <strong>Talend Component Kit Starter</strong> that lets you define the generic configuration of the component. By default, new components are processors,</p>
</li>
<li>
<p>Enter a valid Java name for the component. For example, <strong>Logger</strong>.</p>
</li>
<li>
<p>Select <strong>Configuration Model</strong> and add a string field named <code>level</code>. This input field will be used in the component configuration to enter additional information to display in the logs.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_component_configuration_model.png" target="_blank" rel="noopener"><img src="_images/tutorial_component_configuration_model.png" alt="Configuration Model"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Input(s) / Output(s)</strong> section, click the default <strong>MAIN</strong> input branch to access its detail, and make sure that the record model is set to <strong>Generic</strong>. Leave the <strong>Name</strong> of the branch with its default <code>MAIN</code> value.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_component_generic_input.png" target="_blank" rel="noopener"><img src="_images/tutorial_component_generic_input.png" alt="Generic Input"></a>
</div>
</div>
</li>
<li>
<p>Repeat the same step for the default <strong>MAIN</strong> output branch.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the component is a processor, it has an output branch by default. A processor without any output branch is considered an output component. You can create output components when the <strong>Activate IO</strong> option is selected.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Click <strong>Next</strong> and check the name and location of your project, then click <strong>Finish</strong> to generate the project in the IDE.<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point, your component is technically already ready to be compiled and deployed to Talend Open Studio. But first, have a look at the generated project:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_generated_project_view.png" target="_blank" rel="noopener"><img src="_images/tutorial_generated_project_view.png" alt="Project view"></a>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Two classes based on the name and type of component defined in the <strong>Talend Component Kit Starter</strong> have been generated:</p>
<div class="ulist">
<ul>
<li>
<p><strong>LoggerProcessor</strong> is where the component logic is defined</p>
</li>
<li>
<p><strong>LoggerProcessorConfiguration</strong> is where the component layout and configurable fields are defined, including the <strong>level</strong> string field that was defined earlier in the configuration model of the component.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <strong>package-info.java</strong> file contains the component metadata defined in the <strong>Talend Component Kit Starter</strong>, like the family and category.</p>
</li>
<li>
<p>You can notice as well that the elements in the tree structure are named after the project metadata defined in the <strong>Talend Component Kit Starter</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These files are the starting point if you later need to edit the configuration, logic, and metadata of your component.</p>
</div>
<div class="paragraph">
<p>There is more that you can do and configure with the <strong>Talend Component Kit Starter</strong>. This tutorial covers only the basics. You can find more information in <a href="tutorial-generate-project-using-starter.html" class="xref page">this document</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compiling_and_deploying_the_component_to_talend_open_studio"><a class="anchor" href="#_compiling_and_deploying_the_component_to_talend_open_studio"></a>Compiling and deploying the component to Talend Open Studio</h3>
<div class="paragraph">
<p>Without any modification in the component code, you can compile the project and deploy the component to a local instance of Talend Open Studio.</p>
</div>
<div class="paragraph">
<p>This way, it will be easy to check that what is visible in the Studio is what is intended.</p>
</div>
<div class="paragraph">
<p>Before starting to run any command, make sure Talend Open Studio is not running.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From your component project in IntelliJ, open a terminal and make sure that the selected directory is the root of the project. All commands shown in this tutorial are performed from this location.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_intellij_terminal_blank.png" target="_blank" rel="noopener"><img src="_images/tutorial_intellij_terminal_blank.png" alt="Compile terminal"></a>
</div>
</div>
</li>
<li>
<p>Compile the project by running the following command: <code>mvnw clean install</code>.<br>
The <code>mvnw</code> command refers to the Maven wrapper that is shipped with Talend Component Kit. It allows to use the right version of Maven for your project without having to install it manually beforehand. An equivalent wrapper is available for Gradle.</p>
</li>
<li>
<p>Once the command is executed and you see <strong>BUILD SUCCESS</strong> in the terminal, deploy the component to your local instance of Talend Open Studio using the following command:<br>
<code>mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;path to Talend Open Studio home&gt;"</code><br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Replace the path by your own value. If the path contains spaces (for example, <code>Program Files</code>), enclose it with double quotes.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Make sure the build is successful.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_deploy_in_studio_success.png" target="_blank" rel="noopener"><img src="_images/tutorial_deploy_in_studio_success.png" alt="Build success"></a>
</div>
</div>
</li>
<li>
<p>Open Talend Open Studio and create a new Job:</p>
<div class="ulist">
<ul>
<li>
<p>The new component is present inside the new family and category that were specified in the <strong>Talend Component Kit Starter</strong>. You can add it to your job and open its settings.</p>
</li>
<li>
<p>Notice that the <strong>level</strong> field that was specified in the configuration model of the component in the <strong>Talend Component Kit Starter</strong> is present.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_first_component_in_studio.png" target="_blank" rel="noopener"><img src="_images/tutorial_first_component_in_studio.png" alt="Component in Studio"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point, your new component is available in Talend Open Studio, and its configurable part is already set. But the component logic is still to be defined.<br></p>
</div>
</div>
<div class="sect2">
<h3 id="_editing_the_component"><a class="anchor" href="#_editing_the_component"></a>Editing the component</h3>
<div class="paragraph">
<p>You can now edit the component to implement a simple logic: reading the data contained in the input branch of the component to display it the execution logs of the job. The value of the <strong>level</strong> field of the component also needs to be displayed and changed to uppercase.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save the job created earlier and close Talend Open Studio.</p>
</li>
<li>
<p>Back in IntelliJ open the <strong>LoggerProcessor</strong> class. This is the class where the component logic can be defined.</p>
</li>
<li>
<p>Look for the <code>@ElementListener</code> method. It is already present and references the default input branch that was defined in the <strong>Talend Component Kit Starter</strong>, but it is not complete yet.</p>
</li>
<li>
<p>To be able to log the data in input to the console, add the following lines:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Log to the console
        System.out.println("["+configuration.getLevel().toUpperCase()+"] "+defaultInput);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ElementListener</code> method now looks as follows:<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
    public void onNext(
            @Input final Record defaultInput) {
        // this is the method allowing you to handle the input(s) and emit the output(s)
        // after some custom logic you put here, to send a value to next element you can use an
        // output parameter and call emit(value).

        //Log to the console
        System.out.println("["+configuration.getLevel().toUpperCase()+"] "+defaultInput);
    }</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="5">
<li>
<p>Open the Terminal again to compile the project and deploy the component again. To do that, run successively the two following commands:</p>
<div class="ulist">
<ul>
<li>
<p><code>mvnw clean install</code></p>
</li>
<li>
<p><code>`mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;path to Talend Open Studio home&gt;"</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The update of the component logic should now be deployed to the Studio. After restarting the Studio, you will be ready to build a job and use your component for the first time.</p>
</div>
<div class="paragraph">
<p>To learn the different possibilities and methods available to develop more complex logics, refer to <a href="component-define-processor-output.html" class="xref page">this document</a>.</p>
</div>
<div class="paragraph">
<p>If you want to avoid having to close and re-open Talend Open Studio every time you need to make an edit, you can enable the developer mode, as explained in <a href="studio.html#developer-mode" class="xref page">this document</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_a_job_with_the_component"><a class="anchor" href="#_building_a_job_with_the_component"></a>Building a job with the component</h3>
<div class="paragraph">
<p>As the component is now ready to be used, it is time to create a job and check that it behaves as intended.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open Talend Open Studio again and go to the job created earlier. The new component is still there.</p>
</li>
<li>
<p>Add a <strong>tRowGenerator</strong> component and connect it to the logger.</p>
</li>
<li>
<p>Double-click the <strong>tRowGenerator</strong> to specify the data to generate:</p>
<div class="ulist">
<ul>
<li>
<p>Add a first column named <code>firstName</code> and select the <strong>TalendDataGenerator.getFirstName()</strong> function.</p>
</li>
<li>
<p>Add a second column named 'lastName' and select the <strong>TalendDataGenerator.getLastName()</strong> function.</p>
</li>
<li>
<p>Set the <strong>Number of Rows for RowGenerator</strong> to <code>10</code>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_build_job_trowgenerator.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_trowgenerator.png" alt="tRowGenerator"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Validate the <strong>tRowGenerator</strong> configuration.</p>
</li>
<li>
<p>Open the <strong>TutorialFamilyLogger</strong> component and set the <strong>level</strong> field to <code>info</code>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_build_job_logger.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_logger.png" alt="Logger"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>Run</strong> tab of the job and run the job.<br>
The job is executed. You can observe in the console that each of the 10 generated rows is logged, and that the <code>info</code> value entered in the logger is also displayed with each record, in uppercase.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
</div>
<div class="sect2 relatedlinks">
<h3 id="_related_articles"><a class="anchor" href="#_related_articles"></a>Related articles</h3>
<div class="paragraph">
<p>To go further and start implementing more complex components, you can refer to the following documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="xref page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="xref page">Generating a project using the Talend Component Kit Starter</a></p>
</li>
<li>
<p><a href="component-registering.html" class="xref page">Registering a component</a></p>
</li>
<li>
<p><a href="component-execution.html" class="xref page">General component execution logic</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="xref page">Configuring a component</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="xref page">Defining an input component logic</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="xref page">Defining a processor/output logic</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="xref page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="xref page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="xref page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generating_a_project_using_the_component_kit_starter"><a class="anchor" href="#_generating_a_project_using_the_component_kit_starter"></a>Generating a project using the Component Kit Starter</h2>
<div class="sectionbody">
<div id="tutorial-generate-project-using-starter" class="paragraph">
<p>The Component Kit starter lets you design your components configuration and generates a ready-to-implement project structure.</p>
</div>
<div class="paragraph">
<p>The starter is available on the web or as an <a href="generate-project-using-intellij-plugin.html" class="xref page">IntelliJ plugin</a>.</p>
</div>
<div class="paragraph">
<p>This tutorial shows you how to use the Component Kit Starter to generate new components for MySQL databases. Before starting, make sure that you have correctly setup your environment. See <a href="system-prerequisites.html" class="xref page">this section</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When defining a project using the Starter, do not refresh the page to avoid losing your configuration.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_configuring_the_project"><a class="anchor" href="#_configuring_the_project"></a>Configuring the project</h3>
<div class="paragraph">
<p>Before being able to create components, you need to define the general settings of the project:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a folder on your local machine to store the resource files of the component you want to create. For example, <code>C:/my_components</code>.</p>
</li>
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Select your build tool. This tutorial uses Maven, but you can select Gradle instead.</p>
</li>
<li>
<p>Add any facet you need. For example, add the <strong>Talend Component Kit Testing</strong> facet to your project to automatically generate unit tests for the components created in the project.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_test_facet.png" target="_blank" rel="noopener"><img src="_images/starter/starter_test_facet.png" alt="Test facet"></a>
</div>
</div>
</li>
<li>
<p>Enter the <strong>Component Family</strong> of the components you want to develop in the project. This name must be a valid java name and is recommended to be capitalized, for example 'MySQL'.<br>
Once you have implemented your components in the Studio, this name is displayed in the Palette to group all of the MySQL-related components you develop, and is also part of your component name.</p>
</li>
<li>
<p>Select the <strong>Category</strong> of the components you want to create in the current project. As MySQL is a kind of database, select <strong>Databases</strong> in this tutorial.<br>
This <strong>Databases</strong> category is used and displayed as the parent family of the MySQL group in the Palette of the Studio.</p>
</li>
<li>
<p>Complete the project metadata by entering the <strong>Group</strong>, <strong>Artifact</strong> and <strong>Package</strong>.</p>
</li>
<li>
<p>By default, you can only create <strong>processors</strong>. If you need to create <strong>Input</strong> or <strong>Output</strong> components, select <strong>Activate IO</strong>. By doing this:</p>
<div class="ulist">
<ul>
<li>
<p>Two new menu entries let you add datasets and datastores to your project, as they are required for input and output components.<br></p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Input and Output components without dataset (itself containing a datastore) will not pass the validation step when building the components. Learn more about datasets and datastores in <a href="component-configuration.html#dataset-and-datastore" class="xref page">this document</a>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>An Input component and an Output component are automatically added to your project and ready to be configured.</p>
</li>
<li>
<p>Components added to the project using <strong>Add A Component</strong> can now be processors, input or output components.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_activate_io.png" target="_blank" rel="noopener"><img src="_images/starter/starter_activate_io.png" alt="Activate IO"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_datastore"><a class="anchor" href="#_defining_a_datastore"></a>Defining a Datastore</h3>
<div class="paragraph">
<p>A datastore represents the data needed by an input or output component to connect to a database.</p>
</div>
<div class="paragraph">
<p>When building a component, the <code>validateDataSet</code> validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.</p>
</div>
<div class="paragraph">
<p>You can define one or several datastores if you have selected the <strong>Activate IO</strong> step.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Datastore</strong>. The list of datastores opens. By default, a datastore is already open but not configured. You can configure it or create a new one using <strong>Add new Datastore</strong>.</p>
</li>
<li>
<p>Specify the name of the datastore. Modify the default value to a meaningful name for your project.<br>
This name must be a valid Java name as it will represent the datastore class in your project. It is a good practice to start it with an uppercase letter.</p>
</li>
<li>
<p>Edit the datastore configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes connection details to a database:</p>
<div class="ulist">
<ul>
<li>
<p>url</p>
</li>
<li>
<p>username</p>
</li>
<li>
<p>password.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Save</strong> the datastore configuration.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_dataset"><a class="anchor" href="#_defining_a_dataset"></a>Defining a Dataset</h3>
<div class="paragraph">
<p>A dataset represents the data coming from or sent to a database and needed by input and output components to operate.</p>
</div>
<div class="paragraph">
<p>The <code>validateDataSet</code> validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.</p>
</div>
<div class="paragraph">
<p>You can define one or several datasets if you have selected the <strong>Activate IO</strong> step.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Dataset</strong>. The list of datasets opens. By default, a dataset is already open but not configured. You can configure it or create a new one using the <strong>Add new Dataset</strong> button.</p>
</li>
<li>
<p>Specify the name of the dataset. Modify the default value to a meaningful name for your project.<br>
This name must be a valid Java name as it will represent the dataset class in your project. It is a good practice to start it with an uppercase letter.</p>
</li>
<li>
<p>Edit the dataset configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes details of the data to retrieve:</p>
<div class="ulist">
<ul>
<li>
<p>Datastore to use (that contains the connection details to the database)</p>
</li>
<li>
<p>table name</p>
</li>
<li>
<p>data</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Save</strong> the dataset configuration.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_input_component"><a class="anchor" href="#_creating_an_input_component"></a>Creating an Input component</h3>
<div class="paragraph">
<p>To create an input component, make sure you have selected <strong>Activate IO</strong>.</p>
</div>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.<br>
The intent in this tutorial is to create an input component that connects to a MySQL database, executes a SQL query and gets the result.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_add_component.png" target="_blank" rel="noopener"><img src="_images/starter/starter_add_component.png" alt="Input configuration"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>Input</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLInput</em>.</p>
</li>
<li>
<p>Click <strong>Configuration model</strong>. This button lets you specify the required configuration for the component. By default, a dataset is already specified.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the parameter name and choose its type then click the tick button to save the changes.<br>
In this tutorial, to be able to execute a SQL query on the Input MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a dataset (which contains the datastore with the connection information)</p>
</li>
<li>
<p>a timeout parameter.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration. However, refreshing the page resets the configuration.<br>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_input-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_input-config.png" alt="Input configuration"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Specify whether the component issues a stream or not. In this tutorial, the MySQL input component created is an ordinary (non streaming) component. In this case, leave the <strong>Stream</strong> option disabled.</p>
</li>
<li>
<p>Select the <strong>Record Type</strong> generated by the component. In this tutorial, select <strong>Generic</strong> because the component is designed to generate records in the default <code>Record</code> format.<br>
You can also select <strong>Custom</strong> to define a POJO that represents your records.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your input component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_processor_component"><a class="anchor" href="#_creating_a_processor_component"></a>Creating a Processor component</h3>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.
The intent in this tutorial is to create a simple processor component that receives a record, logs it and returns it at it is.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you did not select <strong>Activate IO</strong>, all new components you add to the project are processors by default.<br>
If you selected <strong>Activate IO</strong>, you can choose the component type. In this case, to create a Processor component, you have to manually add at least one output.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If required, choose the component type: <strong>Processor</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>RecordLogger</em>, as the processor created in this tutorial logs the records.</p>
</li>
<li>
<p>Specify the <strong>Configuration Model</strong> of the component. In this tutorial, the component doesn&#8217;t need any specific configuration. Skip this step.</p>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>Add Input</strong>. In this tutorial, only one input is needed to receive the record to log.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option and click <strong>Save</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_processor-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_processor-config.png" alt="Processor configuration"></a>
</div>
</div>
</li>
<li>
<p>Define the <strong>Output(s)</strong> of the component. For each output that you need to define, click <strong>Add Output</strong>. The first output must be named <code>MAIN</code>. In this tutorial, only one generic output is needed to return the received record.<br>
Outputs can be configured the same way as inputs (see previous steps).<br>
You can define a reject output connection by naming it <code>REJECT</code>. This naming is used by Talend applications to automatically set the connection type to Reject.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your processor component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_an_output_component"><a class="anchor" href="#_creating_an_output_component"></a>Creating an Output component</h3>
<div class="paragraph">
<p>To create an output component, make sure you have selected <strong>Activate IO</strong>.</p>
</div>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.<br>
The intent in this tutorial is to create an output component that receives a record and inserts it into a MySQL database table.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Output</strong> components are <strong>Processors</strong> without any output. In other words, the output is a processor that does not produce any records.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_output-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_output-config.png" alt="Output configuration"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>Output</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLOutput</em>.</p>
</li>
<li>
<p>Click <strong>Configuration Model</strong>. This button lets you specify the required configuration for the component. By default, a dataset is already specified.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes.<br>
In this tutorial, to be able to insert a record in the output MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a dataset (which contains the datastore with the connection information)</p>
</li>
<li>
<p>a timeout parameter.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration. However, refreshing the page resets the configuration.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>Add Input</strong>. In this tutorial, only one input is needed.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option and click <strong>Save</strong>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not create any output because the component does not produce any record. This is the only difference between an output an a processor component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your output component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generating_and_downloading_the_final_project"><a class="anchor" href="#_generating_and_downloading_the_final_project"></a>Generating and downloading the final project</h3>
<div class="paragraph">
<p>Once your project is configured and all the components you need are created, you can generate and download the final project.
In this tutorial, the project was configured and three components of different types (input, processor and output) have been defined.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Click <strong>Finish</strong> on the left panel. You are redirected to a page that summarizes the project. On the left panel, you can also see all the components that you added to the project.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter/starter_project-download.png" target="_blank" rel="noopener"><img src="_images/starter/starter_project-download.png" alt="Output configuration"></a>
</div>
</div>
</li>
<li>
<p>Generate the project using one of the two options available:</p>
<div class="ulist">
<ul>
<li>
<p>Download it locally as a ZIP file using the <strong>Download as ZIP</strong> button.</p>
</li>
<li>
<p>Create a GitHub repository and push the project to it using the <strong>Create on Github</strong> button.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this tutorial, the project is downloaded to the local machine as a ZIP file.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compiling_and_exploring_the_generated_project_files"><a class="anchor" href="#_compiling_and_exploring_the_generated_project_files"></a>Compiling and exploring the generated project files</h3>
<div class="paragraph">
<p>Once the package is available on your machine, you can compile it using the build tool selected when configuring the project.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the tutorial, <strong>Maven</strong> is the build tool selected for the project.<br>
In the project directory, execute the <code>mvn package</code> command.<br>
If you don&#8217;t have Maven installed on your machine, you can use the Maven wrapper provided in the generated project, by executing the <code>./mvnw package</code> command.</p>
</li>
<li>
<p>If you have created a Gradle project, you can compile it using the <code>gradle build</code> command or using the Gradle wrapper: <code>./gradlew build</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated project code contains documentation that can guide and help you implementing the component logic.
Import the project to your favorite IDE to start the implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generating_a_project_using_an_openapi_json_descriptor"><a class="anchor" href="#_generating_a_project_using_an_openapi_json_descriptor"></a>Generating a project using an OpenAPI JSON descriptor</h3>
<div class="paragraph">
<p>The Component Kit Starter allows you to generate a component development project from an OpenAPI JSON descriptor.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">Starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Enable the <strong>OpenAPI</strong> mode using the toggle in the header.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter_openapi_toggle.png" target="_blank" rel="noopener"><img src="_images/starter_openapi_toggle.png" alt="Open API toggle"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>API</strong> menu.</p>
</li>
<li>
<p>Paste the OpenAPI JSON descriptor in the right part of the screen. All the described endpoints are detected.</p>
</li>
<li>
<p>Unselect the endpoints that you do not want to use in the future components. By default, all detected endpoints are selected.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/starter_openapi_json.png" target="_blank" rel="noopener"><img src="_images/starter_openapi_json.png" alt="Open API menu"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>Finish</strong> menu.</p>
</li>
<li>
<p>Download the project.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When exploring the project generated from an OpenAPI descriptor, you can notice the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sources</p>
</li>
<li>
<p>the API dataset</p>
</li>
<li>
<p>an HTTP client for the API</p>
</li>
<li>
<p>a connection folder containing the component configuration. By default, the configuration is only made of a simple datastore with a <code>baseUrl</code> parameter.</p>
</li>
</ul>
</div>
</div>
<div class="sect2 relatedlinks">
<h3 id="_related_articles_2"><a class="anchor" href="#_related_articles_2"></a>Related articles</h3>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="xref page">Methodology</a></p>
</li>
<li>
<p><a href="tutorial-create-an-input-component.html" class="xref page">Creating a Hazelcast input component</a></p>
</li>
<li>
<p><a href="tutorial-create-an-output-component.html" class="xref page">Creating a Hazelcast output component</a></p>
</li>
<li>
<p><a href="tutorial-create-components-rest-api.html" class="xref page">Creating a Zendesk REST API connector</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="xref page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="xref page">Defining a processor or output component</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_talend_input_component_for_hazelcat"><a class="anchor" href="#_talend_input_component_for_hazelcat"></a>Talend Input component for Hazelcat</h2>
<div class="sectionbody">
<div id="tutorial-create-an-input-component2" class="paragraph">
<p>In this tutorial, we will walk through the creation of a complete Talend input component from scratch for hazelcast using
Talend Component Framework that we will reference in this tutorial as <strong>TCK</strong>.</p>
</div>
<div class="paragraph">
<p>We will create an input component for hazelcast. Hazelcast will be a prefect example to show how to create an input component
for distributed systems. Hazelcast is an in-memory distributed data grid. You can read more about it here <a href="https://hazelcast.org/" class="bare">hazelcast.org/</a> but all what you
will need to know to follow this tutorial is that hazelcast is a distributed system that can store data.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>So, Let&#8217;s start by creating the component project.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_project_creation"><a class="anchor" href="#_project_creation"></a>Project creation</h3>
<div class="paragraph">
<p>TCK project is a simple java project with some specific configuration and dependencies. You can choose your
preferred build tool from <strong>Maven</strong> or <strong>Gradle</strong> as TCK supports both of them. <strong>But, in this tutorial, we will use maven.</strong></p>
</div>
<div class="paragraph">
<p>Let&#8217;s generate the project structure using <strong>Talend Starter TOOLKIT</strong> .</p>
</div>
<div class="paragraph">
<p>For that, please go to <a href="https://starter-toolkit.talend.io/" class="bare">starter-toolkit.talend.io/</a> and fill in the project information as shown
in the screen capture bellow, then click finish and click <strong>download as a zip</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/tutorial_hazelcast_generateproject_1.png" alt="tutorial hazelcast generateproject 1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/tutorial_hazelcast_generateproject_2.png" alt="tutorial hazelcast generateproject 2">
</div>
</div>
<div class="paragraph">
<p>Extract the zip file into your workspace and import it to your preferred IDE. We will use Intellij IDE, but you can use Eclipse
or any other IDE that you are comfortable with.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use the <strong>starter toolkit</strong> to design the full configuration of the component, but in this tutorial we will do that
manually to explain some concepts of TCK.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s explore the generated <code>pom.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="
          http://maven.apache.org/POM/4.0.0
          http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.talend.components.hazelcast&lt;/groupId&gt;
  &lt;artifactId&gt;hazelcast-component&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Component Hazelcast&lt;/name&gt;
  &lt;description&gt;A generated component project&lt;/description&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;

    &lt;!--
    Set it to true if you want the documentation to be rendered as HTML and PDF

    You can also use it on the command line: -Dtalend.documentation.htmlAndPdf=true
    --&gt;
    &lt;talend.documentation.htmlAndPdf&gt;false&lt;/talend.documentation.htmlAndPdf&gt;

    &lt;!--
    if you want to deploy into the studio you can use the related goal:

    mvn package talend-component:deploy-in-studio -Dtalend.component.studioHome=/path/to/studio

    TIP: it is recommended to set this property into your settings.xml in an active by default profile.
    --&gt;
    &lt;talend.component.studioHome /&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;component-api&lt;/artifactId&gt;
      &lt;version&gt;1.1.12&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;extensions&gt;
      &lt;extension&gt;
        &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
        &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.1.12&lt;/version&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;

    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.8.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.8&lt;/source&gt;
          &lt;target&gt;1.8&lt;/target&gt;
          &lt;forceJavacCompilerUse&gt;true&lt;/forceJavacCompilerUse&gt;
          &lt;compilerId&gt;javac&lt;/compilerId&gt;
          &lt;fork&gt;true&lt;/fork&gt;
          &lt;compilerArgs&gt;
            &lt;arg&gt;-parameters&lt;/arg&gt;
          &lt;/compilerArgs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.0.0-M3&lt;/version&gt;
        &lt;configuration&gt;
          &lt;trimStackTrace&gt;false&lt;/trimStackTrace&gt;
          &lt;runOrder&gt;alphabetical&lt;/runOrder&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change the <code>name</code> tag to a more relevant one, for example <strong>&lt;name&gt;Component Hazelcast&lt;/name&gt;</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>component-api</code> dependency provides us with the necessary API to develop the components.</p>
</li>
<li>
<p><code>talend-component-maven-plugin</code> provides building and validation tools for the components development.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also the java compiler needs some Talend specific configuration for the components to work correctly.
The most important is the option <strong>-parameters</strong> that preserve the parameters name needed for some introspection feature that TCK rely on.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s download the mvn dependencies declared in the <code>pom.xml</code> file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mvn clean compile</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get a BUILD SUCCESS at this point as shown bellow.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">[INFO] Scanning for projects...
[INFO]
[INFO] -----&lt; org.talend.components.hazelcast:talend-component-hazelcast &gt;-----
[INFO] Building Component :: Hazelcast 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]

...

[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.311 s
[INFO] Finished at: 2019-09-03T11:42:41+02:00
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s create the project structure. For that, create the following folder structure as the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mkdir -p src/main/java
$ mkdir -p src/main/resources</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then, let&#8217;s create the component java packages.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The Package are mandatory in the component model and you can&#8217;t use the default one (no package).
It&#8217;s recommended to create unique package by component to be able to reuse them as dependencies in other component
for example or to guarantee an isolation while writing unit tests.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mkdir -p src/main/java/org/talend/components/hazelcast
$ mkdir -p src/main/resources/org/talend/components/hazelcast</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Now, the project is correctly setup, let&#8217;s continue by registering the component family and setting up
some i18n properties</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_registering_the_hazelcast_components_family"><a class="anchor" href="#_registering_the_hazelcast_components_family"></a>Registering the Hazelcast components family</h3>
<div class="paragraph">
<p>Every family (group) of components needs to be registered to be loaded by components server and then to be available
in Talend Studio components palette for example.</p>
</div>
<div class="paragraph">
<p>The family registration is done via the <code>package-info.java</code> file so let&#8217;s create it.
For that move to <code>src/main/java/org/talend/components/hazelcast</code> package and create a  <code>package-info.java</code> file as bellow.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Components(family = "Hazelcast", categories = "Databases")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Components;
import org.talend.sdk.component.api.component.Icon;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>@Components</strong>: declare the family name and the categories to which it will belongs <strong>@Icon</strong>: declare the component family icon. this is mostly used in the studio metadata tree.</p>
</div>
<div class="paragraph">
<p>TCK also provides i18n support via java properties files to customize and translate the display name of some properties
like the family name or, as we will see later in this tutorial, the component configuration labels.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s create the i18n file in the <code>resources</code> folder.
For that, please move to <code>src/main/resources/org/talend/components/hazelcast</code> and create a <code>Messages.properties</code> file as bellow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># An i18n name for the component family
Hazelcast._displayName=Hazelcast</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the family icon, defined in the <code>package-info.java</code> file, an icon image needs to be provided in the <code>resources/icons</code>
folder.</p>
</div>
<div class="paragraph">
<p>TCK support <code>svg</code> and <code>png</code> format for the icons.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s create the <code>icons</code> folder and put an icon image for our hazelcast family.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mkdir -p /src/main/resources/icons</code></pre>
</div>
</div>
<div class="paragraph">
<p>I will use the hazelcast icon from there official github repository that you can get from here <a href="https://avatars3.githubusercontent.com/u/1453152?s=200&amp;v=4" class="bare">avatars3.githubusercontent.com/u/1453152?s=200&amp;v=4</a></p>
</div>
<div class="paragraph">
<p>Download the image and rename it to <code>Hazelcast_icon32.png</code>.
The name template is important and it should match <code>&lt;Icon id from the package-info&gt;_icon.32.png</code></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>That&#8217;s all for the component registration.
Now we can start designing the component configuration</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_hazelcast_component_configuration"><a class="anchor" href="#_hazelcast_component_configuration"></a>Hazelcast component configuration</h3>
<div class="paragraph">
<p>All the I/O components follow a predefined model of configuration.
The configuration needs to be composed of two parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Datastore</strong>: define all the properties that will let the component connect to the targeted system.</p>
</li>
<li>
<p><strong>Dataset</strong>: define the data that will be read or written from/to the targeted system.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_datastore"><a class="anchor" href="#_datastore"></a>Datastore</h4>
<div class="paragraph">
<p>To connect to hazelcast cluster we will need the cluster ip address, the group name and the password of the targeted cluster.</p>
</div>
<div class="paragraph">
<p>In the component this will be represented by a simple POJO.
So, let&#8217;s create a class file <code>HazelcastDatastore.java</code> in <code>serc/main/java/org/talend/components/hazelcast</code>
folder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.configuration.constraint.Required;
import org.talend.sdk.component.api.configuration.type.DataStore;
import org.talend.sdk.component.api.configuration.ui.layout.GridLayout;
import org.talend.sdk.component.api.configuration.ui.widget.Credential;
import org.talend.sdk.component.api.meta.Documentation;

import java.io.Serializable;

@GridLayout({
        @GridLayout.Row("clusterIpAddress"),
        @GridLayout.Row({"groupName", "password"})
})
@DataStore("HazelcastDatastore")
@Documentation("Hazelcast Datastore configuration")
public class HazelcastDatastore implements Serializable {

    @Option
    @Required
    @Documentation("The hazelcast cluster ip address")
    private String clusterIpAddress;

    @Option
    @Documentation("cluster group name")
    private String groupName;

    @Option
    @Credential
    @Documentation("cluster password")
    private String password;

    // Getters &amp; Setters omitted for simplicity
    // You need to generate them
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s walk through the annotations used here :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GridLayout</code>: define the ui layout of this configuration in a grid manner.</p>
</li>
<li>
<p><code>@DataStore</code>: mark this POJO as being a data store with the id <code>HazelcastDatastore</code> that can be used to reference the datastore in the i18n files or some services</p>
</li>
<li>
<p><code>@Documentation</code>: document classes and properties. then TCK rely on those metadata to generate a documentation for the component.</p>
</li>
<li>
<p><code>@Option</code>: mark class&#8217;s attributes as being a configuration entry.</p>
</li>
<li>
<p><code>@Credential</code>: mark an Option as being a sensible data that need to be encrypted before it&#8217;s stored.</p>
</li>
<li>
<p><code>@Required</code>: mark a configuration as being required.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now let&#8217;s define the i18n properties of the data store.
In the <code>Messages.properties</code> file let add the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#datastore
Hazelcast.datastore.HazelcastDatastore._displayName=Hazelcast Connection
HazelcastDatastore.clusterIpAddress._displayName=Cluster ip address
HazelcastDatastore.groupName._displayName=Group Name
HazelcastDatastore.password._displayName=Passowrd</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>By this, we have defined the hazelcast datastore.
Let&#8217;s see now for the dataset</p>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_dataset"><a class="anchor" href="#_dataset"></a>Dataset</h4>
<div class="paragraph">
<p>In hazelcast there is different types of data store that can be found.
You can manipulate Maps, List, Set, Cache, Locks, Queue, Topic&#8230;&#8203;.</p>
</div>
<div class="paragraph">
<p>In this tutorial we will focus on Maps as an example, but all what we will see is also applicable to all the other data structures.</p>
</div>
<div class="paragraph">
<p>To read/write from a map we will need the map name.
So, let&#8217;s create the dataset classe.
For that create <code>HazelcastDataset.java</code>
file in <code>src/main/java/org/talend/components/hazelcast</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.configuration.type.DataSet;
import org.talend.sdk.component.api.configuration.ui.layout.GridLayout;
import org.talend.sdk.component.api.meta.Documentation;

import java.io.Serializable;

@GridLayout({
        @GridLayout.Row("connection"),
        @GridLayout.Row("mapName")
})
@DataSet("HazelcastDataset")
@Documentation("Hazelcast dataset")
public class HazelcastDataset implements Serializable {


    @Option
    @Documentation("Hazelcast connection")
    private HazelcastDatastore connection;

    @Option
    @Documentation("Hazelcast map name")
    private String mapName;

    // Getters &amp; Setters omitted for simplicity
    // You need to generate them

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we have a new annotation <code>@Dataset</code> that mark this classe as being a dataset.
Note that we also have a reference to the datastore. this is a part of the components model.</p>
</div>
<div class="paragraph">
<p>Now and as we have done with the datastore, let&#8217;s define the i18n properties of the dataset.
for that add the following lines to the <code>Messages.properties</code> file</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#dataset
Hazelcast.dataset.HazelcastDataset._displayName=Hazelcast Map
HazelcastDataset.connection._displayName=Connection
HazelcastDataset.mapName._displayName=Map Name</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>That&#8217;s all we need for the component configuration. Now let&#8217;s create the Source that will read the data from the hazelcast
map.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_source"><a class="anchor" href="#_source"></a>Source</h4>
<div class="paragraph">
<p>Source is the class responsible of reading the data from the configured dataset.</p>
</div>
<div class="paragraph">
<p>A source get the configuration instance that will be injected by TCK at runtime and will use it to connect to the targeted
system to read the data.</p>
</div>
<div class="paragraph">
<p>Here is a simple source for Hazelcast.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.IOException;
import java.io.Serializable;

@Version
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Emitter(name = "Input")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration) {
        this.dataset = configuration;
    }

    @PostConstruct
    public void init() throws IOException {
        //Here we can init connections
    }

    @Producer
    public Record next() {
        // provide a record every time it called. return null if there is no more data
        return null;
    }

    @PreDestroy
    public void release() {
        // clean and release any resources
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this class is annotated with <code>@Emitter</code> which mark this class as being a source that will produce records. We find
the <code>Icon</code> annotation that define the icon of the component. Here we will use the same icon as the family one but you can use
different icon if you want.</p>
</div>
<div class="paragraph">
<p>The constructor of the source class let TCK inject the required configuration to the source. We can also inject some common
services provided by TCK or other services that we can define in the component. We will see the service part later in this tutorial.</p>
</div>
<div class="paragraph">
<p>The method annotated with <code>@PostConstruct</code> is used to prepare resource or open a connection for example.</p>
</div>
<div class="paragraph">
<p>The method annotated with <code>@Producer</code> is responsible of retuning the next record if any. the method will return null if no
more record can be read.</p>
</div>
<div class="paragraph">
<p>The method annotated with <code>@PreDestroy</code> is responsible of cleaning any resource that was used or opened in the Source.</p>
</div>
<div class="paragraph">
<p>As for the configuration. the source also need some i18n properties to provide human readable display name of the source.</p>
</div>
<div class="paragraph">
<p>For that, please add the following line to the Messages.properties file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#Source
Hazelcast.Input._displayName=Input</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point we can already see the result in the Talend component web tester to see how the configuration looks like and validate
our layout visually.</p>
</div>
<div class="paragraph">
<p>For that, let&#8217;s execute this command in the project folder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mvn clean install talend-component:web</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will start the component web tester and deploy the component to it. Then you can browse it at <a href="http://localhost:8080/" class="bare">localhost:8080/</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">[INFO]
[INFO] --- talend-component-maven-plugin:1.1.12:web (default-cli) @ talend-component-hazelcast ---
[16:46:52.361][INFO ][.WebServer_8080][oyote.http11.Http11NioProtocol] Initializing ProtocolHandler ["http-nio-8080"]
[16:46:52.372][INFO ][.WebServer_8080][.catalina.core.StandardService] Starting service [Tomcat]
[16:46:52.372][INFO ][.WebServer_8080][e.catalina.core.StandardEngine] Starting Servlet engine: [Apache Tomcat/9.0.22]
[16:46:52.378][INFO ][.WebServer_8080][oyote.http11.Http11NioProtocol] Starting ProtocolHandler ["http-nio-8080"]
[16:46:52.390][INFO ][.WebServer_8080][g.apache.meecrowave.Meecrowave] --------------- http://localhost:8080
...
[INFO]

  You can now access the UI at http://localhost:8080


[INFO] Enter 'exit' to quit
[INFO] Initializing class org.talend.sdk.component.server.front.ComponentResourceImpl</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/tutorial_hazelcast_webtester.png" alt="tutorial hazelcast webtester">
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Now that we have setup our source let start creating some hazelcast specific code to connect to a cluster and read some
values for a map.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_source_implementation_for_hazelcast"><a class="anchor" href="#_source_implementation_for_hazelcast"></a>Source implementation for Hazelcast</h4>
<div class="paragraph">
<p>To work with hazelcast we will need to add the <code>hazelcast-client</code> maven dependency to the <code>pom.xml</code> of the project.</p>
</div>
<div class="paragraph">
<p>Add this dependency into the dependencies tag in the <code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;dependency&gt;
      &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
      &lt;artifactId&gt;hazelcast-client&lt;/artifactId&gt;
      &lt;version&gt;3.12.2&lt;/version&gt;
    &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s get an hazelcast instance in the <code>@PostConstruct</code> method. for that, let&#8217;s start by declaring a HazelcastInstance
attribute in the source class. Note that any non serializable attribute needs to be marked as transient to avoid serialization
issues. Then let&#8217;s implement the post construct method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;

import static java.util.Collections.singletonList;

@Version
@Emitter(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration) {
        this.dataset = configuration;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        // provide a record every time it called. return null if there is no more data
        return null;
    }

    @PreDestroy
    public void release() {
        // clean and release any resources
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we have mapped the component configuration to hazelcast client configuration to create a hazelcast instance that
we will use later to get the map by it&#8217;s name and then read the data from it.
The code is straight forward as you can notice. To keep it simple, we did expose only the required configuration in the component.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s implement the code that will be responsible of reading the data from the hazelcast map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Map;

import static java.util.Collections.singletonList;

@Version
@Emitter(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        // provide a record every time it called. return null if there is no more data
        if (mapIterator == null) {
            // Get the Distributed Map from Cluster.
            IMap&lt;String, String&gt; map = hazelcastInstance.getMap(dataset.getMapName());
            mapIterator = map.entrySet().iterator();
        }

        if (!mapIterator.hasNext()) {
            return null;
        }

        final Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();
    }

    @PreDestroy
    public void release() {
        // clean and release any resources
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s walk thought the implementation of the <code>Producer</code> annotated method.</p>
</div>
<div class="paragraph">
<p>We start by checking if the map iterator was already initialized and if not we get the map by it&#8217;s name and we initialize it.
we do that in the <code>@Producer</code> method to ensure the map is only initialized if the <code>next()</code> method is called (a lazy initialisation). we also avoid the
map initialization in the <code>PostConstruct</code> as the hazelcast map is not serializable.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Note that all the objects initialized in the <code>PostConstruct</code> method needs to be serializable as the source
may be serialized and sent to an other worker in a distributed cluster for it&#8217;s execution.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>From the map, we create an iterator on the map keys that we will use to read from the map. then we will transform every pair
of key/value to a Talend Record with a key, value Object on every call to next.</p>
</div>
<div class="paragraph">
<p>Notice here that we have used the <code>RecordBuilderFactory</code> class which is a built in service in TCK that we have injected via
the Source constructor. This service is a factory to create Talend Records.</p>
</div>
<div class="paragraph">
<p>Now the <code>next()</code> method will produce a Record every time it&#8217;s called. the method will return null if no more data is in the map.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>That&#8217;s all for the <code>@Producer</code> annotated method.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s implement the <code>@PreDestroy</code> annotated method which will be responsible of releasing
all the resource used by the Source. So here we will need to shutdown the hazelcast client instance to release any connection
between the component and hazelcast cluster.</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Map;

import static java.util.Collections.singletonList;

@Version
@Emitter(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        // provide a record every time it called. return null if there is no more data
        if (mapIterator == null) {
            // Get the Distributed Map from Cluster.
            IMap&lt;String, String&gt; map = hazelcastInstance.getMap(dataset.getMapName());
            mapIterator = map.entrySet().iterator();
        }

        if (!mapIterator.hasNext()) {
            return null;
        }

        final Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();
    }

    @PreDestroy
    public void release() {
        // clean and release any resources
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }
}</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Now, The hazel cast Source is completed. Let&#8217;s write a simple unit test to check that it&#8217;s working.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_source"><a class="anchor" href="#_test_the_source"></a>Test the source</h4>
<div class="paragraph">
<p>TCK provide a set of testing api and tools that makes the testing simple and straight forward.
So let&#8217;s create our first test.</p>
</div>
<div class="paragraph">
<p>To test our hazelcast Source, we will create an embedded hazelcast instance of only one member, for now,
and initialize it with some data. Then we will create a test Job that will read the data from it using the Source
that we have just implemented.</p>
</div>
<div class="paragraph">
<p>So for that, let&#8217;s start by adding the the required test maven dependencies to our project.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
            &lt;version&gt;5.5.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
            &lt;artifactId&gt;component-runtime-junit&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s start initializing a hazelcast test instance. and let&#8217;s create a map with some test data.</p>
</div>
<div class="paragraph">
<p>For that, create the test class <code>HazelcastSourceTest.java</code> in <code>src/test/java</code> folder that you will need to create before.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(4, map.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we start by creating a hazelcast instance for our test. then we create the <code>MY-DISTRIBUTED-MAP</code> map. The get map will
create the map if it&#8217;s not already exists. Then we add some key, values that we will use in our test.
After that we have a simple test that check that the data was correctly initialized. By the end, we shutdown the hazelcast test
instance.</p>
</div>
<div class="paragraph">
<p>Run the test by execution and check in the logs that a hazelcast cluster of one member is created and that the test is
passing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mvn clean test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, let&#8217;s create our test job to test our Source.</p>
</div>
<div class="paragraph">
<p>To be able to test the component. TCK provides the annotation <code>@WithComponents</code> which enable component testing. So, let&#8217;s
start by adding this annotation to our test. The annotation takes the components java package as a value parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.junit5.WithComponents;

import static org.junit.jupiter.api.Assertions.assertEquals;

@WithComponents("org.talend.components.hazelcast")
class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(4, map.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s create the test job that will configure the hazelcast and link it to an output that will collect the data
that will be produced by the source.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;
import org.talend.sdk.component.runtime.manager.chain.Job;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.talend.sdk.component.junit.SimpleFactory.configurationByExample;

@WithComponents("org.talend.components.hazelcast")
class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(4, map.size());
    }

    @Test
    void sourceTest() {
        final HazelcastDatastore connection = new HazelcastDatastore();
        connection.setClusterIpAddress(hazelcastInstance.getCluster().getMembers().iterator().next().getAddress().getHost());
        connection.setGroupName(hazelcastInstance.getConfig().getGroupConfig().getName());
        connection.setPassword(hazelcastInstance.getConfig().getGroupConfig().getPassword());
        final HazelcastDataset dataset = new HazelcastDataset();
        dataset.setConnection(connection);
        dataset.setMapName(MAP_NAME);

        final String configUri = configurationByExample().forInstance(dataset).configured().toQueryString();

        Job.components()
                .component("Input", "Hazelcast://Input?" + configUri)
                .component("Output", "test://collector")
            .connections()
                .from("Input").to("Output")
            .build()
            .run();

        List&lt;Record&gt; data = componentsHandler.getCollectedData(Record.class);
        assertEquals(4, data.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we have added the <code>componentsHandler</code> attribute which will be injected by TCK to our test. This component handler
gives us access to the collected data.</p>
</div>
<div class="paragraph">
<p>In <code>sourceTest</code> method we have instantiated the configuration of the source and fill it we the configuration of our hazelcast
test instance created before to let the source connect to it.
The Job API provide a simple way to build a DAG (directed acyclic graph) job using Talend components and then run it on
a specific runner (standalone, beam or spark). in this test we will first start using only the default runner which is the
standalone one.</p>
</div>
<div class="paragraph">
<p>the <code>configurationByExample()</code> method create the <code>ByExample</code> factory which provide a simple way to convert the configuration
instance to an URI configuration that can be used with the Job API to configure the component correctly.</p>
</div>
<div class="paragraph">
<p>At the end we run the job and check that the collected data size is equals to the initialized test data.</p>
</div>
<div class="paragraph">
<p>Execute the unit test and check that it&#8217;s passing. So our source is reading the data correctly from hazelcast.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mvn clean test</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>By that, our simple source is completed and tested. In the next section we will implement a the partition mapper for the source
which will be responsible of spiting the work (data reading) corresponding to the available cluster members to distribute
the work load.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect3">
<h4 id="_partition_mapper"><a class="anchor" href="#_partition_mapper"></a>Partition Mapper</h4>
<div class="paragraph">
<p>The partition mapper will be responsible of calculating the number of Source that can be created and executed in parallel
on different available worker in a distributed system. (in hazelcast it will corresponds to the  cluster members counts)</p>
</div>
<div class="paragraph">
<p>So, le&#8217;s evolve our test environment to add more hazelcast members and initialize it with more data.</p>
</div>
<div class="paragraph">
<p>For that, we will need to instantiate more hazelcast instance as every hazelcast instance correspond to one member
in a cluster. In our test this can be done as the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;
import org.talend.sdk.component.runtime.manager.chain.Job;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.talend.sdk.component.junit.SimpleFactory.configurationByExample;

@WithComponents("org.talend.components.hazelcast")
class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static final int CLUSTER_MEMBERS_COUNT = 2;

    private static final int MAX_DATA_COUNT_BY_MEMBER = 50;

    private static List&lt;HazelcastInstance&gt; hazelcastInstances;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @BeforeAll
    static void init() {
        hazelcastInstances = IntStream.range(0, CLUSTER_MEMBERS_COUNT)
                .mapToObj(i -&gt; Hazelcast.newHazelcastInstance())
                .collect(Collectors.toList());
        //add some data
        hazelcastInstances.forEach(hz -&gt; {
            final IMap&lt;String, String&gt; map = hz.getMap(MAP_NAME);
            IntStream.range(0, MAX_DATA_COUNT_BY_MEMBER)
                    .forEach(i -&gt; map.put(UUID.randomUUID().toString(), "value " + i));
        });
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstances.get(0).getMap(MAP_NAME);
        assertEquals(CLUSTER_MEMBERS_COUNT * MAX_DATA_COUNT_BY_MEMBER, map.size());
    }

    @Test
    void sourceTest() {
        final HazelcastDatastore connection = new HazelcastDatastore();
        HazelcastInstance hazelcastInstance = hazelcastInstances.get(0);
        connection.setClusterIpAddress(
                hazelcastInstance.getCluster().getMembers().iterator().next().getAddress().getHost());
        connection.setGroupName(hazelcastInstance.getConfig().getGroupConfig().getName());
        connection.setPassword(hazelcastInstance.getConfig().getGroupConfig().getPassword());
        final HazelcastDataset dataset = new HazelcastDataset();
        dataset.setConnection(connection);
        dataset.setMapName(MAP_NAME);

        final String configUri = configurationByExample().forInstance(dataset).configured().toQueryString();

        Job.components()
                .component("Input", "Hazelcast://Input?" + configUri)
                .component("Output", "test://collector")
                .connections()
                .from("Input")
                .to("Output")
                .build()
                .run();

        List&lt;Record&gt; data = componentsHandler.getCollectedData(Record.class);
        assertEquals(CLUSTER_MEMBERS_COUNT * MAX_DATA_COUNT_BY_MEMBER, data.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstances.forEach(HazelcastInstance::shutdown);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we create two hazelcast instance which will create two hazelcast members. So we will get a cluster
of two members (nodes) where we can distribute the data.
We also added more data to the test map and update the shutdown method and our test.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s run our test on our multi nodes cluster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">mvn clean test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the Source is a simple implementation that don&#8217;t distribute the work load and read all the data in a classic way
without distributing the read action on different cluster member.</p>
</div>
<div class="paragraph">
<p>Now that we have our multi members hazelcast cluster, we can start implementing a partition mapper that takes
into account the cluster size and the available dataset size to distribute the work on the members efficiently.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s implement the partition mapper class. For that, start creating a class file <code>HazelcastPartitionMapper.java</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.List;
import java.util.UUID;

import static java.util.Collections.singletonList;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName()+"-"+ UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return 0;
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        return null;
    }

    @Emitter
    public HazelcastSource createSource() {
        return null;
    }

    @PreDestroy
    public void release() {
        if(hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When introducing a partition mapper with a Source.
The partition mapper will be responsible of parameter injection and source instance creation. This way we move all the
attribute initialization from the source to the partition mapper class.</p>
</div>
<div class="paragraph">
<p>in the configuration we also set an instance name to make it easy to find the client instance in logs and while debugging.
We also set the instance class loader to be the tccl.</p>
</div>
<div class="paragraph">
<p>The partition mapper class is composed of :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>constructor</code>: responsible of configuration and services injection</p>
</li>
<li>
<p><code>Assessor</code>: method annotated with Assessor is responsible of the dataset size estimation. the estimated dataset size is
used by the underlying runner to calculate the optimal bundle size to ditribute the work load efficiently.</p>
</li>
<li>
<p><code>Split</code>: method annotated with Split is responsible of the calculation and the creation of partition mapper instance
based on the requested bundle size  by the underlying runner.it will create as much partition as possible to handle
the work load according to the requested bundle size and the dataset size in a way that bundles can be palatalized
efficiently on different available worker (members in hazelcast)</p>
</li>
<li>
<p><code>Emitter</code>: method annotated by Emitter is responsible of the creation of the source instance with an adapted configuration
that will let the source to be able of the bundle size to handle the records amount that it will produce. and the required services
In other words, it will adapt the configuration to let the source read only the requested bundle of data.
The source will need to control the bundle that will be read. Think of it like a pagination pattern where every source
instance  will read only one page.</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Let&#8217;s implement the Assessor method</p>
</div>
</blockquote>
</div>
<div class="sect4">
<h5 id="_assessor"><a class="anchor" href="#_assessor"></a>Assessor</h5>
<div class="paragraph">
<p>The assessor method will need to calculate the memory size of every member on the cluster. for that we will need to submit
the some calculation task to the members. for that we will nead a serializable task that is aware of the hazelcast instance</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create our serializable task first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceAware;

import java.io.Serializable;
import java.util.concurrent.Callable;

public abstract class SerializableTask&lt;T&gt; implements Callable&lt;T&gt;, Serializable, HazelcastInstanceAware {

    protected transient HazelcastInstance localInstance;

    @Override
    public void setHazelcastInstance(final HazelcastInstance hazelcastInstance) {
        localInstance = hazelcastInstance;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will use this class to submit any task to hazelcast cluster. Now, let&#8217;s use it to estimate the dataset size in the assessor
method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static java.util.Collections.singletonList;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName()+"-"+ UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

            @Override
            public Long call() {
                return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
            }
        }).values().stream().mapToLong(feature -&gt; {
            try {
                return feature.get();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }).sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
          return null;
    }

    @Emitter
    public HazelcastSource createSource() {
        return null;
    }

    @PreDestroy
    public void release() {
        if(hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = hazelcastInstance.getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the Assessor method we calculate the memory size that our map occupies on all the members.
In hazelcast, to distribute the a task to all the members we use an execution service which we initialize in <code>getExecutorService()</code>
method. So we request the size of the map on every available member and then we sum the result to get the total size of the
map in the distributed cluster.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Now, let&#8217;s implement the <code>Split</code> method.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect4">
<h5 id="_split"><a class="anchor" href="#_split"></a>Split</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static java.util.Collections.singletonList;
import static java.util.Collections.synchronizedMap;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    private List&lt;String&gt; members;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    private HazelcastPartitionMapper(final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, List&lt;String&gt; membersUUID) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = membersUUID;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return executorService.submitToAllMembers(
                () -&gt; hazelcastInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost())
                .values()
                .stream()
                .mapToLong(feature -&gt; {
                    try {
                        return feature.get();
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                })
                .sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        final Map&lt;String, Long&gt; heapSizeByMember =
                getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                }).entrySet().stream().map(heapSizeMember -&gt; {
                    try {
                        return new AbstractMap.SimpleEntry&lt;&gt;(heapSizeMember.getKey().getUuid(),
                                heapSizeMember.getValue().get());
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                }).collect(toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));

        final List&lt;HazelcastPartitionMapper&gt; partitions = new ArrayList&lt;&gt;(heapSizeByMember.keySet()).stream()
                .map(e -&gt; combineMembers(e, bundleSize, heapSizeByMember))
                .filter(Objects::nonNull)
                .map(m -&gt; new HazelcastPartitionMapper(dataset, recordBuilderFactory, m))
                .collect(toList());

        if (partitions.isEmpty()) {
            List&lt;String&gt; allMembers =
                    hazelcastInstance.getCluster().getMembers().stream().map(Member::getUuid).collect(toList());
            partitions.add(new HazelcastPartitionMapper(dataset, recordBuilderFactory, allMembers));
        }

        return partitions;
    }

    private List&lt;String&gt; combineMembers(String current, final long bundleSize, final Map&lt;String, Long&gt; sizeByMember) {

        if (sizeByMember.isEmpty() || !sizeByMember.containsKey(current)) {
            return null;
        }

        final List&lt;String&gt; combined = new ArrayList&lt;&gt;();
        long size = sizeByMember.remove(current);
        combined.add(current);
        for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = sizeByMember.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry&lt;String, Long&gt; entry = it.next();
            if (size + entry.getValue() &lt;= bundleSize) {
                combined.add(entry.getKey());
                size += entry.getValue();
                it.remove();
            }
        }
        return combined;
    }

    @Emitter
    public HazelcastSource createSource() {
        return null;
    }

    @PreDestroy
    public void release() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = hazelcastInstance.getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the split method calculate the heap size of our map on every member of the cluster.
Then, it calculate how much members, a source can handle.
As the only thing that we can distribute with a configuration like this is to split the reading task from the different
members.</p>
</div>
<div class="paragraph">
<p>So if a member contains less data than the requested bundle size we check if we can combine it with the data from
an other member where the combination of the two members data size is less or equals to the requested bundle size.</p>
</div>
<div class="paragraph">
<p>Read the code carefully to fully understand the logic implemented here.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Now, that we have finished the implementation of the split, let adapt the source to take into account the split.
The source will get the list of members from where it will read data.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect4">
<h5 id="_source_2"><a class="anchor" href="#_source_2"></a>Source</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toMap;

public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    private transient HazelcastInstance hazelcastInstance;

    private final List&lt;String&gt; members;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient Iterator&lt;Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt;&gt; dataByMember;

    public HazelcastSource(final HazelcastDataset configuration, final RecordBuilderFactory recordBuilderFactory,
            final List&lt;String&gt; members) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = members;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        if (dataByMember == null) {
            dataByMember = hazelcastInstance.getExecutorService("talend-source")
                    .submitToMembers(new SerializableTask&lt;Map&lt;String, String&gt;&gt;() {

                        @Override
                        public Map&lt;String, String&gt; call() {
                            final IMap&lt;String, String&gt; map = localInstance.getMap(dataset.getMapName());
                            final Set&lt;String&gt; localKeySet = map.localKeySet();
                            return localKeySet.stream().collect(toMap(k -&gt; k, map::get));
                        }
                    }, member -&gt; members.contains(member.getUuid()))
                    .entrySet()
                    .iterator();
        }

        if (mapIterator != null &amp;&amp; !mapIterator.hasNext() &amp;&amp; !dataByMember.hasNext()) {
            return null;
        }

        if (mapIterator == null || !mapIterator.hasNext()) {
            Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt; next = dataByMember.next();
            try {
                mapIterator = next.getValue().get().entrySet().iterator();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }

        Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();

    }

    @PreDestroy
    public void release() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>next</code> method we read the data from the members that we will get from the partition mapper.</p>
</div>
<div class="paragraph">
<p>In a bigdata runner (like spark) we will get multiple source instance. and every source instance will be responsible of
reading data from a specific set of members already calculated by the partition mapper.</p>
</div>
<div class="paragraph">
<p>Take some time to read the code and to understand what it&#8217;s going on and how we iterate on the data member by member.
The data is fetched only when the <code>next</code> method is called. Which let us stream the data from members without loading it
all into the memory.</p>
</div>
<div class="paragraph">
<p>Now, let&#8217;s implement the last method of this component. The method annotated by <code>@Emitter</code> in the <code>HazelcastPartitionMapper</code>
class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    private List&lt;String&gt; members;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    private HazelcastPartitionMapper(final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, List&lt;String&gt; membersUUID) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = membersUUID;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

            @Override
            public Long call() {
                return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
            }
        }).values().stream().mapToLong(feature -&gt; {
            try {
                return feature.get();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }).sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        final Map&lt;String, Long&gt; heapSizeByMember =
                getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                }).entrySet().stream().map(heapSizeMember -&gt; {
                    try {
                        return new AbstractMap.SimpleEntry&lt;&gt;(heapSizeMember.getKey().getUuid(),
                                heapSizeMember.getValue().get());
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                }).collect(toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));

        final List&lt;HazelcastPartitionMapper&gt; partitions = new ArrayList&lt;&gt;(heapSizeByMember.keySet()).stream()
                .map(e -&gt; combineMembers(e, bundleSize, heapSizeByMember))
                .filter(Objects::nonNull)
                .map(m -&gt; new HazelcastPartitionMapper(dataset, recordBuilderFactory, m))
                .collect(toList());

        if (partitions.isEmpty()) {
            List&lt;String&gt; allMembers =
                    hazelcastInstance.getCluster().getMembers().stream().map(Member::getUuid).collect(toList());
            partitions.add(new HazelcastPartitionMapper(dataset, recordBuilderFactory, allMembers));
        }

        return partitions;
    }

    private List&lt;String&gt; combineMembers(String current, final long bundleSize, final Map&lt;String, Long&gt; sizeByMember) {

        if (sizeByMember.isEmpty() || !sizeByMember.containsKey(current)) {
            return null;
        }

        final List&lt;String&gt; combined = new ArrayList&lt;&gt;();
        long size = sizeByMember.remove(current);
        combined.add(current);
        for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = sizeByMember.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry&lt;String, Long&gt; entry = it.next();
            if (size + entry.getValue() &lt;= bundleSize) {
                combined.add(entry.getKey());
                size += entry.getValue();
                it.remove();
            }
        }
        return combined;
    }

    @Emitter
    public HazelcastSource createSource() {
        return new HazelcastSource(dataset, recordBuilderFactory, members);
    }

    @PreDestroy
    public void release() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = hazelcastInstance.getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>createSource()</code> method we create the source instance and we passe the required services and the selected hazelcast
members to the the source instance.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Now, our component is done. It will be able to read data and distribute the work load upon members in a big data
execution engine that will manage the distribution of the work load.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Run the test and check that it&#8217;s working.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mvn clean test</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_introduce_tck_service"><a class="anchor" href="#_introduce_tck_service"></a>Introduce TCK service</h3>
<div class="paragraph">
<p>Let&#8217;s refactor the component by introducing a service to make some piece of code reusable and avoid code duplication.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s refactor the hazelcast instance creation in a service as the service executor creation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import org.talend.sdk.component.api.service.Service;

import java.io.Serializable;
import java.util.UUID;

import static java.util.Collections.singletonList;

@Service
public class HazelcastService implements Serializable {

    private transient HazelcastInstance hazelcastInstance;

    private transient IExecutorService executorService;

    public HazelcastInstance getOrCreateIntance(final HazelcastDatastore connection) {
        if (hazelcastInstance == null || !hazelcastInstance.getLifecycleService().isRunning()) {
            final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
            networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
            final ClientConfig config = new ClientConfig();
            config.setNetworkConfig(networkConfig);
            config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
            config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
            config.setClassLoader(Thread.currentThread().getContextClassLoader());
            hazelcastInstance = HazelcastClient.newHazelcastClient(config);
        }
        return hazelcastInstance;
    }

    public void shutdownInstance() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    public IExecutorService getExecutorService(final HazelcastDatastore connection) {
        return executorService == null ?
                executorService = getOrCreateIntance(connection).getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This service can be injected to the partition mapper and reused from there. so let&#8217;s do that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ExecutionException;

import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper implements Serializable {

    private final HazelcastDataset dataset;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    private List&lt;String&gt; members;

    private final HazelcastService hazelcastService;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, final HazelcastService hazelcastService) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.hazelcastService = hazelcastService;
    }

    private HazelcastPartitionMapper(final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, List&lt;String&gt; membersUUID,
            final HazelcastService hazelcastService) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.hazelcastService = hazelcastService;
        this.members = membersUUID;

    }

    @PostConstruct
    public void init() {
        // We initialize the hazelcast instance only on it first usage now
    }

    @Assessor
    public long estimateSize() {
        return hazelcastService.getExecutorService(dataset.getConnection())
                .submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                })
                .values()
                .stream()
                .mapToLong(feature -&gt; {
                    try {
                        return feature.get();
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                })
                .sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        final Map&lt;String, Long&gt; heapSizeByMember = hazelcastService.getExecutorService(dataset.getConnection())
                .submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                })
                .entrySet()
                .stream()
                .map(heapSizeMember -&gt; {
                    try {
                        return new AbstractMap.SimpleEntry&lt;&gt;(heapSizeMember.getKey().getUuid(),
                                heapSizeMember.getValue().get());
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                })
                .collect(toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));

        final List&lt;HazelcastPartitionMapper&gt; partitions = new ArrayList&lt;&gt;(heapSizeByMember.keySet()).stream()
                .map(e -&gt; combineMembers(e, bundleSize, heapSizeByMember))
                .filter(Objects::nonNull)
                .map(m -&gt; new HazelcastPartitionMapper(dataset, recordBuilderFactory, m, hazelcastService))
                .collect(toList());

        if (partitions.isEmpty()) {
            List&lt;String&gt; allMembers = hazelcastService.getOrCreateIntance(dataset.getConnection())
                    .getCluster()
                    .getMembers()
                    .stream()
                    .map(Member::getUuid)
                    .collect(toList());
            partitions.add(new HazelcastPartitionMapper(dataset, recordBuilderFactory, allMembers, hazelcastService));
        }

        return partitions;
    }

    private List&lt;String&gt; combineMembers(String current, final long bundleSize, final Map&lt;String, Long&gt; sizeByMember) {

        if (sizeByMember.isEmpty() || !sizeByMember.containsKey(current)) {
            return null;
        }

        final List&lt;String&gt; combined = new ArrayList&lt;&gt;();
        long size = sizeByMember.remove(current);
        combined.add(current);
        for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = sizeByMember.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry&lt;String, Long&gt; entry = it.next();
            if (size + entry.getValue() &lt;= bundleSize) {
                combined.add(entry.getKey());
                size += entry.getValue();
                it.remove();
            }
        }
        return combined;
    }

    @Emitter
    public HazelcastSource createSource() {
        return new HazelcastSource(dataset, recordBuilderFactory, members, hazelcastService);
    }

    @PreDestroy
    public void release() {
        hazelcastService.shutdownInstance();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s adapt the Source class to reuse the service.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.IMap;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import static java.util.stream.Collectors.toMap;

public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    private final List&lt;String&gt; members;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient Iterator&lt;Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt;&gt; dataByMember;

    private final HazelcastService hazelcastService;

    public HazelcastSource(final HazelcastDataset configuration, final RecordBuilderFactory recordBuilderFactory,
            final List&lt;String&gt; members, final HazelcastService hazelcastService) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = members;
        this.hazelcastService = hazelcastService;
    }

    @PostConstruct
    public void init() {
        // We initialize the hazelcast instance only on it first usage now
    }

    @Producer
    public Record next() {
        if (dataByMember == null) {
            dataByMember = hazelcastService.getOrCreateIntance(dataset.getConnection())
                    .getExecutorService("talend-source")
                    .submitToMembers(new SerializableTask&lt;Map&lt;String, String&gt;&gt;() {

                        @Override
                        public Map&lt;String, String&gt; call() {
                            final IMap&lt;String, String&gt; map = localInstance.getMap(dataset.getMapName());
                            final Set&lt;String&gt; localKeySet = map.localKeySet();
                            return localKeySet.stream().collect(toMap(k -&gt; k, map::get));
                        }
                    }, member -&gt; members.contains(member.getUuid()))
                    .entrySet()
                    .iterator();
        }

        if (mapIterator != null &amp;&amp; !mapIterator.hasNext() &amp;&amp; !dataByMember.hasNext()) {
            return null;
        }

        if (mapIterator == null || !mapIterator.hasNext()) {
            Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt; next = dataByMember.next();
            try {
                mapIterator = next.getValue().get().entrySet().iterator();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }

        Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();

    }

    @PreDestroy
    public void release() {
        hazelcastService.shutdownInstance();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>rerun the test to ensure everything still working correctly.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>That&#8217;s all for this tutorial. Now you should be able to create any input component for any system ;)</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_an_output_component_for_hazelcast"><a class="anchor" href="#_implementing_an_output_component_for_hazelcast"></a>Implementing an Output component for Hazelcast</h2>
<div class="sectionbody">
<div id="tutorial-create-an-output-component" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This tutorial is the continuation of
<a href="tutorial-create-an-input-component.html" class="xref page">Talend Input component for Hazelcast</a> tutorial. We will not walk through
the project creation again, So please start from there before taking this one.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This tutorial shows how to create a complete working output component for <a href="https://hazelcast.org">Hazelcast</a></p>
</div>
<div class="sect2">
<h3 id="_defining_the_configurable_part_and_the_layout_of_the_component"><a class="anchor" href="#_defining_the_configurable_part_and_the_layout_of_the_component"></a>Defining the configurable part and the layout of the component</h3>
<div class="paragraph">
<p>As seen before, in Hazelcast there is multiple data source type. You can find queues, topics, cache, maps&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>In this tutorials we will stick with the Map dataset and all what we will see here is applicable to the other types.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that our Hazelcast output component will be responsible of inserting data into a distributed Map.
For that, we will need to know which attribute from the incoming data is to be used as a key in the map. The value will be the hole record
encoded into a json format.</p>
</div>
<div class="paragraph">
<p>Bu that in mind, we can design our output configuration as: the same Datastore and Dataset from the input component
and an additional configuration that will define the key attribute.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create our Output configuration class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.configuration.ui.layout.GridLayout;
import org.talend.sdk.component.api.meta.Documentation;import java.io.Serializable;

@GridLayout({
                @GridLayout.Row("dataset"),
                @GridLayout.Row("key")
})
@Documentation("Hazelcast output configuration")
public class HazelcastOutputConfig implements Serializable {

    @Option
    @Documentation("the hazelcast dataset")
    private HazelcastDataset dataset;

    @Option
    @Documentation("The key attribute")
    private String key;


    // Getters &amp; Setters omitted for simplicity
    // You need to generate them
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s add the i18n properties of our configuration into the <code>Messages.properties file</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Output config
HazelcastOutputConfig.dataset._displayName=Hazelcast dataset
HazelcastOutputConfig.key._displayName=Key attribute</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_output_implementation"><a class="anchor" href="#_output_implementation"></a>Output Implementation</h3>
<div class="paragraph">
<p>The skeleton of the output component looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration) {
    }

    @PostConstruct
    public void init() {
    }

    @PreDestroy
    public void release() {
    }

    @ElementListener
    public void onElement(final Record record) {
    }

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Version</code> annotation indicates the version of the component. It is used to migrate the component configuration if needed.</p>
</li>
<li>
<p><code>@Icon</code> annotation indicates the icon of the component. Here, the icon is a custom icon that needs to be bundled in
the component JAR under <code>resources/icons</code>.</p>
</li>
<li>
<p><code>@Processor</code> annotation indicates that this class is the processor (output) and defines the name of the component.</p>
</li>
<li>
<p><code>constructor</code> of the processor is responsible for injecting the component configuration and services.
Configuration parameters are annotated with <code>@Option</code>. The other parameters are considered as services and are injected
by the component framework. Services can be local (class annotated with <code>@Service</code>) or provided by the component framework.</p>
</li>
<li>
<p>The method annotated with <code>@PostConstruct</code> is executed once by instance and can be used for initialization.</p>
</li>
<li>
<p>The method annotated with <code>@PreDestroy</code> is used to clean resources at the end of the execution of the output.</p>
</li>
<li>
<p>Data is passed to the method annotated with <code>@ElementListener</code>. That method is responsible for handling the data output.
You can define all the related logic in this method.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you need to bulk write the updates accordingly to groups, see <a href="concept-processor-and-batch-processing.html" class="xref page">Processors and batch processing</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, we will need to add the display name of the Output to the i18n resources file <code>Messages.properties</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#Output
Hazelcast.Output._displayName=Output</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Let&#8217;s implement all of those methods</p>
</div>
</blockquote>
</div>
<div class="sect3">
<h4 id="_defining_the_constructor_method"><a class="anchor" href="#_defining_the_constructor_method"></a>Defining the constructor method</h4>
<div class="paragraph">
<p>We will create the outpu contructor to inject the component configuration and some additional local and built in services.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Built in services are services provided by TCK.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.json.bind.Jsonb;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    private final HazelcastOutputConfig configuration;

    private final HazelcastService hazelcastService;

    private final Jsonb jsonb;

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration,
            final HazelcastService hazelcastService, final Jsonb jsonb) {
        this.configuration = configuration;
        this.hazelcastService = hazelcastService;
        this.jsonb = jsonb;
    }

    @PostConstruct
    public void init() {
    }

    @PreDestroy
    public void release() {
    }

    @ElementListener
    public void onElement(final Record record) {
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we find:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>configuration</code> is the component configuration class</p>
</li>
<li>
<p><code>hazelcastService</code> is the service that we have implemented in the input component tutorial. it will be responsible of creating a hazelcast
client instance.</p>
</li>
<li>
<p><code>jsonb</code> is a built in service provided by tck to handle json object serialization and deserialization. We will use it to
convert the incoming record to json format before inseting them into the map.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_postconstruct_method"><a class="anchor" href="#_defining_the_postconstruct_method"></a>Defining the PostConstruct method</h4>
<div class="paragraph">
<p>Nothing to do in the post construct method. but we could for example initialize a hazle cast instance there. but we will
do it in a lazy way on the first call in the <code>@ElementListener</code> method</p>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_predestroy_method"><a class="anchor" href="#_defining_the_predestroy_method"></a>Defining the PreDestroy method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.json.bind.Jsonb;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    private final HazelcastOutputConfig configuration;

    private final HazelcastService hazelcastService;

    private final Jsonb jsonb;

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration,
            final HazelcastService hazelcastService, final Jsonb jsonb) {
        this.configuration = configuration;
        this.hazelcastService = hazelcastService;
        this.jsonb = jsonb;
    }

    @PostConstruct
    public void init() {
        //no-op
    }

    @PreDestroy
    public void release() {
        this.hazelcastService.shutdownInstance();
    }

    @ElementListener
    public void onElement(final Record record) {
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Shut down the Hazelcast client instance and thus free the Hazelcast map reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_elementlistener_method"><a class="anchor" href="#_defining_the_elementlistener_method"></a>Defining the ElementListener method</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.json.bind.Jsonb;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    private final HazelcastOutputConfig configuration;

    private final HazelcastService hazelcastService;

    private final Jsonb jsonb;

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration,
            final HazelcastService hazelcastService, final Jsonb jsonb) {
        this.configuration = configuration;
        this.hazelcastService = hazelcastService;
        this.jsonb = jsonb;
    }

    @PostConstruct
    public void init() {
        //no-op
    }

    @PreDestroy
    public void release() {
        this.hazelcastService.shutdownInstance();
    }

    @ElementListener
    public void onElement(final Record record) {
        final String key = record.getString(configuration.getKey());
        final String value = jsonb.toJson(record);

        final HazelcastInstance hz = hazelcastService.getOrCreateIntance(configuration.getDataset().getConnection());
        final IMap&lt;String, String&gt; map = hz.getMap(configuration.getDataset().getMapName());
        map.put(key, value);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We get the key attribute from the incoming record and then convert the hole record to a json string. Then we insert
the key/value into the hazelcast map.</p>
</div>
</div>
<div class="sect3">
<h4 id="_testing_the_output_component"><a class="anchor" href="#_testing_the_output_component"></a>Testing the output component</h4>
<div class="paragraph">
<p>Let&#8217;s create a unit test for our output component. The idea will be to create a job that will insert the data using
this output implementation.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s create out test class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;

@WithComponents("org.talend.components.hazelcast")
class HazelcastOuputTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        //init the map
        final IMap&lt;String, String&gt; map = hazelcastInstances.getMap(MAP_NAME);

    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we start by creating a hazelcast test instance, and we initialize the map. we also shutdown the instance after all the
test are executed.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s create our output test.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.Service;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;
import org.talend.sdk.component.runtime.manager.chain.Job;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.talend.sdk.component.junit.SimpleFactory.configurationByExample;

@WithComponents("org.talend.components.hazelcast")
class HazelcastOuputTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @Service
    protected RecordBuilderFactory recordBuilderFactory;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        //init the map
        final IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);

    }

    @Test
    void outputTest() {
        final HazelcastDatastore connection = new HazelcastDatastore();
        connection.setClusterIpAddress(
                hazelcastInstance.getCluster().getMembers().iterator().next().getAddress().getHost());
        connection.setGroupName(hazelcastInstance.getConfig().getGroupConfig().getName());
        connection.setPassword(hazelcastInstance.getConfig().getGroupConfig().getPassword());
        final HazelcastDataset dataset = new HazelcastDataset();
        dataset.setConnection(connection);
        dataset.setMapName(MAP_NAME);

        HazelcastOutputConfig config = new HazelcastOutputConfig();
        config.setDataset(dataset);
        config.setKey("id");

        final String configUri = configurationByExample().forInstance(config).configured().toQueryString();

        componentsHandler.setInputData(generateTestData(10));
        Job.components()
                .component("Input", "test://emitter")
                .component("Output", "Hazelcast://Output?" + configUri)
                .connections()
                .from("Input")
                .to("Output")
                .build()
                .run();

        final IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(10, map.size());
    }

    private List&lt;Record&gt; generateTestData(int count) {
        return IntStream.range(0, count)
                .mapToObj(i -&gt; recordBuilderFactory.newRecordBuilder()
                        .withString("id", UUID.randomUUID().toString())
                        .withString("val1", UUID.randomUUID().toString())
                        .withString("val2", UUID.randomUUID().toString())
                        .build())
                .collect(Collectors.toList());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we start preparing the <code>emitter</code> test component provided bt TCK that we use in our test job
to generate random data for our output. Then, we use the output component to fill the hazelcast map.</p>
</div>
<div class="paragraph">
<p>By the end we test that the map contains the exact amount of data inserted by the job.</p>
</div>
<div class="paragraph">
<p>Run the test and check that it&#8217;s working.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">$ mvn clean test</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Congratulation you just finished your output component.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_components_for_a_rest_api"><a class="anchor" href="#_creating_components_for_a_rest_api"></a>Creating components for a REST API</h2>
<div class="sectionbody">
<div id="tutorial-create-components-rest-api" class="paragraph">
<p>This tutorial shows how to create components that consume a REST API.</p>
</div>
<div class="paragraph">
<p>The component developed as example in this tutorial is an input component that provides a search functionality for Zendesk using its <a href="https://developer.zendesk.com/rest_api/docs/core/search">Search API</a>.<br>
<a href="https://projectlombok.org/">Lombok</a> is used to avoid writing getter, setter and constructor methods.</p>
</div>
<div class="paragraph">
<p>You can generate a project using the Talend Components Kit starter, as described in
<a href="tutorial-generate-project-using-starter.html" class="xref page">this tutorial</a>.</p>
</div>
<div class="sect2">
<h3 id="_setting_up_the_http_client"><a class="anchor" href="#_setting_up_the_http_client"></a>Setting up the HTTP client</h3>
<div class="paragraph">
<p>The input component relies on Zendesk Search API and requires an HTTP client to consume it.</p>
</div>
<div class="paragraph">
<p>The Zendesk Search API takes the following parameters on the <code>/api/v2/search.json</code> endpoint.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>query</strong>     : The search query.</p>
</li>
<li>
<p><strong>sort_by</strong>   : The sorting type of the query result. Possible values are <code>updated_at</code>, <code>created_at</code>, <code>priority</code>, <code>status</code>, <code>ticket_type</code>, or <code>relevance</code>. It defaults to <code>relevance</code>.</p>
</li>
<li>
<p><strong>sort_order</strong>: The sorting order of the query result. Possible values are <code>asc</code> (for ascending) or <code>desc</code> (for descending). It defaults to <code>desc</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Talend Component Kit provides a built-in service to create an easy-to-use HTTP client in a declarative manner, using Java annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SearchClient extends HttpClient { <i class="conum" data-value="1"></i><b>(1)</b>

    @Request(path = "api/v2/search.json", method = "GET") <i class="conum" data-value="2"></i><b>(2)</b>
    Response&lt;JsonObject&gt; search(@Header("Authorization") String auth,<i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
            @Header("Content-Type") String contentType, <i class="conum" data-value="5"></i><b>(5)</b>
            @Query("query") String query, <i class="conum" data-value="6"></i><b>(6)</b>
            @Query("sort_by") String sortBy,
            @Query("sort_order") String sortOrder,
            @Query("page") Integer page
    );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The interface needs to extend <code>org.talend.sdk.component.api.service.http.HttpClient</code> to be recognized as an HTTP client by the component framework.
This interface also provides the <code>void base(String base)</code> method, that allows to set the base URI for the HTTP request. In this tutorial, it is the Zendesk instance URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@Request</code> annotation allows to define the HTTP request path and method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, and so on).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method return type and a header parameter are defined.<br>
The method return type is a JSON object: <code>Response&lt;JsonObject&gt;</code>. The <code>Response</code> object allows to access the HTTP response status code, headers, error payload and the response body that are of the <code>JsonObject</code> type in this case.<br>
The response body is decoded according to the content type returned by the API. The component framework provides the codec to decode JSON content.<br>
If you want to consume specific content types, you need to specify your custom codec using the <code>@Codec</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>Authorization</code> HTTP request header allows to provide the authorization token.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Another HTTP request header defined to provide the content type.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Query parameters are defined using the <code>@Query</code> annotation that provides the parameter name.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>No additional implementation is needed for the interface, as it is provided by the component framework, according to what is defined above.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This HTTP client can be injected into a mapper or a processor to perform HTTP requests.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_the_component"><a class="anchor" href="#_configuring_the_component"></a>Configuring the component</h3>
<div class="paragraph">
<p>This example uses the basic authentication that supported by the API.</p>
</div>
<div class="sect3">
<h4 id="_configuring_basic_authentication"><a class="anchor" href="#_configuring_basic_authentication"></a>Configuring basic authentication</h4>
<div class="paragraph">
<p>The first step is to set up the configuration for the basic authentication.
To be able to consume the Search API, the Zendesk instance URL, the username and the password are needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
@DataStore <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
        @GridLayout.Row({ "url" }),
        @GridLayout.Row({ "username", "password" })
})
@Documentation("Basic authentication for Zendesk API")
public class BasicAuth {

    @Option
    @Documentation("Zendesk instance url")
    private final String url;

    @Option
    @Documentation("Zendesk account username (e-mail).")
    private final String username;

    @Option
    @Credential <i class="conum" data-value="3"></i><b>(3)</b>
    @Documentation("Zendesk account password")
    private final String password;

    public String getAuthorizationHeader() { <i class="conum" data-value="4"></i><b>(4)</b>
        try {
            return "Basic " + Base64.getEncoder()
                    .encodeToString((this.getUsername() + ":" + this.getPassword()).getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This configuration class provides the authentication information. Type it as <code>Datastore</code> so that it can be validated using services (similar to connection test) and used by Talend Studio or web application metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@GridLayout</code> defines the UI layout of this configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The password is marked as <code>Credential</code> so that it is handled as sensitive data in Talend Studio and web applications. <a href="tutorial-configuration-sensitive-data.html" class="xref page">Read more about sensitive data handling</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This method generates a basic authentication token using the username and the password. This token is used to authenticate the HTTP call on the Search API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The data store is now configured. It provides a basic authentication token.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_the_dataset"><a class="anchor" href="#_configuring_the_dataset"></a>Configuring the dataset</h4>
<div class="paragraph">
<p>Once the data store is configured, you can define the dataset by configuring the search query. It is that query that defines the records processed by the input component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
@DataSet <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
        @GridLayout.Row({ "dataStore" }),
        @GridLayout.Row({ "query" }),
        @GridLayout.Row({ "sortBy", "sortOrder" })
})
@Documentation("Data set that defines a search query for Zendesk Search API. See API reference https://developer.zendesk.com/rest_api/docs/core/search")
public class SearchQuery {

    @Option
    @Documentation("Authentication information.")
    private final BasicAuth dataStore;

    @Option
    @TextArea <i class="conum" data-value="3"></i><b>(3)</b>
    @Documentation("Search query.") <i class="conum" data-value="4"></i><b>(4)</b>
    private final String query;

    @Option
    @DefaultValue("relevance") <i class="conum" data-value="5"></i><b>(5)</b>
    @Documentation("One of updated_at, created_at, priority, status, or ticket_type. Defaults to sorting by relevance")
    private final String sortBy;

    @Option
    @DefaultValue("desc")
    @Documentation("One of asc or desc. Defaults to desc")
    private final String sortOrder;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The configuration class is marked as a <code>DataSet</code>. <a href="component-configuration.html#dataset-and-datastore" class="xref page">Read more about configuration types</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@GridLayout</code> defines the UI layout of this configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A text area widget is bound to the <strong>Search query</strong> field. <a href="gallery.html" class="xref page">See all the available widgets</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>@Documentation</code> annotation is used to document the component (configuration in this scope).
A Talend Component Kit Maven plugin can be used to generate the component documentation with all the configuration description and the default values.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A default value is defined for sorting the query result.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your component is configured. You can now create the component logic.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_component_mapper"><a class="anchor" href="#_defining_the_component_mapper"></a>Defining the component mapper</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Mappers defined with this tutorial don&#8217;t implement the split part because HTTP calls are not split on many workers in this case.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version
@Icon(value = Icon.IconType.CUSTOM, custom = "zendesk")
@PartitionMapper(name = "search")
@Documentation("Search component for zendesk query")
public class SearchMapper implements Serializable {

    private final SearchQuery configuration; <i class="conum" data-value="1"></i><b>(1)</b>
    private final SearchClient searchClient; <i class="conum" data-value="2"></i><b>(2)</b>

    public SearchMapper(@Option("configuration") final SearchQuery configuration, final SearchClient searchClient) {
        this.configuration = configuration;
        this.searchClient = searchClient;
    }

    @PostConstruct
    public void init() {
        searchClient.base(configuration.getDataStore().getUrl()); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Assessor
    public long estimateSize() {
        return 1L;
    }

    @Split
    public List&lt;SearchMapper&gt; split(@PartitionSize final long bundles) {
        return Collections.singletonList(this); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Emitter
    public SearchSource createWorker() {
        return new SearchSource(configuration, searchClient); <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component configuration that is injected by the component framework</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The HTTP client created earlier in this tutorial. It is also injected by the framework via the mapper constructor.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The base URL of the HTTP client is defined using the configuration URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The mapper is returned in the split method because HTTP requests are not split.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A source is created to perform the HTTP request and return the search result.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_component_source"><a class="anchor" href="#_defining_the_component_source"></a>Defining the component source</h3>
<div class="paragraph">
<p>Once the component logic implemented, you can create the source in charge of performing the HTTP request to the search API and converting the result to <code>JsonObject</code> records.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchSource implements Serializable {

    private final SearchQuery config; <i class="conum" data-value="1"></i><b>(1)</b>
    private final SearchClient searchClient; <i class="conum" data-value="2"></i><b>(2)</b>
    private BufferizedProducerSupport&lt;JsonValue&gt; bufferedReader; <i class="conum" data-value="3"></i><b>(3)</b>

    private transient int page = 0;
    private transient int previousPage = -1;

    public SearchSource(final SearchQuery configuration, final SearchClient searchClient) {
        this.config = configuration;
        this.searchClient = searchClient;
    }

    @PostConstruct
    public void init() { <i class="conum" data-value="4"></i><b>(4)</b>
        bufferedReader = new BufferizedProducerSupport&lt;&gt;(() -&gt; {
            JsonObject result = null;
            if (previousPage == -1) {
                result = search(config.getDataStore().getAuthorizationHeader(),
                        config.getQuery(), config.getSortBy(),
                        config.getSortBy() == null ? null : config.getSortOrder(), null);
            } else if (previousPage != page) {
                result = search(config.getDataStore().getAuthorizationHeader(),
                        config.getQuery(), config.getSortBy(),
                        config.getSortBy() == null ? null : config.getSortOrder(), page);
            }
            if (result == null) {
                return null;
            }
            previousPage = page;
            String nextPage = result.getString("next_page", null);
            if (nextPage != null) {
                page++;
            }

            return result.getJsonArray("results").iterator();
        });
    }

    @Producer
    public JsonObject next() { <i class="conum" data-value="5"></i><b>(5)</b>
        final JsonValue next = bufferedReader.next();
        return next == null ? null : next.asJsonObject();
    }

    <i class="conum" data-value="6"></i><b>(6)</b>
    private JsonObject search(String auth, String query, String sortBy, String sortOrder, Integer page) {
        final Response&lt;JsonObject&gt; response = searchClient.search(auth, "application/json",
                query, sortBy, sortOrder, page);
        if (response.status() == 200 &amp;&amp; response.body().getInt("count") != 0) {
            return response.body();
        }

        final String mediaType = extractMediaType(response.headers());
        if (mediaType != null &amp;&amp; mediaType.contains("application/json")) {
            final JsonObject error = response.error(JsonObject.class);
            throw new RuntimeException(error.getString("error") + "\n" + error.getString("description"));
        }
        throw new RuntimeException(response.error(String.class));
    }

    <i class="conum" data-value="7"></i><b>(7)</b>
    private String extractMediaType(final Map&lt;String, List&lt;String&gt;&gt; headers) {
        final String contentType = headers == null || headers.isEmpty()
                || !headers.containsKey(HEADER_Content_Type) ? null :
                headers.get(HEADER_Content_Type).iterator().next();

        if (contentType == null || contentType.isEmpty()) {
            return null;
        }
        // content-type contains charset and/or boundary
        return ((contentType.contains(";")) ? contentType.split(";")[0] : contentType).toLowerCase(ROOT);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component configuration injected from the component mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The HTTP client injected from the component mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A utility used to buffer search results and iterate on them one after another.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The record buffer is initialized with the <code>init</code> by providing the logic to iterate on the search result. The logic consists in getting the first result page and converting the result into JSON records. The buffer then retrieves the next result page, if needed, and so on.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>next</code> method returns the next record from the buffer. When there is no record left, the buffer returns <code>null</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>In this method, the HTTP client is used to perform the HTTP request to the search API.<br>
Depending on the HTTP response status code, the results are retrieved or an error is thrown.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The <code>extractMediaType</code> method allows to extract the media type returned by the API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You now have created a simple Talend component that consumes a REST API.</p>
</div>
<div class="paragraph">
<p>To learn how to test this component, refer to <a href="tutorial-test-rest-api.html" class="xref page">this tutorial</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_a_rest_api"><a class="anchor" href="#_testing_a_rest_api"></a>Testing a REST API</h2>
<div class="sectionbody">
<div id="tutorial-test-rest-api" class="paragraph">
<p>Testing code that consumes REST APIs can sometimes present many constraints: API rate limit, authentication token and password sharing, API availability, sandbox expiration, API costs, and so on.</p>
</div>
<div class="paragraph">
<p>As a developer, it becomes critical to avoid those constraints and to be able to easily mock the API response.</p>
</div>
<div class="paragraph">
<p>The component framework provides an API simulation tool that makes it easy to write unit tests.</p>
</div>
<div class="paragraph">
<p>This tutorial shows how to use this tool in unit tests.
As a starting point, the tutorial uses the component that consumes Zendesk Search API and that was created in <a href="tutorial-create-components-rest-api.html" class="xref page">a previous tutorial</a>. The goal is to add unit tests for it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For this tutorial, four <strong>tickets</strong> that have the <strong>open</strong> status have been added to the Zendesk test instance used in the tests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To learn more about the testing methodology used in this tutorial, refer to <a href="testing-junit.html#_junit_4" class="xref page">Component JUnit testing</a>.</p>
</div>
<div class="sect2">
<h3 id="_creating_the_unit_test"><a class="anchor" href="#_creating_the_unit_test"></a>Creating the unit test</h3>
<div class="paragraph">
<p>Create a unit test that performs a real HTTP request to the Zendesk Search API instance.
You can learn how to create a simple unit test in <a href="tutorial-test-your-components.html" class="xref page">this tutorial</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    @Test
    public void searchQuery() {
        // Initiating the component test configuration <i class="conum" data-value="1"></i><b>(1)</b>
        BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com", "username", "password");
        final SearchQuery searchQuery = new SearchQuery(basicAuth, "type:ticket status:open", "created_at", "desc");

        // We convert our configuration instance to URI configuration <i class="conum" data-value="2"></i><b>(2)</b>
        final String uriConfig = SimpleFactory.configurationByExample()
                        .forInstance(searchQuery)
                        .configured().toQueryString();

        // We create our job test pipeline <i class="conum" data-value="3"></i><b>(3)</b>
        Job.components()
                .component("search", "zendesk://search?" + uriConfig)
                .component("collector", "test://collector")
                .connections()
                .from("search").to("collector")
                .build()
                .run();

        final List&lt;JsonObject&gt; res = component.getCollectedData(JsonObject.class);
        assertEquals(4, res.size());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initiating:
<div class="ulist">
<ul>
<li>
<p>the authentication configuration using Zendesk instance URL and credentials.</p>
</li>
<li>
<p>the search query configuration to get all the open ticket, ordered by creation date and sorted in descending order.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Converting the configuration to a URI format that will be used in the job test pipeline,
using the <code>SimpleFactory</code> class provided by the component framework. <a href="services-pipeline.html#_job_builder" class="xref page">Read more about job pipeline</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating the job test pipeline. The pipeline executes the <code>search</code> component and redirects the result to the test <code>collector</code> component, that collects the search result.
The pipeline is then executed.
Finally, the job result is retrieved to check that the four tickets have been received. You can also check that the tickets have the <code>open</code> status.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The test is now complete and working. It performs a real HTTP request to the Zendesk instance.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transforming_the_unit_test_into_a_mocked_test"><a class="anchor" href="#_transforming_the_unit_test_into_a_mocked_test"></a>Transforming the unit test into a mocked test</h3>
<div class="paragraph">
<p>As an alternative, you can use mock results to avoid performing HTTP requests every time on the development environment. The real HTTP requests would, for example, only be performed on an integration environment.</p>
</div>
<div class="paragraph">
<p>To transform the unit test into a mocked test that uses a mocked response of the Zendesk Search API:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the two following JUnit rules provided by the component framework.</p>
<div class="ulist">
<ul>
<li>
<p><code>JUnit4HttpApi</code>: This rule starts a simulation server that acts as a proxy and catches all the HTTP requests performed in the tests.
This simulation server has two modes :</p>
<div class="ulist">
<ul>
<li>
<p><strong>capture</strong>    : This mode forwards the captured HTTP request to the real server and captures the response.</p>
</li>
<li>
<p><strong>simulation</strong> : this mode returns a mocked response from the responses already captured. This rule needs to be added as a class rule.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>JUnit4HttpApi</code>: This rule has a reference to the first rule. Its role is to configure the simulation server for every unit test. It passes the context of the running test to the simulation server. This rule needs to be added as a simple (method) rule.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Example to run in a simulation mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    private final MavenDecrypter mavenDecrypter = new MavenDecrypter();

    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi() <i class="conum" data-value="1"></i><b>(1)</b>
                                                        .activeSsl(); <i class="conum" data-value="2"></i><b>(2)</b>

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API); <i class="conum" data-value="3"></i><b>(3)</b>

    @Test
    public void searchQuery() {
        // the exact same code as above
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creating and starting a simulation server for this test class.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Activating SSL on the simulation server by calling the <code>activeSsl()</code> method. This step is required because the consumed API uses SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding the simulation server configuration provider that provides the test context to the simulation server.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Make the test run in <strong>capture</strong> mode to catch the real API responses that can be used later in the simulated mode.<br>
To do that, set a new <code>talend.junit.http.capture</code> environment variable to <code>true</code>.
This tells the simulation server to run in a capture mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The captured response is saved in the <code>resources/talend.testing.http</code> package in a JSON format, then reused to perform the API simulation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_a_component"><a class="anchor" href="#_testing_a_component"></a>Testing a component</h2>
<div class="sectionbody">
<div id="tutorial-test-your-components" class="paragraph">
<p>This tutorial focuses on writing unit tests for the input component that was created in this <a href="tutorial-create-an-input-component.html" class="xref page">previous tutorial</a>.</p>
</div>
<div class="paragraph">
<p>This tutorial covers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>How to load components in a unit test.</p>
</li>
<li>
<p>How to create a job pipeline.</p>
</li>
<li>
<p>How to run the test in standalone mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The test class is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HazelcastMapperTest {

    @ClassRule
    public static final SimpleComponentRule COMPONENTS = new SimpleComponentRule(HazelcastMapperTest.class
                                                                                    .getPackage().getName()); <i class="conum" data-value="1"></i><b>(1)</b>

    private static HazelcastInstance instance; <i class="conum" data-value="2"></i><b>(2)</b>

    @BeforeClass
    public static void startInstanceWithData() { <i class="conum" data-value="3"></i><b>(3)</b>
        instance = Hazelcast.newHazelcastInstance();
        final IMap&lt;Object, Object&gt; map = instance.getMap(HazelcastMapperTest.class.getSimpleName());
        IntStream.range(0, 100).forEach(i -&gt; map.put("test_" + i, "value #" + i));
    }

    @AfterClass
    public static void stopInstance() { <i class="conum" data-value="4"></i><b>(4)</b>
        instance.getLifecycleService().shutdown();
    }

    @Test
    public void run() { <i class="conum" data-value="5"></i><b>(5)</b>
        Job.components() <i class="conum" data-value="6"></i><b>(6)</b>
                .component("source", "Hazelcast://Input?configuration.mapName=" + HazelcastMapperTest.class.getSimpleName())
                .component("output", "test://collector")
            .connections()
                .from("source").to("output")
            .build()
            .run();

        final List&lt;JsonObject&gt; outputs = COMPONENTS.getCollectedData(JsonObject.class); <i class="conum" data-value="7"></i><b>(7)</b>
        assertEquals(100, outputs.size());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SimpleComponentRule</code> is a JUnit rule that lets you load your component from a package. This rule also provides some test components like <code>emitter</code> and <code>collector</code>. Learn more about JUnit in <a href="testing-junit.html#_component_runtime_junit" class="xref page">this section</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using an embedded Hazelcast instance to test the input component.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating an embedded Hazelcast instance and filling it with some test data. A map with the name of the test class is created and data is added to it.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Cleaning up the instance after the end of the tests.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Defining the unit test. It first creates a job pipeline that uses our input component.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <a href="services-pipeline.html" class="xref page">pipeline builder</a> <code>Job</code> is used to create a job. It contains two components: the input component and the test collector component. The input component is connected to the collector component. Then the job is built and ran locally.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>After the job has finished running. The <code>COMPONENTS</code> rule instance is used to get the collected data from the <code>collector</code> component.
Once this is done, it is possible to do some assertion on the collected data.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_in_a_continuous_integration_environment"><a class="anchor" href="#_testing_in_a_continuous_integration_environment"></a>Testing in a Continuous Integration environment</h2>
<div class="sectionbody">
<div id="tutorial-dev-vs-ci-setup.adoc" class="paragraph">
<p>This tutorial shows how to adapt the test configuration of the Zendesk search component that was done in <a href="tutorial-test-rest-api.html" class="xref page">this previous tutorial</a> to make it work in a Continuous Integration environment.</p>
</div>
<div class="paragraph">
<p>In the test, the Zendesk credentials are used directly in the code to perform a first capture of the API response. Then, fake credentials are used in the simulation mode because the real API is not called anymore.</p>
</div>
<div class="paragraph">
<p>However, in some cases, you can require to continue calling the real API on a CI server or on a specific environment.</p>
</div>
<div class="paragraph">
<p>To do that, you can adapt the test to get the credentials depending on the execution mode (simulation/passthrough).</p>
</div>
<div class="sect2">
<h3 id="_setting_up_credentials"><a class="anchor" href="#_setting_up_credentials"></a>Setting up credentials</h3>
<div class="paragraph">
<p>These instructions concern the CI server or on any environment that requires real credentials.</p>
</div>
<div class="paragraph">
<p>This tutorial uses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="https://maven.apache.org/guides/mini/guide-encryption.html">Maven server</a> that supports password encryption as a credential provider. Encryption is optional but recommended.</p>
</li>
<li>
<p>The <code>MavenDecrypterRule</code> test rule provided by the framework. This rule lets you get credentials from Maven settings using a server ID.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To create encrypted server credentials for the Zendesk instance:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a master password using the command: <code>mvn --encrypt-master-password &lt;password&gt;</code>.</p>
</li>
<li>
<p>Store this master password in the <code>settings-security.xml</code> file of the <code>~/.m2</code> folder.</p>
</li>
<li>
<p>Encrypt the Zendesk instance password using the command: <code>mvn --encrypt-password &lt;zendesk-password&gt;</code>.</p>
</li>
<li>
<p>Create a server entry under <strong>servers</strong> in Maven <code>settings.xml</code> file located in the <code>~/.m2</code> folder.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;server&gt;
  &lt;id&gt;zendesk&lt;/id&gt;
  &lt;username&gt;username@email.com&lt;/username&gt;
  &lt;password&gt;The encrypted password {oL37x/xiSvwtlhrMQ=}&lt;/password&gt;
&lt;/server&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can store the <code>settings-security.xml</code> and <code>settings.xml</code> files elsewhere that the default location (<code>~/.m2</code>). To do that, set the path of the directory containing the files
in the <code>talend.maven.decrypter.m2.location</code> environment variable.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_adapting_the_unit_test"><a class="anchor" href="#_adapting_the_unit_test"></a>Adapting the unit test</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the <code>MavenDecrypterRule</code> rule to the test class. This rule allows to inject server information stored in Maven <code>settings.xml</code> file to the test. The rule also decrypts credentials if they are encrypted.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Inject the Zendesk server to the test. To do that, add a new field to the class with the <code>@DecryptedServer</code> annotation, that holds the server ID to be injected.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);

    @DecryptedServer("zendesk")
    private Server server;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MavenDecrypterRule</code> is able to inject the server instance into this class at runtime. The server instance contains the username and the decrypted password.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Use the <code>server</code> instance in the test to get the real credentials in a secured manner.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com",
                            server.getUsername(),
                            server.getPassword());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once modified, the complete test class looks as follows:</p>
</div>
<div class="listingblock initial-block-closed">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    private final MavenDecrypter mavenDecrypter = new MavenDecrypter();

    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi()
                                                        .activeSsl();

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);

    @DecryptedServer("zendesk")
    private Server server;

    @Test
    public void searchQuery() {
        // Initiating the component test configuration
        BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com", server.getUsername(), server.getPassword());
        final SearchQuery searchQuery = new SearchQuery(basicAuth, "type:ticket status:open", "created_at", "desc");

        // We convert our configuration instance to URI configuration
        final String uriConfig = SimpleFactory.configurationByExample()
                        .forInstance(searchQuery)
                        .configured().toQueryString();

        // We create our job test pipeline
        Job.components()
                .component("search", "zendesk://search?" + uriConfig)
                .component("collector", "test://collector")
                .connections()
                .from("search").to("collector")
                .build()
                .run();

        final List&lt;JsonObject&gt; res = component.getCollectedData(JsonObject.class);
        assertEquals(4, res.size());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>This test will continue to work in simulation mode</strong>, because the API simulation proxy is activated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up_the_ci_server_in_passthrough_mode"><a class="anchor" href="#_setting_up_the_ci_server_in_passthrough_mode"></a>Setting up the CI server in passthrough mode</h3>
<div class="paragraph">
<p>This tutorial shows how to set up a CI server in passthrough mode using <a href="https://jenkins.io/">Jenkins</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Log in to Jenkins.</p>
</li>
<li>
<p>Click <strong>New Item</strong> to create a new build job.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/jenkins/1_jenkins_new_item.png" target="_blank" rel="noopener"><img src="_images/jenkins/1_jenkins_new_item.png" alt="Create a new job"></a>
</div>
</div>
</li>
<li>
<p>Enter an Item name (Job name) and choose the freestyle job. Then click OK.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/jenkins/2_jenkins_new_item.png" target="_blank" rel="noopener"><img src="_images/jenkins/2_jenkins_new_item.png" alt="Create a new job"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Source Code Management</strong> section, enter your project repository URL. A GitHub repository is used in this tutorial.</p>
</li>
<li>
<p>Specify the <code>master</code> branch as <strong>Branches to build</strong>.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/jenkins/4_jenkins_source_code.png" target="_blank" rel="noopener"><img src="_images/jenkins/4_jenkins_source_code.png" alt="Source Code Management"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Build</strong> section, click <strong>Add build step</strong> and choose <strong>Invoke top-level Maven targets</strong>.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/jenkins/6_jenkins_build_cmd.png" target="_blank" rel="noopener"><img src="_images/jenkins/6_jenkins_build_cmd.png" alt="Build Section"></a>
</div>
</div>
</li>
<li>
<p>Choose your Maven version and enter the Maven build command. In this case: <code>clean install</code>. Then, click <strong>Save</strong>.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/jenkins/6_jenkins_build_cmd_2.png" target="_blank" rel="noopener"><img src="_images/jenkins/6_jenkins_build_cmd_2.png" alt="Build Section"></a>
</div>
</div>
<div class="paragraph">
<p>The <code>-Dtalend.junit.http.passthrough=true</code> option is part of the build command.
This option tells the API simulation proxy to run in <code>passthrough</code> mode. This way, all the HTTP requests made in the test are forwarded to the real API server.</p>
</div>
<div class="paragraph">
<p>The <code>MavenDecrypterRule</code> rule allows to get the real credentials.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can configure the <strong>passthrough</strong> mode globally on your CI server by setting the <code>talend.junit.http.passthrough</code> environment variable to <code>true</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Test the job by selecting <strong>Build now</strong>, and check that the job has built correctly.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.14/_images/jenkins/7_jenkins_build_result.png" target="_blank" rel="noopener"><img src="_images/jenkins/7_jenkins_build_result.png" alt="Test the job"></a>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now your tests run in a simulation mode on your development environment and in a passthrough mode on your CI server.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_component_version_migration"><a class="anchor" href="#_handling_component_version_migration"></a>Handling component version migration</h2>
<div class="sectionbody">
<div id="tutorial-handle-talend-component-migration" class="paragraph">
<p>Talend Component Kit provides a migration mechanism between two versions of a component to let you ensure backward compatibility.</p>
</div>
<div class="paragraph">
<p>For example, a new version of a component may have some new options that need to be remapped, set with a default value in the older versions, or disabled.</p>
</div>
<div class="paragraph">
<p>This tutorial shows how to create a migration handler for a component that needs to be upgraded from a version 1 to a version 2. The upgrade to the newer version includes adding new options to the component.</p>
</div>
<div class="paragraph">
<p>This tutorial assumes that you know <a href="methodology-creating-components.html" class="xref page">the basics</a> about component development and are familiar with component project <a href="index-generating-project.html" class="xref page">generation</a> and <a href="index-creating-components.html" class="xref page">implementation</a>.</p>
</div>
<div class="sect2">
<h3 id="_requirements"><a class="anchor" href="#_requirements"></a>Requirements</h3>
<div class="paragraph">
<p>To follow this tutorial, you need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 8</p>
</li>
<li>
<p>A Talend component development environment using Talend Component Kit. Refer to <a href="system-prerequisites.html" class="xref page">this document</a>.</p>
</li>
<li>
<p>Have generated a project containing a simple processor component using the Talend Component Kit Starter.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creating_the_version_1_of_the_component"><a class="anchor" href="#_creating_the_version_1_of_the_component"></a>Creating the version 1 of the component</h3>
<div class="paragraph">
<p>First, create a simple processor component configured as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a simple configuration class that represents a basic authentication and that can be used in any component requiring this kind of authentication.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
        @GridLayout.Row({ "username", "password" })
})
public class BasicAuth {

    @Option
    @Documentation("username to authenticate")
    private String username;

    @Option
    @Credential
    @Documentation("user password")
    private String password;
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Create a simple output component that uses the configuration defined earlier. The component configuration is injected into the component constructor.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(1)
@Icon(Icon.IconType.DEFAULT)
@Processor(name = "MyOutput")
@Documentation("A simple output component")
public class MyOutput implements Serializable {

    private final BasicAuth configuration;

    public MyOutput(@Option("configuration") final BasicAuth configuration) {
        this.configuration = configuration;
    }

    @ElementListener
    public void onNext(@Input final JsonObject record) {
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The version of the configuration class corresponds to the component version.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>By configuring these two classes, the first version of the component is ready to use a simple authentication mechanism.</p>
</div>
<div class="paragraph">
<p>Now, assuming that the component needs to support a new authentication mode following a new requirement, the next steps are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creating a version 2 of the component that supports the new authentication mode.</p>
</li>
<li>
<p>Handling migration from the first version to the new version.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creating_the_version_2_of_the_component"><a class="anchor" href="#_creating_the_version_2_of_the_component"></a>Creating the version 2 of the component</h3>
<div class="paragraph">
<p>The second version of the component needs to support a new authentication method and let the user choose the authentication mode he wants to use using a dropdown list.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add an Oauth2 authentication mode to the component in addition to the basic mode. For example:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
        @GridLayout.Row({ "clientId", "clientSecret" })
})
public class Oauth2 {

    @Option
    @Documentation("client id to authenticate")
    private String clientId;

    @Option
    @Credential
    @Documentation("client secret token")
    private String clientSecret;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The options of the new authentication mode are now defined.</p>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Wrap the configuration created above in a global configuration with the basic authentication mode and add an enumeration to let the user choose the mode to use. For example, create an <code>AuthenticationConfiguration</code> class as follows:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
        @GridLayout.Row({ "authenticationMode" }),
        @GridLayout.Row({ "basic" }),
        @GridLayout.Row({ "oauth2" })
})
public class AuthenticationConfiguration {

    @Option
    @Documentation("the authentication mode")
    private AuthMode authenticationMode = AuthMode.Oauth2; // we set the default value to the new mode

    @Option
    @ActiveIf(target = "authenticationMode", value = {"Basic"})
    @Documentation("basic authentication")
    private BasicAuth basic;

    @Option
    @ActiveIf(target = "authenticationMode", value = {"Oauth2"})
    @Documentation("oauth2 authentication")
    private Oauth2 oauth2;


    /**
    * This enum holds the authentication mode supported by this configuration
    */
    public enum AuthMode {
        Basic,
        Oauth2;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Using the <code>@ActiveIf</code> annotation allows to activate the authentication type according to the selected authentication mode.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Edit the component to use the new configuration that supports an additional authentication mode.
Also upgrade the component version from 1 to 2 as its configuration has changed.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(2) // upgrade the component version
@Icon(Icon.IconType.DEFAULT)
@Processor(name = "MyOutput")
@Documentation("A simple output component")
public class MyOutput implements Serializable {

    private final AuthenticationConfiguration configuration; // use the new configuration

    public MyOutput(@Option("configuration") final AuthenticationConfiguration configuration) {
        this.configuration = configuration;
    }

    @ElementListener
    public void onNext(@Input final JsonObject record) {
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The component now supports two authentication modes in its version 2.
Once the new version is ready, you can implement the migration handler that will take care of adapting the old configuration to the new one.</p>
</div>
</div>
<div class="sect2">
<h3 id="_handling_the_migration_from_the_version_1_to_the_version_2"><a class="anchor" href="#_handling_the_migration_from_the_version_1_to_the_version_2"></a>Handling the migration from the version 1 to the version 2</h3>
<div class="paragraph">
<p><strong>What can happen if an old configuration is passed to the new component version?</strong></p>
</div>
<div class="paragraph">
<p>It simply fails, as the version 2 does not recognize the old version anymore.
For that reason, a migration handler that adapts the old configuration to the new one is required.
It can be achieved by defining a migration handler class in the <code>@Version</code> annotation of the component class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An old configuration may already be persisted by an application that integrates the version 1 of the component (Studio or web application).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declaring_the_migration_handler"><a class="anchor" href="#_declaring_the_migration_handler"></a>Declaring the migration handler</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add a migration handler class to the component version.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(value = 2, migrationHandler = MyOutputMigrationHandler.class)</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Create the migration handler class <code>MyOutputMigrationHandler</code>.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyOutputMigrationHandler implements MigrationHandler{ <i class="conum" data-value="1"></i><b>(1)</b>

       @Override
       public Map&lt;String, String&gt; migrate(final int incomingVersion, final Map&lt;String, String&gt; incomingData) { <i class="conum" data-value="2"></i><b>(2)</b>
           // Here we will implement our migration logic to adapt the version 1 of the component to the version 2
           return incomingData;
       }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The migration handler class needs to implement the <code>MigrationHandler</code> interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MigrationHandler</code> interface specifies the <code>migrate</code> method. This method references:<br>
<div class="ulist">
<ul>
<li>
<p>the incoming version, which is the version of the configuration that we are migrating from</p>
</li>
<li>
<p>a map (key, value) of the configuration, where the key is the configuration path and the value is the value of the configuration.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_the_migration_handler"><a class="anchor" href="#_implementing_the_migration_handler"></a>Implementing the migration handler</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You need to be familiar with the component configuration path construction to better understand this part.
Refer to <a href="component-configuration.html" class="xref page">Defining component layout and configuration</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As a reminder, the following changes were made since the version 1 of the component:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The configuration <code>BasicAuth</code> from the version 1 is not the root configuration anymore, as it is under <code>AuthenticationConfiguration</code>.</p>
</li>
<li>
<p><code>AuthenticationConfiguration</code> is the new root configuration.</p>
</li>
<li>
<p>The component supports a new authentication mode (Oauth2) which is the default mode in the version 2 of the component.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To migrate the old component version to the new version and to keep backward compatibility, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remap the old configuration to the new one.</p>
</li>
<li>
<p>Give the adequate default values to some options.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the case of this scenario, it means making all configurations based on the version 1 of the component have the <code>authenticationMode</code> set to basic by default and remapping the old basic authentication configuration to the new one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyOutputMigrationHandler implements MigrationHandler{

       @Override
       public Map&lt;String, String&gt; migrate(final int incomingVersion, final Map&lt;String, String&gt; incomingData) {
           if(incomingVersion == 1){ <i class="conum" data-value="1"></i><b>(1)</b>
               // remapping the old configuration <i class="conum" data-value="2"></i><b>(2)</b>
               String userName = incomingData.get("configuration.username");
               String password = incomingData.get("configuration.password");
               incomingData.put("configuration.basic.username", userName);
               incomingData.put("configuration.basic.password", password);

               // setting default value for authenticationMode to Basic <i class="conum" data-value="3"></i><b>(3)</b>
               incomingData.put("configuration.authenticationMode", "Basic");
           }

           return incomingData; <i class="conum" data-value="4"></i><b>(4)</b>
       }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Safety check of the incoming data version to make sure to only apply the migration logic to the version 1.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Mapping the old configuration to the new version structure. As the <code>BasicAuth</code> is now under the root configuration class, its path changes and becomes <code>configuration.basic.*</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Setting a new default value to the <code>authenticationMode</code> as it needs to be set to <code>Basic</code> for configuration coming from version 1.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Returning the new configuration data.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
if a configuration has been renamed between 2 component versions, you can get the old configuration option from the configuration map by using its old path and set its value using its new path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can now upgrade your component without losing backward compatibility.</p>
</div>
</div>
</div>
</div>
</div>
            </div>
          </div>
          <div class="col-sm-3 container article-side-panel">
            <nav class="article-anchors">
              <div class="article-side-actions">

                <ul>
                    <li>
                      <a class="article-side-actions-link" target="_blank" href="https://github.com/Talend/component-runtime/blob/component-runtime-1.1.14/documentation/src/main/antora/modules/ROOT/pages/pdf-tutorials.adoc">
                        <i class="fa fa-edit"></i> &nbsp; &nbsp; Suggest an edit
                      </a>
                    </li>

                    <li>
                                <a class="article-side-actions-link" target="_blank"
                                   href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2Flatest%2Fpdf-tutorials.html&text=Talend%20Component%20Kit%20%3E%3E%20Tutorials%20%3E%3E%20&tw_p=tweetbutton&url=https%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2Flatest%2Fpdf-tutorials.html">
                                    <i class="fab fa-twitter"></i> &nbsp; &nbsp; Tweet
                                </a>
                            </li>
                            <li>
                                <a class="article-side-actions-link"
                                   href="mailto:?subject=Talend%20Component%20Kit%3A%20Tutorials&body=Talend%20Component%20Kit%3A%20Tutorials%0A%0Ahttps%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2Flatest%2Fpdf-tutorials.html">
                                    <i class="far fa-envelope"></i> &nbsp; &nbsp; Mail
                                </a>
                            </li>

                </ul>
              </div>
              <h1 class="article-side-toc">In this article</h1>
            </nav>
          </div>
          <a href="#top" class="top">Scroll to top</a>
        </div>
        <script>(window.talend = (window.talend || {})).article = true;</script>
    </article>
              </div>
            </main>
      <footer class="footer ">
    <div class="footer-with-copyright footer-with-links">
        <ul class="footer-links pull-left">
            <li><a class="gwt-Anchor" href="http://www.talend.com/">Talend</a></li>
            <li><a class="gwt-Anchor" href="http://www.talend.com/contact">Contact</a></li>
            <li><a class="gwt-Anchor" href="http://www.talend.com/legal-terms/us-eula">Talend EULA</a></li>
        </ul>
        <div class="footer-copyright pull-right" style="">&copy; 2019 Talend Inc. All rights reserved.</div>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchorific/1.2/min/anchorific.min.js" integrity="sha384-ACUAcVkJ3XBvxLPJQqN8h9BfzCtcyqiQoemYyYiS7JJLg9O6aVOVzRYLwqxM2d7/" crossorigin="anonymous"></script>
<script src="../../_/js/talend.js"></script>
  </body>
</html>
