<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talend Component Kit Developer Reference Guide :: Talend Component Kit Developer Guide</title>
    <link rel="canonical" href="https://talend.github.io/component-runtime/main/1.1.28/all-in-one.html">
    <meta name="generator" content="Talend Component Kit Generator">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Talend Component Kit Developer Guide :: Talend Component Kit Developer Reference Guide</title>
    <link rel="canonical" href="https://talend.github.io/component-runtime/main/1.1.28/all-in-one.html">
    <meta name="generator" content="Antora 2.2.0">
<meta name="date" content="2020-12-18T11:39:35.384Z" scheme="YYYY-MM-DDTHH:mm:ss.sssZ">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css" integrity="sha256-NuCn4IvuZXdBaFKJOAcsU2Q3ZpwbdFisd5dux4jkQ5w=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css" integrity="sha256-rD61BPsgKHzJPyg7vpXaYOw6tMYuY2fz1p9033NYeM8=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css" integrity="sha384-lKuwvrZot6UHsBSfcMvOkWwlCMgc0TaWr+30HWe3a4ltaBwTZhyTEggF5tJv8tbt" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@talend/bootstrap-theme@0.200.1/dist/bootstrap.css">
<link rel="stylesheet" href="../../_/css/talend.css">
<link rel="shortcut icon" href="../../_/images/favicon_0.ico" />


<script type="text/x-mathjax-config">
                MathJax.Hub.Config({
                  messageStyle: "none",
                  tex2jax: {
                    inlineMath: [["\\(", "\\)"]],
                    displayMath: [["\\[", "\\]"]],
                    ignoreClass: "nostem|nolatexmath"
                  },
                  asciimath2jax: {
                    delimiters: [["\\$", "\\$"]],
                    ignoreClass: "nostem|noasciimath"
                  },
                  TeX: { equationNumbers: { autoNumber: "none" } }
                });
                </script>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-PSBN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-PSBN')</script>
  </head>
  <body>
      <svg xmlns="http://www.w3.org/2000/svg" focusable="false" style="display: none;">
    <symbol id="talend-logo-square">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
            <path fill="#FFF" d="M8,5.32907052e-14 C12.4182648,5.32907052e-14 16,3.58173516 16,8 C16,12.4188737 12.4182648,16.0006088 8,16.0006088 C3.58173516,16.0006088 0,12.4188737 0,8 C0,3.58173516 3.58173516,5.32907052e-14 8,5.32907052e-14 Z M7.86070588,3.63987227 C7.41418487,4.67207395 6.53747899,5.46891429 5.4532437,5.80834286 C5.4532437,5.80834286 5.23179832,5.86098151 5.28867227,6.09271261 C5.29532773,6.11267899 5.30137815,6.13264538 5.31105882,6.15261176 C5.34191597,6.21735126 5.37942857,6.25062857 5.42359664,6.25607395 L6.13391597,6.25607395 L6.13391597,10.6517042 C6.13391597,11.2755025 6.32329412,11.7117378 6.70205042,11.959805 C7.08020168,12.2072672 7.58843697,12.3306958 8.22554622,12.3306958 C8.42521008,12.3306958 8.65633613,12.2937882 8.91952941,12.218763 C9.18272269,12.1431328 9.43078992,12.0469311 9.66312605,11.9295529 C9.89606723,11.8127798 10.0672941,11.6941916 10.1780168,11.5737882 C10.2046387,11.5568471 10.2046387,11.5090487 10.1780168,11.4316034 C10.151395,11.354158 10.1138824,11.282158 10.0648739,11.2162084 C10.0164706,11.1496538 9.97895798,11.1230319 9.95233613,11.1363429 C9.78413445,11.2198387 9.60020168,11.2912336 9.40114286,11.3487126 C9.20208403,11.4061916 9.02904202,11.4352336 8.88322689,11.4352336 C8.7192605,11.4352336 8.59401681,11.397721 8.50810084,11.325721 C8.42157983,11.2525109 8.35986555,11.1169815 8.32235294,10.9203429 C8.28423529,10.7237042 8.26547899,10.4363092 8.26547899,10.0599731 L8.26547899,6.24276303 L9.69337815,6.24276303 C9.74178151,6.24276303 9.78715966,6.19617479 9.82951261,6.10239328 C9.8712605,6.01042689 9.89243697,5.89546891 9.89243697,5.75812437 C9.89243697,5.70004034 9.87791597,5.64861176 9.84887395,5.60504874 C9.82043697,5.56088067 9.78171429,5.53667899 9.73331092,5.5324437 L8.26547899,5.5324437 L8.26547899,3.6792 C8.26547899,3.60235966 8.21465546,3.54790588 8.1245042,3.51099832 C7.95811765,3.45896471 7.86070588,3.63987227 7.86070588,3.63987227 Z"</path>
        </svg>
    </symbol>
    <symbol id="talend-component-kit-positive">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
            <g fill="none">
                <path fill="#005695" d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path>
                <path fill="#FFF" d="M5.69 10.662a2.3 2.3 0 0 0 1.425.492 2.3 2.3 0 0 0 1.664-.709l-.631-.632 1.005-1.005a.33.33 0 0 0 0-.466.332.332 0 0 0-.467 0L7.68 9.347 6.633 8.3l1.005-1.005a.33.33 0 0 0-.467-.466L6.167 7.832l-.653-.652a2.3 2.3 0 0 0-.71 1.664c0 .54.187 1.037.498 1.43L3.878 11.7a.721.721 0 0 0-.358.027 5.824 5.824 0 0 1-.722-6.368c1.364-2.7 4.612-3.914 7.41-2.777l-.348.69 1.584-.369-.643-1.495-.351.695C7.384.832 3.818 2.15 2.32 5.117a6.359 6.359 0 0 0 .798 6.962.704.704 0 0 0 1.26.631.704.704 0 0 0-.036-.699l1.349-1.349z"></path>
                <path fill="#FFF" d="M12.623 3.031a.706.706 0 0 0-.973.894l-1.296 1.298a2.304 2.304 0 0 0-3.092.215l3.266 3.265a2.304 2.304 0 0 0 .213-3.092l1.299-1.297a.701.701 0 0 0 .504.006 5.838 5.838 0 0 1 .675 6.311c-1.332 2.636-4.524 3.871-7.284 2.826l.339-.67-1.585.368.643 1.494.36-.712c3.028 1.18 6.538-.162 8.005-3.064a6.375 6.375 0 0 0-.758-6.912.703.703 0 0 0-.316-.93z"></path>
            </g>
        </svg>
    </symbol>
</svg>

<header class="global-header">
  <nav class="navbar navbar-default">
      <div class="navbar-text-content nav navbar-nav">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <button aria-label="Go to Portal" id="header-talend-logo" type="button" class="btn-icon-only btn btn-link">
            <svg name="talend-logo-square" focusable="false" aria-hidden="true">
                <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#talend-logo-square"></use>
            </svg>
        </button>
        <button aria-label="Kit logo" id="header-kit-logo" type="button" class="btn-icon-only btn btn-link">
          <svg name="talend-component-kit-positive" focusable="false" aria-hidden="true">
            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#talend-component-kit-positive"></use>
          </svg>
        </button>
        <a class="navbar-single-link" href="index.html">Talend Component Kit</a>
        <div class="btn-group navbar-versions">
          <button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                1.1.28 (dev)
              <span class="caret"></span>
          </button>
          <ul class="dropdown-menu">
                <li class="navbar-item version">
                    <a href="index.html">1.1.28</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.27/index.html">1.1.27</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.26/index.html">1.1.26</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.25/index.html">1.1.25</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.24/index.html">1.1.24</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.23/index.html">1.1.23</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.22/index.html">1.1.22</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.21/index.html">1.1.21</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.20/index.html">1.1.20</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.19/index.html">1.1.19</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.18/index.html">1.1.18</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.17/index.html">1.1.17</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.16/index.html">1.1.16</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.15/index.html">1.1.15</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.14/index.html">1.1.14</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.13/index.html">1.1.13</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.12/index.html">1.1.12</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.11/index.html">1.1.11</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.10/index.html">1.1.10</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.9/index.html">1.1.9</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.8/index.html">1.1.8</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.7/index.html">1.1.7</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.6/index.html">1.1.6</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.5/index.html">1.1.5</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.4/index.html">1.1.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.3/index.html">1.1.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.2/index.html">1.1.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.1/index.html">1.1.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.1.0/index.html">1.1.0</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.4/index.html">1.0.4</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.3/index.html">1.0.3</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.2/index.html">1.0.2</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.1/index.html">1.0.1</a>
                </li>
                <li class="navbar-item version">
                    <a href="../1.0.0/index.html">1.0.0</a>
                </li>
          </ul>
        </div>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul class="nav navbar-nav navbar-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Blog <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a class="navbar-item" href="https://talend.github.io/component-runtime/blog/release-notes.html" target="_blank">Release Notes</a></li>
            </ul>
          </li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Community <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li><a class="navbar-item" href="https://github.com/talend/component-runtime" target="_blank">GitHub Repository</a></li>
              <li><a class="navbar-item" href="contributors.html">Contributors</a></li>
              <li><a class="navbar-item" href="https://community.talend.com/t5/Component-Development/bd-p/ComponentDevelopment" target="_blank">Forum</a></li>
              <li><a class="navbar-item" href="https://help.talend.com/" target="_blank">Talend Help Center</a></li>
            </ul>
          </li>
        </ul>
        <form role="search" action="search.html" class="navbar-form navbar-right">
          <div class="input-group">
            <span class="input-group-addon"><i class="fa fa-search"></i></span>
            <input class="form-control" type="text" placeholder="Search" name="query" id="searchInput">
          </div>
        </form>
      </div>
    </nav>
</header>
            <main class="main">
              <div class="navigation-container grey-background hidden-xs col-sm-2" data-component="main" data-version="1.1.28">
  <aside class="navigation" role="navigation">
    <div class="panels">
      <div class="input-group nav-filter-group">
        <span class="input-group-addon"><i class="fa fa-search"></i></span>
        <input class="form-control" type="text" placeholder="Filter menu entries..." id="navFilterInput">
      </div>
      <div class="navigation-menu is-active" data-panel="menu">
        <nav class="nav-menu">
          <!-- <label>Talend Component Kit Developer Reference Guide</label> -->
          <ul class="nav nav-list tree" >
  <li data-depth="0">
      
    <ul class="nav nav-list tree" >
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>First steps</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="getting-started.html">Getting Started</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-my-first-component.html">Creating your first component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="record-types.html">Record types</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Tutorials</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-tutorials.html">Tutorial overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-my-first-component.html">Creating your first component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-generate-project-using-starter.html">Generating a project from the starter</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-an-input-component.html">Creating a Hazelcast input component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-an-output-component.html">Creating a Hazelcast output component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-create-components-rest-api.html">Creating a Zendesk REST API connector</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-test-rest-api.html">Testing a Zendesk REST API connector</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-test-your-components.html">Testing a Hazelcast component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-dev-vs-ci-setup.html">Testing in a continuous integration environment</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-handle-talend-component-migration.html">Handling component version migration</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Setting up your environment</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-setup-environment.html">Setup overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="system-prerequisites.html">System requirements</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="installing-talend-intellij-plugin.html">Installing the IntelliJ plugin</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Generating a project</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-generating-project.html">Project generation overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-generate-project-using-starter.html">Using the Starter</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="generate-project-using-intellij-plugin.html">Using the IntelliJ plugin</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Implementing components</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-creating-components.html">Component implementation overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-registering.html">Defining component metadata</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="creating-dataset-datastore.html">Defining datasets and datastores</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-define-input.html">Defining an input component logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-define-processor-output.html">Defining a processor/output logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-configuration.html">Defining component configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-execution.html">Component execution logic</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-internationalization.html">Internationalizing a component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-versions-and-migration.html">Managing component versions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="tutorial-configuration-sensitive-data.html">Masking sensitive data</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="concept-processor-and-batch-processing.html">Implementing batch processing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-implementing-streaming.html">Implementing streaming on a component</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="component-loading.html">Component loading</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="build-tools-maven.html">Building components with Maven</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="build-tools-gradle.html">Building components with Gradle</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="wrapping-a-beam-io.html">Wrapping a Beam I/O</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Defining services</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-defining-services.html">Service overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-internationalization.html">Internationalizing a service</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-actions.html">Providing actions through a service</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-built-in.html">Built-in services</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-interceptors.html">Services and interceptors</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-custom-api.html">Defining a custom API</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Testing components</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-testing-components.html">Component testing overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-best-practices.html">Component testing best practices</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="index-sub-testing-runtime.html">Testing component runtime</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-beam.html">Beam testing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-multiple-envs.html">Testing in multiple environments</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-maven-passwords.html">Reusing Maven credentials</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="testing-generating-data.html">Generating data for testing</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="services-pipeline.html">Simple/Test Pipeline API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="https://beam.apache.org/documentation/programming-guide/#creating-a-pipeline">Beam Pipeline API</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Integrating into Talend Studio</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-deploying-components.html">Studio integration overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="studio.html">Iterating on component development</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="studio-from-car.html">Installing components from a CAR file</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="studio-schema.html">Studio schema</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="compatibility.html">Version compatibility</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="javajet-to-componentkit.html">From Javajet to the Component Kit</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Integrating into Talend Cloud</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-cloud-integration.html">Cloud integration overview</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="documentation-rest.html">Component server and HTTP API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="vault-proxy.html">Component Server Vault Proxy</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Knowledge base</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="index-knowledge-base.html">Knowledge base articles</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="changelog.html">Changelog</a>
  </li>
</ul>
  </li>
  <li data-depth="1">
      <label class="tree-toggler nav-header"><i class="fa fa-angle-right"></i><span>Reference Guide</span></label>
    <ul class="nav nav-list tree"  style="display:none">
  <li data-depth="2">
    <a class="menu-link" href="gallery.html">Widget and validation gallery</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-actions.html">List of available actions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-conditions.html">List of conditions for binding properties</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-configuration-types.html">Component data configuration types</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-constraints.html">Component field constraints and validations</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-junit-environments.html">Provided JUnit testing environments</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-rest-resources.html">Component Server HTTP API reference</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-scanning-exclusions.html">Scanning exclusions</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-server-configuration.html">Server configuration</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="ref-ui.html">UI API</a>
  </li>
  <li data-depth="2">
    <a class="menu-link" href="apidocs.html">Javadocs</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
        </nav>
      </div>
    </div>
  </aside>
</div>
              <div class="col-xs-12 col-sm-10 maincontent">
                <div class="toolbar" role="navigation">

    <ol class="breadcrumb">
      <li class="crumb active"><a href="all-in-one.html">Talend Component Kit Developer Guide</a></li>
    </ol>
</div>
                <article class="doc">
        <div class="row">
          <div class="col-sm-9 row">
              <h1>Talend Component Kit Developer Guide</h1>
            <div class="article-content">
              <div class="sect1">
<h2 id="_getting_started_with_talend_component_kit"><a class="anchor" href="#_getting_started_with_talend_component_kit"></a>Getting started with Talend Component Kit</h2>
<div class="sectionbody">
<div id="getting-started-introducing-talend-component" class="paragraph">
<p><em>Talend Component Kit</em> is a Java framework designed to simplify the development of components at two levels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Runtime</strong>: Runtime is about injecting the specific component code into a job or pipeline. The framework helps unify as much as possible the code required to run in Data Integration (DI) and BEAM environments.</p>
</li>
<li>
<p><strong>Graphical interface</strong>: The framework helps unifying the code required to be able to render the component in a browser (web) or in the Eclipse-based Studio (SWT).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most part of the development happens as a Maven or Gradle project and requires a dedicated tool such as IntelliJ.</p>
</div>
<div class="paragraph">
<p>The Component Kit is made of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Starter, that is a graphical interface allowing you to define the skeleton of your development project.</p>
</li>
<li>
<p>APIs to implement components UI and runtime.</p>
</li>
<li>
<p>Development tools: Maven and Gradle wrappers, validation rules, packaging, Web preview, etc.</p>
</li>
<li>
<p>A testing kit based on JUnit 4 and 5.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By using this tooling in a basic development environment, you can start creating components as described below.</p>
</div>
<div class="sect2">
<h3 id="_talend_component_kit_methodology"><a class="anchor" href="#_talend_component_kit_methodology"></a>Talend Component Kit methodology</h3>
<div id="getting-started-principles" class="paragraph">
<p>Developing new components using the Component Kit framework includes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="index-generating-project.html" class="page">Creating a project</a> using the <a href="https://starter-toolkit.talend.io/">starter</a> or the <a href="installing-talend-intellij-plugin.html" class="page">Talend IntelliJ plugin</a>. This step allows to build the skeleton of the project. It consists in:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Defining the general configuration model for each component in your project</p>
</li>
<li>
<p>Generating and downloading the project archive from the starter</p>
</li>
<li>
<p>Compiling the project</p>
</li>
</ol>
</div>
</li>
<li>
<p>Importing the compiled project in your IDE. This step is not required if you have generated the project using the IntelliJ plugin.</p>
</li>
<li>
<p><a href="index-creating-components.html" class="page">Implementing the components</a>, including:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Registering the components by specifying their metadata: family, categories, version, icon, type, and name.</p>
</li>
<li>
<p>Defining the layout and configurable part of the components</p>
</li>
<li>
<p>Defining the execution logic of the components, also called runtime.</p>
</li>
</ol>
</div>
</li>
<li>
<p><a href="index-testing-components.html" class="page">Testing the components</a>.</p>
</li>
<li>
<p><a href="index-deploying-components.html" class="page">Deploying the components</a> to Talend Studio or Cloud applications.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Optionally, you can use <a href="index-defining-services.html" class="page">services</a>. Services are predefined or user-defined configurations that can be reused in several components.</p>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/methodo.png" target="_blank" rel="noopener"><img src="_images/methodo.png" alt="Methodology"></a></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_component_types"><a class="anchor" href="#_component_types"></a>Component types</h3>
<div class="paragraph">
<p>There are three types of components, each type coming with its specificities, especially on the runtime side.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Input components: Retrieve the data to process from a defined source. An input component is made of:</p>
<div class="ulist">
<ul>
<li>
<p>The execution logic of the component, represented by a <code>Mapper</code> or an <code>Emitter</code> class.</p>
</li>
<li>
<p>The source logic of the component, represented by a <code>Source</code> class.</p>
</li>
<li>
<p>The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a <code>Configuration</code> class. All input components must have a dataset specified in their configuration, and every dataset must use a datastore.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Processors: Process and transform the data. A processor is made of:</p>
<div class="ulist">
<ul>
<li>
<p>The execution logic of the component, describing how to process each records or batches of records it receives. It also describes how to pass records to its output connections. This logic is defined in a <code>Processor</code> class.</p>
</li>
<li>
<p>The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a <code>Configuration</code> class.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Output components: Send the processed data to a defined destination. An output component is made of:</p>
<div class="ulist">
<ul>
<li>
<p>The execution logic of the component, describing how to process each records or batches of records it receives. This logic is defined in an <code>Output</code> class. Unlike processors, output components are the last components of the execution and return no data.</p>
</li>
<li>
<p>The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a <code>Configuration</code> class. All input components must have a dataset specified in their configuration, and every dataset must use a datastore.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows the different classes of an input components in a multi-component development project:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/input_intellij.png" target="_blank" rel="noopener"><img src="_images/input_intellij.png" alt="Input"></a>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_next"><a class="anchor" href="#_next"></a>Next</h3>
<div class="ulist">
<ul>
<li>
<p><a href="system-prerequisites.html" class="page">Setup your development environment</a></p>
</li>
<li>
<p><a href="tutorial-create-my-first-component.html" class="page">Generate your first project and develop your first component</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creating_your_first_component"><a class="anchor" href="#_creating_your_first_component"></a>Creating your first component</h3>
<div class="paragraph">
<p>This tutorial walks you through all the required steps to get started with <strong>Talend Component Kit</strong>, from the creation of a simple component to its integration into <strong>Talend Open Studio</strong>.</p>
</div>
<div class="paragraph">
<p>The component created in this tutorial is a simple processor component that receives data from the previous component and displays it in the logs, along with an extra information entered by a user.</p>
</div>
<div class="paragraph">
<p>Once the prerequisites completed, this tutorial should take you about 20 minutes.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The component designed in this tutorial is a processor and does not require nor show any <a href="component-configuration.html#dataset-and-datastore" class="page">datastore and dataset</a> configuration. Datasets and datastores are required only for input and output components.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
<div class="sect3">
<h4 id="_prerequisites"><a class="anchor" href="#_prerequisites"></a>Prerequisites</h4>
<div class="paragraph">
<p>This tutorial aims at helping you to create your very first component. But before, get your development environment ready:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Download and install a Java JDK 1.8 or greater.</p>
</li>
<li>
<p>Download and install Talend Open Studio. For example, from <a href="https://sourceforge.net/projects/talend-studio">Sourceforge</a>.</p>
</li>
<li>
<p>Download and install <a href="https://www.jetbrains.com/idea/download">IntelliJ</a>.</p>
</li>
<li>
<p>Download the Talend Component Kit plugin for IntelliJ. The detailed installation steps for the plugin are available in <a href="installing-talend-intellij-plugin.html" class="page">this document</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_generating_a_simple_component_project"><a class="anchor" href="#_generating_a_simple_component_project"></a>Generating a simple component project</h4>
<div class="paragraph">
<p>The first step in this tutorial is to generate a project containing a simple output component using the <strong>Starter</strong> included in the Talend Component Kit plugin for IntelliJ.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start IntelliJ and create a new project. In the available options, you should see <strong>Talend Component</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij_new_component_project.png" target="_blank" rel="noopener"><img src="_images/intellij_new_component_project.png" alt="New project"></a>
</div>
</div>
</li>
<li>
<p>Make sure that a <strong>Project SDK</strong> is selected. Then, select <strong>Talend Component</strong> and click <strong>Next</strong>.<br>
The <strong>Talend Component Kit Starter</strong> opens.</p>
</li>
<li>
<p>Enter the project details. The goal here is to define the component and project metadata. Change the default values as follows:<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij_tutorial_project_metadata.png" target="_blank" rel="noopener"><img src="_images/intellij_tutorial_project_metadata.png" alt="Project metadata"></a>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <strong>Component Family</strong> and the <strong>Category</strong> will be used later in Talend Open Studio to find the new component.</p>
</li>
<li>
<p>The project metadata are mostly used to identify the project structure. A common practice is to replace 'company' in the default value by a value of your own, like your domain name.<br></p>
</li>
</ul>
</div>
</li>
<li>
<p>Once the metadata is filled, select <strong>Add a component</strong>. A new screen is displayed in the <strong>Talend Component Kit Starter</strong> that lets you define the generic configuration of the component. By default, new components are processors,</p>
</li>
<li>
<p>Enter a valid Java name for the component. For example, <strong>Logger</strong>.</p>
</li>
<li>
<p>Select <strong>Configuration Model</strong> and add a string field named <code>level</code>. This input field will be used in the component configuration to enter additional information to display in the logs.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_component_configuration_model.png" target="_blank" rel="noopener"><img src="_images/tutorial_component_configuration_model.png" alt="Configuration Model"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Input(s) / Output(s)</strong> section, click the default <strong>MAIN</strong> input branch to access its detail, and make sure that the record model is set to <strong>Generic</strong>. Leave the <strong>Name</strong> of the branch with its default <code>MAIN</code> value.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_component_generic_input.png" target="_blank" rel="noopener"><img src="_images/tutorial_component_generic_input.png" alt="Generic Input"></a>
</div>
</div>
</li>
<li>
<p>Repeat the same step for the default <strong>MAIN</strong> output branch.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the component is a processor, it has an output branch by default. A processor without any output branch is considered an output component. You can create output components when the <strong>Activate IO</strong> option is selected.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Click <strong>Next</strong> and check the name and location of your project, then click <strong>Finish</strong> to generate the project in the IDE.<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point, your component is technically already ready to be compiled and deployed to Talend Open Studio. But first, have a look at the generated project:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_generated_project_view.png" target="_blank" rel="noopener"><img src="_images/tutorial_generated_project_view.png" alt="Project view"></a>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Two classes based on the name and type of component defined in the <strong>Talend Component Kit Starter</strong> have been generated:</p>
<div class="ulist">
<ul>
<li>
<p><strong>LoggerProcessor</strong> is where the component logic is defined</p>
</li>
<li>
<p><strong>LoggerProcessorConfiguration</strong> is where the component layout and configurable fields are defined, including the <strong>level</strong> string field that was defined earlier in the configuration model of the component.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <strong>package-info.java</strong> file contains the component metadata defined in the <strong>Talend Component Kit Starter</strong>, like the family and category.</p>
</li>
<li>
<p>You can notice as well that the elements in the tree structure are named after the project metadata defined in the <strong>Talend Component Kit Starter</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These files are the starting point if you later need to edit the configuration, logic, and metadata of your component.</p>
</div>
<div class="paragraph">
<p>There is more that you can do and configure with the <strong>Talend Component Kit Starter</strong>. This tutorial covers only the basics. You can find more information in <a href="tutorial-generate-project-using-starter.html" class="page">this document</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_and_deploying_the_component_to_talend_open_studio"><a class="anchor" href="#_compiling_and_deploying_the_component_to_talend_open_studio"></a>Compiling and deploying the component to Talend Open Studio</h4>
<div class="paragraph">
<p>Without any modification in the component code, you can compile the project and deploy the component to a local instance of Talend Open Studio.</p>
</div>
<div class="paragraph">
<p>This way, it will be easy to check that what is visible in the Studio is what is intended.</p>
</div>
<div class="paragraph">
<p>Before starting to run any command, make sure Talend Open Studio is not running.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From your component project in IntelliJ, open a terminal and make sure that the selected directory is the root of the project. All commands shown in this tutorial are performed from this location.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_intellij_terminal_blank.png" target="_blank" rel="noopener"><img src="_images/tutorial_intellij_terminal_blank.png" alt="Compile terminal"></a>
</div>
</div>
</li>
<li>
<p>Compile the project by running the following command: <code>mvnw clean install</code>.<br>
The <code>mvnw</code> command refers to the Maven wrapper that is shipped with Talend Component Kit. It allows to use the right version of Maven for your project without having to install it manually beforehand. An equivalent wrapper is available for Gradle.</p>
</li>
<li>
<p>Once the command is executed and you see <strong>BUILD SUCCESS</strong> in the terminal, deploy the component to your local instance of Talend Open Studio using the following command:<br>
<code>mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;path to Talend Open Studio home&gt;"</code><br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Replace the path by your own value. If the path contains spaces (for example, <code>Program Files</code>), enclose it with double quotes.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Make sure the build is successful.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_deploy_in_studio_success.png" target="_blank" rel="noopener"><img src="_images/tutorial_deploy_in_studio_success.png" alt="Build success"></a>
</div>
</div>
</li>
<li>
<p>Open Talend Open Studio and create a new Job:</p>
<div class="ulist">
<ul>
<li>
<p>The new component is present inside the new family and category that were specified in the <strong>Talend Component Kit Starter</strong>. You can add it to your job and open its settings.</p>
</li>
<li>
<p>Notice that the <strong>level</strong> field that was specified in the configuration model of the component in the <strong>Talend Component Kit Starter</strong> is present.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_first_component_in_studio.png" target="_blank" rel="noopener"><img src="_images/tutorial_first_component_in_studio.png" alt="Component in Studio"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point, your new component is available in Talend Open Studio, and its configurable part is already set. But the component logic is still to be defined.<br></p>
</div>
</div>
<div class="sect3">
<h4 id="_editing_the_component"><a class="anchor" href="#_editing_the_component"></a>Editing the component</h4>
<div class="paragraph">
<p>You can now edit the component to implement a simple logic: reading the data contained in the input branch of the component to display it the execution logs of the job. The value of the <strong>level</strong> field of the component also needs to be displayed and changed to uppercase.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save the job created earlier and close Talend Open Studio.</p>
</li>
<li>
<p>Back in IntelliJ open the <strong>LoggerProcessor</strong> class. This is the class where the component logic can be defined.</p>
</li>
<li>
<p>Look for the <code>@ElementListener</code> method. It is already present and references the default input branch that was defined in the <strong>Talend Component Kit Starter</strong>, but it is not complete yet.</p>
</li>
<li>
<p>To be able to log the data in input to the console, add the following lines:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Log to the console
        System.out.println("["+configuration.getLevel().toUpperCase()+"] "+defaultInput);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ElementListener</code> method now looks as follows:<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
    public void onNext(
            @Input final Record defaultInput) {
        // this is the method allowing you to handle the input(s) and emit the output(s)
        // after some custom logic you put here, to send a value to next element you can use an
        // output parameter and call emit(value).

        //Log to the console
        System.out.println("["+configuration.getLevel().toUpperCase()+"] "+defaultInput);
    }</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="5">
<li>
<p>Open the Terminal again to compile the project and deploy the component again. To do that, run successively the two following commands:</p>
<div class="ulist">
<ul>
<li>
<p><code>mvnw clean install</code></p>
</li>
<li>
<p><code>`mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;path to Talend Open Studio home&gt;"</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The update of the component logic should now be deployed to the Studio. After restarting the Studio, you will be ready to build a job and use your component for the first time.</p>
</div>
<div class="paragraph">
<p>To learn the different possibilities and methods available to develop more complex logics, refer to <a href="component-define-processor-output.html" class="page">this document</a>.</p>
</div>
<div class="paragraph">
<p>If you want to avoid having to close and re-open Talend Open Studio every time you need to make an edit, you can enable the developer mode, as explained in <a href="studio.html#developer-mode" class="page">this document</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_building_a_job_with_the_component"><a class="anchor" href="#_building_a_job_with_the_component"></a>Building a job with the component</h4>
<div class="paragraph">
<p>As the component is now ready to be used, it is time to create a job and check that it behaves as intended.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open Talend Open Studio again and go to the job created earlier. The new component is still there.</p>
</li>
<li>
<p>Add a <strong>tRowGenerator</strong> component and connect it to the logger.</p>
</li>
<li>
<p>Double-click the <strong>tRowGenerator</strong> to specify the data to generate:</p>
<div class="ulist">
<ul>
<li>
<p>Add a first column named <code>firstName</code> and select the <strong>TalendDataGenerator.getFirstName()</strong> function.</p>
</li>
<li>
<p>Add a second column named 'lastName' and select the <strong>TalendDataGenerator.getLastName()</strong> function.</p>
</li>
<li>
<p>Set the <strong>Number of Rows for RowGenerator</strong> to <code>10</code>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_trowgenerator.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_trowgenerator.png" alt="tRowGenerator"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Validate the <strong>tRowGenerator</strong> configuration.</p>
</li>
<li>
<p>Open the <strong>TutorialFamilyLogger</strong> component and set the <strong>level</strong> field to <code>info</code>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_logger.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_logger.png" alt="Logger"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>Run</strong> tab of the job and run the job.<br>
The job is executed. You can observe in the console that each of the 10 generated rows is logged, and that the <code>info</code> value entered in the logger is also displayed with each record, in uppercase.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles"><a class="anchor" href="#_related_articles"></a>Related articles</h4>
<div class="paragraph">
<p>To go further and start implementing more complex components, you can refer to the following documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the Talend Component Kit Starter</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-execution.html" class="page">General component execution logic</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Configuring a component</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component logic</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor/output logic</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_record_types"><a class="anchor" href="#_record_types"></a>Record types</h3>
<div class="paragraph">
<p>Components are designed to manipulate data (access, read, create). Talend Component Kit can handle several types of data, described in this document.</p>
</div>
<div class="paragraph">
<p>By design, the framework must run in DI (plain standalone Java program) and in Beam pipelines.<br>
It is out of scope of the framework to handle the way the runtime serializes - if needed - the data.</p>
</div>
<div class="paragraph">
<p>For that reason, it is critical not to import serialization constraints to the stack. As an example, this is one of the reasons why <code>Record</code> or <code>JsonObject</code> were preferred to Avro <code>IndexedRecord</code>.</p>
</div>
<div class="paragraph">
<p>Any serialization concern should either be hidden in the framework runtime (outside of the component developer scope) or in the runtime integration with the framework (for example, Beam integration).</p>
</div>
<div class="sect3">
<h4 id="record"><a class="anchor" href="#record"></a>Record</h4>
<div class="paragraph">
<p><code>Record</code> is the default format. It offers many possibilities and can evolve depending on the Talend platform needs. Its structure is data-driven and exposes a schema that allows to browse it.</p>
</div>
<div class="paragraph">
<p>Projects generated from the <a href="index-generating-project.html" class="page">Talend Component Kit Starter</a> are by default designed to handle this format of data.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>Record</code> is a Java interface but never implement it yourself to ensure compatibility with the different Talend products. Follow the guidelines below.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_creating_a_record"><a class="anchor" href="#_creating_a_record"></a>Creating a record</h5>
<div class="paragraph">
<p>You can build records using the <code>newRecordBuilder</code> method of the <code>RecordBuilderFactory</code> (see <a href="services-built-in.html" class="page">here</a>).</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Record createRecord() {
    return factory.newRecordBuilder()
            .withString("name", "Gary")
            .withDateTime("date", ZonedDateTime.of(LocalDateTime.of(2011, 2, 6, 8, 0), ZoneId.of("UTC")))
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, the schema is dynamically computed from the data. You can also do it using a pre-built schema, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Record createRecord() {
    return factory.newRecordBuilder(myAlreadyBuiltSchemaWithSchemaBuilder)
            .withString("name", "Gary")
            .withDateTime("date", ZonedDateTime.of(LocalDateTime.of(2011, 2, 6, 8, 0), ZoneId.of("UTC")))
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above uses a schema that was pre-built using <code>factory.newSchemaBuilder(Schema.Type.RECORD)</code>.</p>
</div>
<div class="paragraph">
<p>When using a pre-built schema, the entries passed to the record builder are validated. It means that if you pass a null value null or an entry type that does not match the provided schema, the record creation fails.
It also fails if you try to add an entry which does not exist or if you did not set a not nullable entry.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Using a dynamic schema can be useful on the backend but can lead users to more issues when creating a pipeline to process the data. Using a pre-built schema is more reliable for end-users.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_accessing_and_reading_a_record"><a class="anchor" href="#_accessing_and_reading_a_record"></a>Accessing and reading a record</h5>
<div class="paragraph">
<p>You can access and read data by relying on the <code>getSchema</code> method, which provides you with the available entries (columns) of a record. The <code>Entry</code> exposes the type of its value, which lets you access the value through the corresponding method. For example, the <code>Schema.Type.STRING</code> type implies using the <code>getString</code> method of the record.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void print(final Record record) {
    final Schema schema = record.getSchema();
    // log in the natural type
    schema.getEntries()
          .forEach(entry -&gt; System.out.println(record.get(Object.class, entry.getName())));
    // log only strings
    schema.getEntries().stream()
          .filter(e -&gt; e.getType() == Schema.Type.STRING)
          .forEach(entry -&gt; System.out.println(record.getString(entry.getName())));
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_supported_data_types"><a class="anchor" href="#_supported_data_types"></a>Supported data types</h5>
<div class="paragraph">
<p>The <code>Record</code> format supports the following data types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>String</p>
</li>
<li>
<p>Boolean</p>
</li>
<li>
<p>Int</p>
</li>
<li>
<p>Long</p>
</li>
<li>
<p>Float</p>
</li>
<li>
<p>Double</p>
</li>
<li>
<p>DateTime</p>
</li>
<li>
<p>Array</p>
</li>
<li>
<p>Bytes</p>
</li>
<li>
<p>Record</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A map can always be modelized as a list (array of records with key and value entries).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public Record create() {
       final Record address = factory.newRecordBuilder()
               .withString("street", "Prairie aux Ducs")
               .withString("city", "Nantes")
               .withString("country", "FRANCE")
               .build();
       return factory.newRecordBuilder()
                     .withBoolean("active", true)
                     .withInt("age", 33)
                     .withLong("duration", 123459)
                     .withFloat("tolerance", 1.1f)
                     .withDouble("balance", 12.58)
                     .withString("name", "John Doe")
                     .withDateTime("birth", ZonedDateTime.now())
                     .withRecord(
                             factory.newEntryBuilder()
                               .withName("address")
                               .withType(Schema.Type.RECORD)
                               .withComment("The user address")
                               .withElementSchema(address.getSchema())
                               .build(),
                             address)
                     .withArray(
                             factory.newEntryBuilder()
                                       .withName("permissions")
                                       .withType(Schema.Type.ARRAY)
                                       .withElementSchema(factory.newSchemaBuilder(Schema.Type.STRING).build())
                                       .build(),
                             asList("admin", "dev"))
                     .build();
   }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_example_discovering_a_schema"><a class="anchor" href="#_example_discovering_a_schema"></a>Example: discovering a schema</h5>
<div class="paragraph">
<p>For example, you can use the API to provide the schema.
The following method needs to be implemented in a <a href="index-defining-services.html" class="page">service</a>.</p>
</div>
<div class="paragraph">
<p>Manually constructing the schema without any data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DiscoverSchema
getSchema(@Option MyDataset dataset) {
    return factory.newSchemaBuilder(Schema.Type.RECORD)
            .withEntry(factory.newEntryBuilder().withName("id").withType(Schema.Type.LONG).build())
            .withEntry(factory.newEntryBuilder().withName("name").withType(Schema.Type.STRING).build())
            .build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returning the schema from an already built record:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DiscoverSchema
public Schema guessSchema(@Option MyDataset dataset, final MyDataLoaderService myCustomService) {
   return myCustomService.loadFirstData().getRecord().getSchema();
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MyDataset</code> is the class that defines the dataset. Learn more about datasets and datastores in <a href="component-configuration.html#dataset-and-datastore" class="page">this document</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_authorized_characters_in_entry_names"><a class="anchor" href="#_authorized_characters_in_entry_names"></a>Authorized characters in entry names</h5>
<div class="paragraph">
<p>Entry names for <code>Record</code> and <code>JsonObject</code> types must comply with the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The name must start with a letter or with <code>_</code>. If not, the invalid characters are ignored until the first valid character.</p>
</li>
<li>
<p>Following characters of the name must be a letter, a number, or <code><em></code>. If not, the invalid character is replaced with <code></em></code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>1foo</code> becomes <code>foo</code>.</p>
</li>
<li>
<p><code>f@o</code> becomes <code>f_o</code>.</p>
</li>
<li>
<p><code>1234f5@o</code> becomes <code>___f5_o</code>.</p>
</li>
<li>
<p><code>foo123</code> stays <code>foo123</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_data_types_in_arrays"><a class="anchor" href="#_data_types_in_arrays"></a>Data types in arrays</h5>
<div class="paragraph">
<p>Each array uses only one schema for all of its elements. If an array contains several elements, they must be of the same data type.</p>
</div>
<div class="paragraph">
<p>For example, the following array is not correct as it contains a <strong>string</strong> and an <strong>object</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{"Value":[
  {"value":"v1"},
  {"value":[]}
  ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jsonobject"><a class="anchor" href="#_jsonobject"></a>JsonObject</h4>
<div class="paragraph">
<p>The runtime also supports <code>JsonObject</code> as input and output component type. You can rely on the JSON services (<code>Jsonb</code>, <code>JsonBuilderFactory</code>) to create new instances.</p>
</div>
<div class="paragraph">
<p>This format is close to the <code>Record</code> format, except that it does not natively support the Datetime type and has a unique Number type to represent Int, Long, Float and Double types. It also does not provide entry metadata like <code>nullable</code> or <code>comment</code>, for example.</p>
</div>
<div class="paragraph">
<p>It also inherits the <code>Record</code> format limitations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pojo"><a class="anchor" href="#_pojo"></a>Pojo</h4>
<div class="paragraph">
<p>The runtime also accepts any POJO as input and output component type. In this case, it uses JSON-B to treat it as a <code>JsonObject</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_setting_up_your_environment"><a class="anchor" href="#_setting_up_your_environment"></a>Setting up your environment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before being able to develop components using Talend Component Kit, you need the right system configuration and tools.</p>
</div>
<div class="paragraph">
<p>Although Talend Component Kit comes with some embedded tools, such as Maven and Gradle wrappers, you still need to prepare your system. A Talend Component Kit plugin for IntelliJ is also available and allows to design and generate your component project right from IntelliJ.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="system-prerequisites.html" class="page">System requirements</a></p>
</li>
<li>
<p><a href="installing-talend-intellij-plugin.html" class="page">Installing the IntelliJ plugin</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_system_prerequisites"><a class="anchor" href="#_system_prerequisites"></a>System prerequisites</h3>
<div id="getting-started-system-requirements" class="paragraph">
<p>In order to use Talend Component Kit, you need the following tools installed on your machine:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java JDK 1.8.x. You can download it from <a href="http://www.oracle.com/technetwork/pt/java/javase/downloads/jdk8-downloads-2133151.html">Oracle</a> website.</p>
</li>
<li>
<p>Talend Open Studio to integrate your components.</p>
</li>
<li>
<p>A Java Integrated Development Environment such as Eclipse or IntelliJ. IntelliJ is recommended as a Talend Component Kit plugin is available.</p>
</li>
<li>
<p>Optional: If you use IntelliJ, you can install the <a href="installing-talend-intellij-plugin.html" class="page">Talend Component Kit plugin for IntelliJ</a>.</p>
</li>
<li>
<p>Optional: A build tool:</p>
<div class="ulist">
<ul>
<li>
<p>Apache Maven 3.5.4 is recommended to develop a component or the project itself. You can download it from <a href="https://maven.apache.org/download.cgi?Preferred=ftp%3A%2F%2Fmirror.reverse.net%2Fpub%2Fapache%2F">Apache Maven</a> website.<br></p>
</li>
<li>
<p>You can also use Gradle, but at the moment certain features are not supported, such as validations.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is optional to install a build tool independently since Maven and Gradle wrappers are already available with Talend Component Kit.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_2"><a class="anchor" href="#_related_articles_2"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="installing-talend-intellij-plugin.html" class="page">IntelliJ plugin</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_installing_the_talend_component_kit_intellij_plugin"><a class="anchor" href="#_installing_the_talend_component_kit_intellij_plugin"></a>Installing the Talend Component Kit IntelliJ plugin</h3>
<div id="installing-talend-intellij-plugin" class="paragraph">
<p>The Talend Component Kit IntelliJ plugin is a plugin for the IntelliJ Java IDE. It adds support for the Talend Component Kit project creation.</p>
</div>
<div class="paragraph">
<p>Main features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project generation support.</p>
</li>
<li>
<p>Internationalization completion for component configuration.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_installing_the_intellij_plugin"><a class="anchor" href="#_installing_the_intellij_plugin"></a>Installing the IntelliJ plugin</h4>
<div class="paragraph">
<p>In the Intellij IDEA:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to <strong>File</strong> &gt; <strong>Settings&#8230;&#8203;</strong></p>
</li>
<li>
<p>On the left panel, select <strong>Plugins</strong>.</p>
</li>
<li>
<p>Access the <strong>Marketplace</strong> tab.</p>
</li>
<li>
<p>Enter <code>Talend</code> in the search field and Select <strong>Talend Component Kit</strong>.</p>
</li>
<li>
<p>Select <strong>Install</strong>.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij/plugin/2-browse-talend.png" target="_blank" rel="noopener"><img src="_images/intellij/plugin/2-browse-talend.png" alt="Browse talend plugin"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="6">
<li>
<p>Click the <strong>Restart IDE</strong> button.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij/plugin/3-restart.png" target="_blank" rel="noopener"><img src="_images/intellij/plugin/3-restart.png" alt="IDEA restart"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="7">
<li>
<p>Confirm the IDEA restart to complete the installation.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij/plugin/4-restart.png" target="_blank" rel="noopener"><img src="_images/intellij/plugin/4-restart.png" alt="IDEA restart"></a>
</div>
</div>
<div class="paragraph">
<p>The plugin is now installed on your IntelliJ IDEA. You can <a href="generate-project-using-intellij-plugin.html" class="page">start using it</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_about_the_internationalization_completion"><a class="anchor" href="#_about_the_internationalization_completion"></a>About the internationalization completion</h4>
<div class="paragraph">
<p>The plugin offers auto-completion for the configuration internationalization.
The Talend component configuration lets you setup translatable and user-friendly labels for your configuration using a property file.
Auto-completion in possible for the configuration keys and default values in the property file.</p>
</div>
<div class="paragraph">
<p>For example, you can internationalize a simple configuration class for a basic authentication that you use in your component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Checkable("basicAuth")
@DataStore("basicAuth")
@GridLayout({
        @GridLayout.Row({ "url" }),
        @GridLayout.Row({ "username", "password" }),
})
public class BasicAuthConfig implements Serializable {

    @Option
    private String url;

    @Option
    private String username;

    @Option
    @Credential
    private String password;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration class contains three properties which you can attach a user-friendly label to.</p>
</div>
<div class="paragraph">
<p>For example, you can define a label like <code>My server URL</code> for the <code>url</code> option:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Locate or create a <code>Messages.properties</code> file in the project resources and add the label to that file.
The plugin automatically detects your configuration and provides you with key completion in the property file.</p>
</li>
<li>
<p>Press <strong>Ctrl</strong>+<strong>Space</strong> to see the key suggestions.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij/plugin/suggestion_1.png" target="_blank" rel="noopener"><img src="_images/intellij/plugin/suggestion_1.png" alt="Keys suggestion"></a>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_3"><a class="anchor" href="#_related_articles_3"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="system-prerequisites.html" class="page">System requirements</a></p>
</li>
<li>
<p><a href="generate-project-using-intellij-plugin.html" class="page">Generating a project using the IntelliJ plugin</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generating_a_project"><a class="anchor" href="#_generating_a_project"></a>Generating a project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first step when developing new components is to create a project that will contain the skeleton of your components and set you on the right track.</p>
</div>
<div class="paragraph">
<p>The project generation can be achieved using the <a href="https://starter-toolkit.talend.io">Talend Component Kit Starter</a> or the Talend Component Kit plugin for IntelliJ.</p>
</div>
<div class="paragraph">
<p>Through a user-friendly interface, you can define the main lines of your project and of your component(s), including their name, family, type, configuration model, and so on.</p>
</div>
<div class="paragraph">
<p>Once completed, all the information filled are used to generate a project that you will use as starting point to implement the logic and layout of your components, and to iterate on them.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Using the starter</a></p>
</li>
<li>
<p><a href="generate-project-using-intellij-plugin.html" class="page">Using the IntelliJ plugin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once your project is generated, you can start <a href="index-creating-components.html" class="page">implementing the component logic</a>.</p>
</div>
<div class="sect2">
<h3 id="_generating_a_project_using_the_component_kit_starter"><a class="anchor" href="#_generating_a_project_using_the_component_kit_starter"></a>Generating a project using the Component Kit Starter</h3>
<div id="tutorial-generate-project-using-starter" class="paragraph">
<p>The Component Kit starter lets you design your components configuration and generates a ready-to-implement project structure.</p>
</div>
<div class="paragraph">
<p>The starter is available on the web or as an <a href="generate-project-using-intellij-plugin.html" class="page">IntelliJ plugin</a>.</p>
</div>
<div class="paragraph">
<p>This tutorial shows you how to use the Component Kit Starter to generate new components for MySQL databases. Before starting, make sure that you have correctly setup your environment. See <a href="system-prerequisites.html" class="page">this section</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When defining a project using the Starter, do not refresh the page to avoid losing your configuration.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_configuring_the_project"><a class="anchor" href="#_configuring_the_project"></a>Configuring the project</h4>
<div class="paragraph">
<p>Before being able to create components, you need to define the general settings of the project:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a folder on your local machine to store the resource files of the component you want to create. For example, <code>C:/my_components</code>.</p>
</li>
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Select your build tool. This tutorial uses Maven, but you can select Gradle instead.</p>
</li>
<li>
<p>Add any facet you need. For example, add the <strong>Talend Component Kit Testing</strong> facet to your project to automatically generate unit tests for the components created in the project.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_test_facet.png" target="_blank" rel="noopener"><img src="_images/starter/starter_test_facet.png" alt="Test facet"></a>
</div>
</div>
</li>
<li>
<p>Enter the <strong>Component Family</strong> of the components you want to develop in the project. This name must be a valid java name and is recommended to be capitalized, for example 'MySQL'.<br>
Once you have implemented your components in the Studio, this name is displayed in the Palette to group all of the MySQL-related components you develop, and is also part of your component name.</p>
</li>
<li>
<p>Select the <strong>Category</strong> of the components you want to create in the current project. As MySQL is a kind of database, select <strong>Databases</strong> in this tutorial.<br>
This <strong>Databases</strong> category is used and displayed as the parent family of the MySQL group in the Palette of the Studio.</p>
</li>
<li>
<p>Complete the project metadata by entering the <strong>Group</strong>, <strong>Artifact</strong> and <strong>Package</strong>.</p>
</li>
<li>
<p>By default, you can only create <strong>processors</strong>. If you need to create <strong>Input</strong> or <strong>Output</strong> components, select <strong>Activate IO</strong>. By doing this:</p>
<div class="ulist">
<ul>
<li>
<p>Two new menu entries let you add datasets and datastores to your project, as they are required for input and output components.<br></p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Input and Output components without dataset (itself containing a datastore) will not pass the validation step when building the components. Learn more about datasets and datastores in <a href="component-configuration.html#dataset-and-datastore" class="page">this document</a>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>An Input component and an Output component are automatically added to your project and ready to be configured.</p>
</li>
<li>
<p>Components added to the project using <strong>Add A Component</strong> can now be processors, input or output components.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_activate_io.png" target="_blank" rel="noopener"><img src="_images/starter/starter_activate_io.png" alt="Activate IO"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_datastore"><a class="anchor" href="#_defining_a_datastore"></a>Defining a Datastore</h4>
<div class="paragraph">
<p>A datastore represents the data needed by an input or output component to connect to a database.</p>
</div>
<div class="paragraph">
<p>When building a component, the <code>validateDataSet</code> validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.</p>
</div>
<div class="paragraph">
<p>You can define one or several datastores if you have selected the <strong>Activate IO</strong> step.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Datastore</strong>. The list of datastores opens. By default, a datastore is already open but not configured. You can configure it or create a new one using <strong>Add new Datastore</strong>.</p>
</li>
<li>
<p>Specify the name of the datastore. Modify the default value to a meaningful name for your project.<br>
This name must be a valid Java name as it will represent the datastore class in your project. It is a good practice to start it with an uppercase letter.</p>
</li>
<li>
<p>Edit the datastore configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes connection details to a database:</p>
<div class="ulist">
<ul>
<li>
<p>url</p>
</li>
<li>
<p>username</p>
</li>
<li>
<p>password.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Save</strong> the datastore configuration.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_dataset"><a class="anchor" href="#_defining_a_dataset"></a>Defining a Dataset</h4>
<div class="paragraph">
<p>A dataset represents the data coming from or sent to a database and needed by input and output components to operate.</p>
</div>
<div class="paragraph">
<p>The <code>validateDataSet</code> validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.</p>
</div>
<div class="paragraph">
<p>You can define one or several datasets if you have selected the <strong>Activate IO</strong> step.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Dataset</strong>. The list of datasets opens. By default, a dataset is already open but not configured. You can configure it or create a new one using the <strong>Add new Dataset</strong> button.</p>
</li>
<li>
<p>Specify the name of the dataset. Modify the default value to a meaningful name for your project.<br>
This name must be a valid Java name as it will represent the dataset class in your project. It is a good practice to start it with an uppercase letter.</p>
</li>
<li>
<p>Edit the dataset configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes details of the data to retrieve:</p>
<div class="ulist">
<ul>
<li>
<p>Datastore to use (that contains the connection details to the database)</p>
</li>
<li>
<p>table name</p>
</li>
<li>
<p>data</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Save</strong> the dataset configuration.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_creating_an_input_component"><a class="anchor" href="#_creating_an_input_component"></a>Creating an Input component</h4>
<div class="paragraph">
<p>To create an input component, make sure you have selected <strong>Activate IO</strong>.</p>
</div>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.<br>
The intent in this tutorial is to create an input component that connects to a MySQL database, executes a SQL query and gets the result.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_add_component.png" target="_blank" rel="noopener"><img src="_images/starter/starter_add_component.png" alt="Input configuration"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>Input</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLInput</em>.</p>
</li>
<li>
<p>Click <strong>Configuration model</strong>. This button lets you specify the required configuration for the component. By default, a dataset is already specified.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the parameter name and choose its type then click the tick button to save the changes.<br>
In this tutorial, to be able to execute a SQL query on the Input MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a dataset (which contains the datastore with the connection information)</p>
</li>
<li>
<p>a timeout parameter.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration. However, refreshing the page resets the configuration.<br>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_input-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_input-config.png" alt="Input configuration"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Specify whether the component issues a stream or not. In this tutorial, the MySQL input component created is an ordinary (non streaming) component. In this case, leave the <strong>Stream</strong> option disabled.</p>
</li>
<li>
<p>Select the <strong>Record Type</strong> generated by the component. In this tutorial, select <strong>Generic</strong> because the component is designed to generate records in the default <code>Record</code> format.<br>
You can also select <strong>Custom</strong> to define a POJO that represents your records.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your input component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_processor_component"><a class="anchor" href="#_creating_a_processor_component"></a>Creating a Processor component</h4>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.
The intent in this tutorial is to create a simple processor component that receives a record, logs it and returns it at it is.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you did not select <strong>Activate IO</strong>, all new components you add to the project are processors by default.<br>
If you selected <strong>Activate IO</strong>, you can choose the component type. In this case, to create a Processor component, you have to manually add at least one output.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If required, choose the component type: <strong>Processor</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>RecordLogger</em>, as the processor created in this tutorial logs the records.</p>
</li>
<li>
<p>Specify the <strong>Configuration Model</strong> of the component. In this tutorial, the component doesn&#8217;t need any specific configuration. Skip this step.</p>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>Add Input</strong>. In this tutorial, only one input is needed to receive the record to log.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option and click <strong>Save</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_processor-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_processor-config.png" alt="Processor configuration"></a>
</div>
</div>
</li>
<li>
<p>Define the <strong>Output(s)</strong> of the component. For each output that you need to define, click <strong>Add Output</strong>. The first output must be named <code>MAIN</code>. In this tutorial, only one generic output is needed to return the received record.<br>
Outputs can be configured the same way as inputs (see previous steps).<br>
You can define a reject output connection by naming it <code>REJECT</code>. This naming is used by Talend applications to automatically set the connection type to Reject.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your processor component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_an_output_component"><a class="anchor" href="#_creating_an_output_component"></a>Creating an Output component</h4>
<div class="paragraph">
<p>To create an output component, make sure you have selected <strong>Activate IO</strong>.</p>
</div>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.<br>
The intent in this tutorial is to create an output component that receives a record and inserts it into a MySQL database table.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Output</strong> components are <strong>Processors</strong> without any output. In other words, the output is a processor that does not produce any records.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_output-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_output-config.png" alt="Output configuration"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>Output</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLOutput</em>.</p>
</li>
<li>
<p>Click <strong>Configuration Model</strong>. This button lets you specify the required configuration for the component. By default, a dataset is already specified.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes.<br>
In this tutorial, to be able to insert a record in the output MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a dataset (which contains the datastore with the connection information)</p>
</li>
<li>
<p>a timeout parameter.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration. However, refreshing the page resets the configuration.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>Add Input</strong>. In this tutorial, only one input is needed.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option and click <strong>Save</strong>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not create any output because the component does not produce any record. This is the only difference between an output an a processor component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your output component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generating_and_downloading_the_final_project"><a class="anchor" href="#_generating_and_downloading_the_final_project"></a>Generating and downloading the final project</h4>
<div class="paragraph">
<p>Once your project is configured and all the components you need are created, you can generate and download the final project.
In this tutorial, the project was configured and three components of different types (input, processor and output) have been defined.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Click <strong>Finish</strong> on the left panel. You are redirected to a page that summarizes the project. On the left panel, you can also see all the components that you added to the project.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_project-download.png" target="_blank" rel="noopener"><img src="_images/starter/starter_project-download.png" alt="Output configuration"></a>
</div>
</div>
</li>
<li>
<p>Generate the project using one of the two options available:</p>
<div class="ulist">
<ul>
<li>
<p>Download it locally as a ZIP file using the <strong>Download as ZIP</strong> button.</p>
</li>
<li>
<p>Create a GitHub repository and push the project to it using the <strong>Create on Github</strong> button.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this tutorial, the project is downloaded to the local machine as a ZIP file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_and_exploring_the_generated_project_files"><a class="anchor" href="#_compiling_and_exploring_the_generated_project_files"></a>Compiling and exploring the generated project files</h4>
<div class="paragraph">
<p>Once the package is available on your machine, you can compile it using the build tool selected when configuring the project.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the tutorial, <strong>Maven</strong> is the build tool selected for the project.<br>
In the project directory, execute the <code>mvn package</code> command.<br>
If you don&#8217;t have Maven installed on your machine, you can use the Maven wrapper provided in the generated project, by executing the <code>./mvnw package</code> command.</p>
</li>
<li>
<p>If you have created a Gradle project, you can compile it using the <code>gradle build</code> command or using the Gradle wrapper: <code>./gradlew build</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated project code contains documentation that can guide and help you implementing the component logic.
Import the project to your favorite IDE to start the implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generating_a_project_using_an_openapi_json_descriptor"><a class="anchor" href="#_generating_a_project_using_an_openapi_json_descriptor"></a>Generating a project using an OpenAPI JSON descriptor</h4>
<div class="paragraph">
<p>The Component Kit Starter allows you to generate a component development project from an OpenAPI JSON descriptor.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">Starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Enable the <strong>OpenAPI</strong> mode using the toggle in the header.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter_openapi_toggle.png" target="_blank" rel="noopener"><img src="_images/starter_openapi_toggle.png" alt="Open API toggle"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>API</strong> menu.</p>
</li>
<li>
<p>Paste the OpenAPI JSON descriptor in the right part of the screen. All the described endpoints are detected.</p>
</li>
<li>
<p>Unselect the endpoints that you do not want to use in the future components. By default, all detected endpoints are selected.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter_openapi_json.png" target="_blank" rel="noopener"><img src="_images/starter_openapi_json.png" alt="Open API menu"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>Finish</strong> menu.</p>
</li>
<li>
<p>Download the project.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When exploring the project generated from an OpenAPI descriptor, you can notice the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sources</p>
</li>
<li>
<p>the API dataset</p>
</li>
<li>
<p>an HTTP client for the API</p>
</li>
<li>
<p>a connection folder containing the component configuration. By default, the configuration is only made of a simple datastore with a <code>baseUrl</code> parameter.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_4"><a class="anchor" href="#_related_articles_4"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology</a></p>
</li>
<li>
<p><a href="tutorial-create-an-input-component.html" class="page">Creating a Hazelcast input component</a></p>
</li>
<li>
<p><a href="tutorial-create-an-output-component.html" class="page">Creating a Hazelcast output component</a></p>
</li>
<li>
<p><a href="tutorial-create-components-rest-api.html" class="page">Creating a Zendesk REST API connector</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_generating_a_project_using_intellij_plugin"><a class="anchor" href="#_generating_a_project_using_intellij_plugin"></a>Generating a project using IntelliJ plugin</h3>
<div class="paragraph">
<p>Once the plugin <a href="installing-talend-intellij-plugin.html" class="page">installed</a>, you can generate a component project.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>File</strong> &gt; <strong>New</strong> &gt; <strong>Project</strong>.</p>
</li>
<li>
<p>In the <strong>New Project</strong> wizard, choose <strong>Talend Component</strong> and click <strong>Next</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij/plugin/new-project_1.png" target="_blank" rel="noopener"><img src="_images/intellij/plugin/new-project_1.png" alt="New Talend Project"></a>
</div>
</div>
<div class="paragraph">
<p>The plugin loads the component starter and lets you design your components.
For more information about the Talend Component Kit starter, check <a href="tutorial-generate-project-using-starter.html" class="page">this tutorial</a>.</p>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Once your project is configured, select <strong>Next</strong>, then click <strong>Finish</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The project is automatically imported into the IDEA using the build tool that you have chosen.</p>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_5"><a class="anchor" href="#_related_articles_5"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology</a></p>
</li>
<li>
<p><a href="installing-talend-intellij-plugin.html" class="page">Installing the IntelliJ plugin</a></p>
</li>
<li>
<p><a href="tutorial-create-an-input-component.html" class="page">Creating a Hazelcast input component</a></p>
</li>
<li>
<p><a href="tutorial-create-an-output-component.html" class="page">Creating a Hazelcast output component</a></p>
</li>
<li>
<p><a href="tutorial-create-components-rest-api.html" class="page">Creating a Zendesk REST API connector</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementing_components"><a class="anchor" href="#_implementing_components"></a>Implementing components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once you have generated a project, you can start implementing the logic and layout of your components and iterate on it. Depending on the type of component you want to create, the logic implementation can differ. However, the layout and component metadata are defined the same way for all types of components in your project. The main steps are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="component-registering.html" class="page">Defining family and component metadata</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component logic</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor/output logic</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Defining component layout and configuration</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/implementing-components.png" target="_blank" rel="noopener"><img src="_images/implementing-components.png" alt="Implementing component"></a></span></p>
</div>
<div class="paragraph">
<p>In some cases, you will require specific implementations to handle more advanced cases, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="component-versions-and-migration.html" class="page">Managing component versions</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="concept-processor-and-batch-processing.html" class="page">Implementing batch processing</a></p>
</li>
<li>
<p><a href="component-implementing-streaming.html" class="page">Implementing streaming on a component</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also make certain configurations reusable across your project by <a href="index-defining-services.html" class="page">defining services</a>.
Using your Java IDE along with a build tool supported by the framework, you can then compile your components to <a href="index-testing-components.html" class="page">test</a> and <a href="index-deploying-components.html" class="page">deploy</a> them to Talend Studio or other Talend applications:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="build-tools-maven.html" class="page">Building components with Maven</a></p>
</li>
<li>
<p><a href="build-tools-gradle.html" class="page">Building components with Gradle</a></p>
</li>
<li>
<p><a href="wrapping-a-beam-io.html" class="page">Wrapping a Beam I/O</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In any case, follow these <a href="best-practices.html" class="page">best practices</a> to ensure the components you develop are optimized.</p>
</div>
<div class="paragraph">
<p>You can also learn more about component loading and plugins here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="component-loading.html" class="page">Loading a component</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_registering_components"><a class="anchor" href="#_registering_components"></a>Registering components</h3>
<div class="paragraph">
<p>Before implementing a component logic and configuration, you need to specify the family and the category it belongs to, the component type and name, as well as its name and a few other generic parameters. This set of metadata, and more particularly the family, categories and component type, is mandatory to recognize and load the component to Talend Studio or Cloud applications.</p>
</div>
<div class="paragraph">
<p>Some of these parameters are handled at the project generation using the starter, but can still be accessed and updated later on.</p>
</div>
<div class="sect3">
<h4 id="_component_family_and_categories"><a class="anchor" href="#_component_family_and_categories"></a>Component family and categories</h4>
<div class="paragraph">
<p>The family and category of a component is automatically written in the <code>package-info.java</code> file of the component package, using the <code>@Components</code> annotation. By default, these parameters are already configured in this file when you import your project in your IDE. Their value correspond to what was defined during the project definition with the starter.</p>
</div>
<div class="paragraph">
<p>Multiple components can share the same <strong>family</strong> and <strong>category</strong> value, but the <strong>family</strong> + <strong>name</strong> pair must be unique for the system.</p>
</div>
<div class="paragraph">
<p>A component can belong to one family only and to one or several categories. If not specified, the category defaults to <code>Misc</code>.</p>
</div>
<div class="paragraph">
<p>The <code>package-info.java</code> file also defines the component family icon, which is different from the component icon. You can learn how to customize this icon in <a href="component-defining-custom-icon.html" class="page">this section</a>.</p>
</div>
<div class="paragraph">
<p>Here is a sample <code>package-info.java</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Components(name = "my_component_family", categories = "My Category")
package org.talend.sdk.component.sample;

import org.talend.sdk.component.api.component.Components;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example with an existing component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Components(name = "Salesforce", categories = {"Business", "Cloud"})
package org.talend.sdk.component.sample;

import org.talend.sdk.component.api.component.Components;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="icon_version"><a class="anchor" href="#icon_version"></a>Component icon and version</h4>
<div class="paragraph">
<p>Components can require metadata to be integrated in Talend Studio or Cloud platforms.
Metadata is set on the component class and belongs to the <code>org.talend.sdk.component.api.component</code> package.</p>
</div>
<div class="paragraph">
<p>When you generate your project and import it in your IDE, icon and version both come with a default value.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>@Icon</strong>: Sets an icon key used to represent the component.
You can use a custom key with the <code>custom()</code> method but the icon may not be rendered properly. The icon defaults to <strong>Check</strong>.<br>
Replace it with a custom icon, as described in <a href="component-defining-custom-icon.html" class="page">this section</a>.</p>
</li>
<li>
<p><strong>@Version</strong>: Sets the component version. 1 by default.<br>
Learn how to manage different versions and migrations between your component versions in <a href="component-versions-and-migration.html" class="page">this section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(1)
@Icon(FILE_XML_O)
@PartitionMapper(name = "jaxbInput")
public class JaxbPartitionMapper implements Serializable {
    // ...
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_defining_a_custom_icon_for_a_component_or_component_family"><a class="anchor" href="#_defining_a_custom_icon_for_a_component_or_component_family"></a>Defining a custom icon for a component or component family</h5>
<div class="paragraph">
<p>Every component family and component needs to have a representative icon.<br>
You have to define a custom icon as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For the component family the icon is defined in the <code>package-info.java</code> file.</p>
</li>
<li>
<p>For the component itself, you need to declare the icon in the component class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Custom icons must comply with the following requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Icons must be stored in the <code>src/main/resources/icons</code> folder of the project.</p>
</li>
<li>
<p>Icon file names need to match one of the following patterns: <code>IconName.svg</code> or <code>IconName_icon32.png</code>. The latter will run in degraded mode in Talend Cloud. Replace <code>IconName</code> by the name of your choice.</p>
</li>
<li>
<p>Icons must be squared, even for the SVG format.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Icon(value = Icon.IconType.CUSTOM, custom = "IconName")</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that SVG icons are not supported by Talend Studio and can cause the deployment of the component to fail.</p>
</div>
<div class="paragraph">
<p>If you aim at deploying a custom component to Talend Studio, specify PNG icons or use the Maven (or Gradle) <code>svg2png</code> plugin to convert SVG icons to PNG. If you want a finer control over both images, you can provide both in your component.</p>
</div>
<div class="paragraph">
<p>Ultimately, you can also remove SVG parameters from the <code>talend.component.server.icon.paths</code> property in the HTTP server configuration.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_component_type_and_name"><a class="anchor" href="#_component_type_and_name"></a>Component type and name</h4>
<div class="paragraph">
<p>The component type is declared in the component class. When you import your project generated from the starter in your IDE, the component type is already defined.</p>
</div>
<div class="paragraph">
<p><strong>Input</strong> components can be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A partition mapper. <code>@PartitionMapper</code> is the default for input components.</p>
</li>
<li>
<p>An emitter. <code>@Emitter</code> is a shortcut for <code>@PartitionMapper</code> when you don&#8217;t support distribution. It enforces an implicit partition mapper execution with an assessor size of 1 and a split returning itself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Processor</strong>/<strong>Output</strong> components can be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A processor. <code>@Processor</code> is the default for output components. A method decorated with <code>@Processor</code> is considered as a producer factory.</p>
</li>
<li>
<p>Combiners are not supported by the framework. Combiners allow to aggregate results in a single partition.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The name of the component is defined there as well as a parameter of the component type.</p>
</div>
<div class="paragraph">
<p>Once the component type is defined, you can start implementing its specific logic:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Partition mapper example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PartitionMapper(name = "my_mapper")
public class MyMapper {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Emitter example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Emitter(name = "my_input")
public class MyInput {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Processor example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Processor(name = "my_processor")
public class MyProcessor {
}</code></pre>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_6"><a class="anchor" href="#_related_articles_6"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-versions-and-migration.html" class="page">Managing component versions</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Defining component layout and configuration</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_datasets_and_datastores"><a class="anchor" href="#_defining_datasets_and_datastores"></a>Defining datasets and datastores</h3>
<div id="dataset-and-datastore" class="paragraph">
<p>Datasets and datastores are configuration types that define how and where to pull the data from. They are used at design time to create shared configurations that can be stored and used at runtime.</p>
</div>
<div class="paragraph">
<p>All input and output components created using Talend Component Kit must reference a valid dataset. Each dataset must reference a datastore.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Datastore: The data you need to connect to the backend.</p>
</li>
<li>
<p>Dataset: A datastore coupled with the data you need to execute an action.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/datastore_and_dataset_validation.png" target="_blank" rel="noopener"><img src="_images/datastore_and_dataset_validation.png" alt="Dataset validation"></a>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a datastore is used in each dataset.</p>
</li>
<li>
<p>each dataset has a corresponding input component (mapper or emitter) which has a configuration that is usable if the software only fills the dataset part. All other properties must not be required.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These rules are enforced by the <code>validateDataSet</code> validation. If the conditions are not met, the component builds will fail.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_defining_a_datastore_2"><a class="anchor" href="#_defining_a_datastore_2"></a>Defining a datastore</h4>
<div class="paragraph">
<p>A datastore defines the information required to connect to a data source. For example, it can be made of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a URL</p>
</li>
<li>
<p>a username</p>
</li>
<li>
<p>a password.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can specify a datastore and its context of use (in which dataset, etc.) from the <a href="tutorial-generate-project-using-starter.html" class="page">Component Kit Starter</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once you generate and import the project into an IDE, you can find your datastores under a specific <code>datastore</code> node.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/datastore_view_intellij.png" target="_blank" rel="noopener"><img src="_images/datastore_view_intellij.png" alt="Datastore view"></a>
</div>
</div>
<div class="paragraph">
<p>Example of datastore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.mycomponent.components.datastore;

@DataStore("DatastoreA") <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
    // the generated layout put one configuration entry per line,
    // customize it as much as needed
    @GridLayout.Row({ "apiurl" }),
    @GridLayout.Row({ "username" }),
    @GridLayout.Row({ "password" })
})
@Documentation("A Datastore made of an API URL, a username, and a password. The password is marked as Credential.") <i class="conum" data-value="3"></i><b>(3)</b>
public class DatastoreA implements Serializable {
    @Option
    @Documentation("")
    private String apiurl;

    @Option
    @Documentation("")
    private String username;

    @Option
    @Credential
    @Documentation("")
    private String password;

    public String getApiurl() {
        return apiurl;
    }

    public DatastoreA setApiurl(String apiurl) {
        this.apiurl = apiurl;
        return this;
    }

    public String getUsername() {
        return Username;
    }

    public DatastoreA setuUsername(String username) {
        this.username = username;
        return this;
    }

    public String getPassword() {
        return password;
    }

    public DatastoreA setPassword(String password) {
        this.password = password;
        return this;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identifying the class as a datastore and naming it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defining the layout of the datastore configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defining each element of the configuration: a URL, a username, and a password. Note that the password is also marked as being a credential.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_dataset_2"><a class="anchor" href="#_defining_a_dataset_2"></a>Defining a dataset</h4>
<div class="paragraph">
<p>A dataset represents the inbound data. It is generally made of:
* A datastore that defines the connection information needed to access the data.
* A query.</p>
</div>
<div class="paragraph">
<p>You can specify a dataset and its context of use (in which input and output component it is used) from the <a href="tutorial-generate-project-using-starter.html" class="page">Component Kit Starter</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once you generate and import the project into an IDE, you can find your datastores under a specific <code>dataset</code> node.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/dataset_view_intellij.png" target="_blank" rel="noopener"><img src="_images/dataset_view_intellij.png" alt="Dataset view"></a>
</div>
</div>
<div class="paragraph">
<p>Example of dataset referencing the datastore shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.datastorevalidation.components.dataset;

@DataSet("DatasetA") <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({
    // the generated layout put one configuration entry per line,
    // customize it as much as needed
    @GridLayout.Row({ "datastore" })
})
@Documentation("A Dataset configuration containing a simple datastore") <i class="conum" data-value="2"></i><b>(2)</b>
public class DatasetA implements Serializable {
    @Option
    @Documentation("Datastore")
    private DatastoreA datastore;

    public DatastoreA getDatastore() {
        return datastore;
    }

    public DatasetA setDatastore(DatastoreA datastore) {
        this.datastore = datastore;
        return this;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identifying the class as a dataset and naming it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Implementing the dataset and referencing DatastoreA as the datastore to use.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_internationalizing_datasets_and_datastores"><a class="anchor" href="#_internationalizing_datasets_and_datastores"></a>Internationalizing datasets and datastores</h4>
<div class="paragraph">
<p>The display name of each dataset and datastore must be referenced in the <code>message.properties</code> file of the family package.</p>
</div>
<div class="paragraph">
<p>The key for dataset and datastore display names follows a defined pattern: <code>${family}.${configurationType}.${name}._displayName</code>. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ComponentFamily.dataset.DatasetA._displayName=Dataset A
ComponentFamily.datastore.DatastoreA._displayName=Datastore A</code></pre>
</div>
</div>
<div class="paragraph">
<p>These keys are automatically added for datasets and datastores defined from the Component Kit Starter.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reusing_datasets_and_datastores_in_talend_studio"><a class="anchor" href="#_reusing_datasets_and_datastores_in_talend_studio"></a>Reusing datasets and datastores in Talend Studio</h4>
<div class="paragraph">
<p>When deploying a component or set of components that include datasets and datastores to Talend Studio, a new node is created under <strong>Metadata</strong>. This node has the name of the component family that was deployed.</p>
</div>
<div class="paragraph">
<p>It allows users to create reusable configurations for datastores and datasets.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/studio_create_dataset.png" target="_blank" rel="noopener"><img src="_images/studio_create_dataset.png" alt="Dataset in Studio"></a>
</div>
</div>
<div class="paragraph">
<p>With predefined datasets and datastores, users can then quickly fill the component configuration in their jobs. They can do so by selecting <strong>Repository</strong> as <strong>Property Type</strong> and by browsing to the predefined dataset or datastore.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/studio_select_predefined_dataset.png" target="_blank" rel="noopener"><img src="_images/studio_select_predefined_dataset.png" alt="Dataset in Component"></a>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_how_does_the_component_server_interact_with_datasets_and_datastores"><a class="anchor" href="#_how_does_the_component_server_interact_with_datasets_and_datastores"></a>How does the component server interact with datasets and datastores</h4>
<div class="paragraph">
<p>The component server scans all configuration types and returns a configuration type index. This index can be used for the integration into the targeted platforms (Studio, web applications, and so on).</p>
</div>
<div class="sect4">
<h5 id="_dataset"><a class="anchor" href="#_dataset"></a>Dataset</h5>
<div class="paragraph">
<p>Mark a model (complex object) as being a dataset.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: @org.talend.sdk.component.api.configuration.type.DataSet</p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "tcomp::configurationtype::name":"test",
  "tcomp::configurationtype::type":"dataset"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_datastore"><a class="anchor" href="#_datastore"></a>Datastore</h5>
<div class="paragraph">
<p>Mark a model (complex object) as being a datastore (connection to a backend).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: @org.talend.sdk.component.api.configuration.type.DataStore</p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "tcomp::configurationtype::name":"test",
  "tcomp::configurationtype::type":"datastore"
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The configuration type index is represented as a flat tree that contains all the configuration types, which themselves are represented as nodes and indexed by ID.</p>
</div>
<div class="paragraph">
<p>Every node can point to other nodes. This relation is represented as an array of edges that provides the child IDs.</p>
</div>
<div class="paragraph">
<p>As an illustration, a configuration type index for the example above can be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{nodes: {
             "idForDstore": { datastore:"datastore data", edges:[id:"idForDset"] },
             "idForDset":   { dataset:"dataset data" }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_an_input_component_logic"><a class="anchor" href="#_defining_an_input_component_logic"></a>Defining an input component logic</h3>
<div class="paragraph">
<p>Input components are the components generally placed at the beginning of a Talend job. They are in charge of retrieving the data that will later be processed in the job.</p>
</div>
<div class="paragraph">
<p>An input component is primarily made of three distinct logics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The execution logic of the component itself, defined through a partition mapper.</p>
</li>
<li>
<p>The configurable part of the component, defined through the mapper configuration.</p>
</li>
<li>
<p>The source logic defined through a producer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before implementing the component logic and defining its layout and configurable fields, make sure you have specified its basic metadata, as detailed in <a href="component-registering.html" class="page">this document</a>.</p>
</div>
<div class="sect3">
<h4 id="_defining_a_partition_mapper"><a class="anchor" href="#_defining_a_partition_mapper"></a>Defining a partition mapper</h4>
<div class="sect4">
<h5 id="partition-mapper"><a class="anchor" href="#partition-mapper"></a>What is a partition mapper</h5>
<div class="paragraph">
<p>A <strong>Partition Mapper</strong> (<code>PartitionMapper</code>) is a component able to split itself to make the execution more efficient.</p>
</div>
<div class="paragraph">
<p>This concept is borrowed from big data and useful in this context only (<code>BEAM</code> executions).
The idea is to divide the work before executing it in order to reduce the overall execution time.</p>
</div>
<div class="paragraph">
<p>The process is the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The size of the data you work on is estimated. This part can be heuristic and not very precise.</p>
</li>
<li>
<p>From that size, the execution engine (<em>runner</em> for Beam) requests the mapper to split <em>itself</em> in <em>N</em> mappers with a subset of the overall work.</p>
</li>
<li>
<p>The <em>leaf</em> (final) mapper is used as a <code>Producer</code> (actual reader) factory.</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This kind of component must be <code>Serializable</code> to be distributable.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_implementing_a_partition_mapper"><a class="anchor" href="#_implementing_a_partition_mapper"></a>Implementing a partition mapper</h5>
<div class="paragraph">
<p>A partition mapper requires three methods marked with specific annotations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>@Assessor</code> for the evaluating method</p>
</li>
<li>
<p><code>@Split</code> for the dividing method</p>
</li>
<li>
<p><code>@Emitter</code> for the <code>Producer</code> factory</p>
</li>
</ol>
</div>
<div class="sect5">
<h6 id="_assessor"><a class="anchor" href="#_assessor"></a>@Assessor</h6>
<div class="paragraph">
<p>The Assessor method returns the estimated size of the data related to the component (depending its configuration).
It must return a <code>Number</code> and must not take any parameter.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock initial-block-closed">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Assessor
public long estimateDataSetByteSize() {
    return ....;
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_split"><a class="anchor" href="#_split"></a>@Split</h6>
<div class="paragraph">
<p>The Split method returns a collection of partition mappers and can take optionally a <code>@PartitionSize</code> long value as parameter, which is the requested size of the dataset per sub partition mapper.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Split
public List&lt;MyMapper&gt; split(@PartitionSize final long desiredSize) {
    return ....;
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_emitter"><a class="anchor" href="#_emitter"></a>@Emitter</h6>
<div class="paragraph">
<p>The Emitter method must not have any parameter and must return a producer. It uses the partition mapper configuration to instantiate and configure the producer.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Emitter
public MyProducer create() {
    return ....;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_producer_method"><a class="anchor" href="#_defining_the_producer_method"></a>Defining the producer method</h4>
<div class="paragraph">
<p>The <strong>Producer</strong> defines the source logic of an input component. It handles the interaction with a physical source and produces input data for the processing flow.</p>
</div>
<div class="paragraph">
<p>A producer must have a <code>@Producer</code> method without any parameter. It is triggered by the <code>@Emitter</code> method of the partition mapper and can return any data. It is defined in the <code>&lt;component_name&gt;Source.java</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Producer
public MyData produces() {
    return ...;
}</code></pre>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_7"><a class="anchor" href="#_related_articles_7"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-execution.html" class="page">General component execution logic</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Defining component layout and configuration</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="component-implementing-streaming.html" class="page">Implementing streaming on a component</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_processor_or_an_output_component_logic"><a class="anchor" href="#_defining_a_processor_or_an_output_component_logic"></a>Defining a processor or an output component logic</h3>
<div class="paragraph">
<p>Processors and output components are the components in charge of reading, processing and transforming data in a Talend job, as well as passing it to its required destination.</p>
</div>
<div class="paragraph">
<p>Before implementing the component logic and defining its layout and configurable fields, make sure you have specified its basic metadata, as detailed in <a href="component-registering.html" class="page">this document</a>.</p>
</div>
<div class="sect3">
<h4 id="_defining_a_processor"><a class="anchor" href="#_defining_a_processor"></a>Defining a processor</h4>
<div class="sect4">
<h5 id="component-type-processor"><a class="anchor" href="#component-type-processor"></a>What is a processor</h5>
<div class="paragraph">
<p>A <strong>Processor</strong> is a component that converts incoming data to a different model.</p>
</div>
<div class="paragraph">
<p>A processor must have a method decorated with <code>@ElementListener</code> taking an incoming data and returning the processed data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public MyNewData map(final MyData data) {
    return ...;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Processors must be <strong>Serializable</strong> because they are distributed components.</p>
</div>
<div class="paragraph">
<p>If you just need to access data on a map-based ruleset, you can use <code>Record</code> or <code>JsonObject</code> as parameter type.<br>
From there, Talend Component Kit wraps the data to allow you to access it as a map. The parameter type is not enforced.<br>
This means that if you know you will get a <code>SuperCustomDto</code>, then you can use it as parameter type. But for generic components that are reusable in any chain, it is highly encouraged to use <code>Record</code> until you have an evaluation language-based processor that has its own way to access components.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public MyNewData map(final Record incomingData) {
    String name = incomingData.getString("name");
    int name = incomingData.getInt("age");
    return ...;
}

// equivalent to (using POJO subclassing)

public class Person {
    private String age;
    private int age;

    // getters/setters
}

@ElementListener
public MyNewData map(final Person person) {
    String name = person.getName();
    int age = person.getAge();
    return ...;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A processor also supports <code>@BeforeGroup</code> and <code>@AfterGroup</code> methods, which must not have any parameter and return <code>void</code> values. Any other result would be ignored.
These methods are used by the runtime to mark a chunk of the data in a way which is estimated <em>good</em> for the execution flow size.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the size is estimated, the size of a <em>group</em> can vary. It is even possible to have groups of size <code>1</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is recommended to batch records, for performance reasons:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@BeforeGroup
public void initBatch() {
    // ...
}

@AfterGroup
public void endBatch() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can optimize the data batch processing by using the <code>maxBatchSize</code> parameter. This parameter is automatically implemented on the component when it is deployed to a Talend application. Only the logic needs to be implemented. You can however customize its value setting in your <code>LocalConfiguration</code> the property <code>_maxBatchSize.value</code> - for the family - or <code>${component simple class name}._maxBatchSize.value</code> - for a particular component, otherwise its default will be <code>1000</code>. If you replace <code>value</code> by <code>active</code>, you can also configure if this feature is enabled or not. This is useful when you don&#8217;t want to use it at all. Learn how to implement chunking/bulking in <a href="concept-processor-and-batch-processing.html" class="page">this document</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_defining_output_connections"><a class="anchor" href="#_defining_output_connections"></a>Defining output connections</h5>
<div class="paragraph">
<p>In some cases, you may need to split the output of a processor in two or more connections. A common example is to have "main" and "reject" output connections where part of the incoming data are passed to a specific bucket and processed later.</p>
</div>
<div class="paragraph">
<p>Talend Component Kit supports two types of output connections: Flow and Reject.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Flow</strong> is the main and standard output connection.</p>
</li>
<li>
<p>The <strong>Reject</strong> connection handles records rejected during the processing. A component can only have one reject connection, if any. Its name must be <code>REJECT</code> to be processed correctly in Talend applications.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also define the different output connections of your component in the Starter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To define an output connection, you can use <code>@Output</code> as replacement of the returned value in the <code>@ElementListener</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public void map(final MyData data, @Output final OutputEmitter&lt;MyNewData&gt; output) {
    output.emit(createNewData(data));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can pass a string that represents the new branch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public void map(final MyData data,
                @Output final OutputEmitter&lt;MyNewData&gt; main,
                @Output("REJECT") final OutputEmitter&lt;MyNewDataWithError&gt; rejected) {
    if (isRejected(data)) {
        rejected.emit(createNewData(data));
    } else {
        main.emit(createNewData(data));
    }
}

// or

@ElementListener
public MyNewData map(final MyData data,
                    @Output("REJECT") final OutputEmitter&lt;MyNewDataWithError&gt; rejected) {
    if (isSuspicious(data)) {
        rejected.emit(createNewData(data));
        return createNewData(data); // in this case the processing continues but notifies another channel
    }
    return createNewData(data);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_defining_multiple_inputs"><a class="anchor" href="#_defining_multiple_inputs"></a>Defining multiple inputs</h5>
<div class="paragraph">
<p>Having multiple inputs is similar to having multiple outputs, except that an <code>OutputEmitter</code> wrapper is not needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public MyNewData map(@Input final MyData data, @Input("input2") final MyData2 data2) {
    return createNewData(data1, data2);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@Input</code> takes the input name as parameter. If no name is set, it defaults to the "main (default)" input branch. It is recommended to use the default branch when possible and to avoid naming branches according to the component semantic.</p>
</div>
</div>
<div class="sect4">
<h5 id="_implementing_batch_processing"><a class="anchor" href="#_implementing_batch_processing"></a>Implementing batch processing</h5>
<div class="paragraph">
<p>Depending on several requirements, including the system capacity and business needs, a processor can process records differently.</p>
</div>
<div class="paragraph">
<p>For example, for real-time or near-real time processing, it is more interesting to process small batches of data more often. On the other hand, in case of one-time processing, it is more optimal to adapt the way the component handles batches of data according to the system capacity.</p>
</div>
<div class="paragraph">
<p>By default, the runtime automatically estimates a group size that it considers good, according to the system capacity, to process the data. This group size can sometimes be too big and not optimal for your needs or for your system to handle effectively and correctly.</p>
</div>
<div class="paragraph">
<p>Users can then customize this size from the component settings in Talend Studio, by specifying a <code>maxBatchSize</code> that adapts the size of each group of data to be processed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The estimated group size logic is automatically implemented when a component is deployed to a Talend application. Besides defining the @BeforeGroup and @AfterGroup logic detailed below, no action is required on the implementation side of the component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The component batch processes the data as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Case 1 - No <code>maxBatchSize</code> is specified in the component configuration. The runtime estimates a group size of 4. Records are processed by groups of 4.</p>
</li>
<li>
<p>Case 2 - The runtime estimates a group size of 4 but a <code>maxBatchSize</code> of 3 is specified in the component configuration. The system adapts the group size to 3. Records are processed by groups of 3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title"><strong>Processing schema (values are examples):</strong></div>
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/batch-processing-maxbatchsize.png" target="_blank" rel="noopener"><img src="_images/batch-processing-maxbatchsize.png" alt="Batch processing"></a></span></p>
</div>
<div class="paragraph">
<p>Each group is processed as follows until there is no record left:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>@BeforeGroup</code> method resets a record buffer at the beginning of each group.</p>
</li>
<li>
<p>The records of the group are assessed one by one and placed in the buffer as follows: The <code>@ElementListener</code> method tests if the buffer size is greater or equal to the defined <code>maxBatchSize</code>. If it is, the records are processed. If not, then the current record is buffered.</p>
</li>
<li>
<p>The previous step happens for all records of the group. Then the <code>@AfterGroup</code> method tests if the buffer is empty.</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title"><strong>Group execution detail (values are examples):</strong></div>
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/batch-processing-group.png" target="_blank" rel="noopener"><img src="_images/batch-processing-group.png" alt="Group batch processing"></a></span></p>
</div>
<div class="paragraph">
<p>You can define the following logic in the processor configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;

import javax.json.JsonObject;

import org.talend.sdk.component.api.processor.AfterGroup;
import org.talend.sdk.component.api.processor.BeforeGroup;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.processor.Processor;

@Processor(name = "BulkOutputDemo")
public class BulkProcessor implements Serializable {
    private Collection&lt;JsonObject&gt; buffer;

    @BeforeGroup
    public void begin() {
        buffer = new ArrayList&lt;&gt;();
    }

    @ElementListener
    public void bufferize(final JsonObject object) {
        buffer.add(object);
    }

    @AfterGroup
    public void commit() {
        // save buffered records at once (bulk)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the condensed syntax for this kind of processor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Processor(name = "BulkOutputDemo")
public class BulkProcessor implements Serializable {

    @AfterGroup
    public void commit(final Collection&lt;Record&gt; records) {
        // save records
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When writing tests for your components, you can force the <code>maxBatchSize</code> parameter value by setting it with the following syntax: <code>&lt;configuration prefix&gt;.$maxBatchSize=10</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can learn more about processors in <a href="component-define-processor-output.html" class="page">this document</a>.</p>
</div>
<div class="sect5 relatedlinks">
<h6 id="_related_articles_8"><a class="anchor" href="#_related_articles_8"></a>Related articles</h6>
<div class="ulist">
<ul>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor/output logic</a></p>
</li>
<li>
<p><a href="component-execution.html" class="page">General component execution logic</a></p>
</li>
<li>
<p><a href="concept-processor-and-batch-processing.html" class="page">Implementing bulk processing</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_shortcut_syntax_for_bulk_output_processors"><a class="anchor" href="#_shortcut_syntax_for_bulk_output_processors"></a>Shortcut syntax for bulk output processors</h5>
<div class="paragraph">
<p>For the case of output components (not emitting any data) using bulking you can pass the list of records to the after group method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Processor(name = "DocOutput")
public class DocOutput implements Serializable {

    @AfterGroup
    public void onCommit(final Collection&lt;Record&gt; records) {
        // save records
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_an_output"><a class="anchor" href="#_defining_an_output"></a>Defining an output</h4>
<div class="sect4">
<h5 id="_what_is_an_output"><a class="anchor" href="#_what_is_an_output"></a>What is an output</h5>
<div class="paragraph">
<p>An <strong>Output</strong> is a <strong>Processor</strong> that does not return any data.</p>
</div>
<div class="paragraph">
<p>Conceptually, an output is a data listener. It matches the concept of processor. Being the last component of the execution chain or returning no data makes your processor an output component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
public void store(final MyData data) {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_combiner"><a class="anchor" href="#_defining_a_combiner"></a>Defining a combiner</h4>
<div class="sect4">
<h5 id="_what_is_a_combiner"><a class="anchor" href="#_what_is_a_combiner"></a>What is a combiner</h5>
<div class="paragraph">
<p>Currently, Talend Component Kit does not allow you to define a <strong>Combiner</strong>.
A combiner is the symmetric part of a partition mapper. It allows to aggregate results in a single partition.</p>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_9"><a class="anchor" href="#_related_articles_9"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-execution.html" class="page">General component execution logic</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Defining component layout and configuration</a></p>
</li>
<li>
<p><a href="concept-processor-and-batch-processing.html" class="page">Implementing bulk processing</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_component_layout_and_configuration"><a class="anchor" href="#_defining_component_layout_and_configuration"></a>Defining component layout and configuration</h3>
<div class="paragraph">
<p>The component configuration is defined in the <code>&lt;component_name&gt;Configuration.java</code> file of the package. It consists in defining the configurable part of the component that will be displayed in the UI.</p>
</div>
<div class="paragraph">
<p>To do that, you can specify parameters. When you import the project in your IDE, the parameters that you have specified in the starter are already present.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All input and output components must reference a dataset in their configuration. Refer to <a href="creating-dataset-datastore.html" class="page">Defining datasets and datastores</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_parameter_name"><a class="anchor" href="#_parameter_name"></a>Parameter name</h4>
<div class="paragraph">
<p>Components are configured using their constructor parameters. All parameters can be marked with the <code>@Option</code> property, which lets you give a name to them.</p>
</div>
<div class="paragraph">
<p>For the name to be correct, you must follow these guidelines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a valid Java name.</p>
</li>
<li>
<p>Do not include any <code>.</code> character in it.</p>
</li>
<li>
<p>Do not start the name with a <code>$</code>.</p>
</li>
<li>
<p>Defining a name is optional. If you don&#8217;t set a specific name, it defaults to the bytecode name. This can require you to compile with a <code>-parameter</code> flag to avoid ending up with names such as <strong>arg0</strong>, <strong>arg1</strong>, and so on.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Examples of option name:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Option name</th>
<th class="tableblock halign-center valign-top">Valid</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">myName</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my_name</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my.name</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon mediumvioletred"><i class="fa fa-times"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$myName</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><span class="icon mediumvioletred"><i class="fa fa-times"></i></span></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_parameter_types"><a class="anchor" href="#_parameter_types"></a>Parameter types</h4>
<div class="paragraph">
<p>Parameter types can be <em>primitives</em> or complex objects with fields decorated with <code>@Option</code> exactly like method parameters.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
It is recommended to use simple models which can be serialized in order to ease serialized component implementations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class FileFormat implements Serializable {
    @Option("type")
    private FileType type = FileType.CSV;

    @Option("max-records")
    private int maxRecords = 1024;
}

@PartitionMapper(name = "file-reader")
public MyFileReader(@Option("file-path") final File file,
                    @Option("file-format") final FileFormat format) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this kind of API makes the configuration extensible and component-oriented, which allows you to define all you need.</p>
</div>
<div class="paragraph">
<p>The instantiation of the parameters is done from the properties passed to the component.</p>
</div>
<div class="sect4">
<h5 id="_primitives"><a class="anchor" href="#_primitives"></a>Primitives</h5>
<div class="paragraph">
<p>A primitive is a class which can be directly converted from a <code>String</code> to the expected type.</p>
</div>
<div class="paragraph">
<p>It includes all Java primitives, like the <code>String</code> type itself, but also all types with a <code>org.apache.xbean.propertyeditor.Converter</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BigDecimal</code></p>
</li>
<li>
<p><code>BigInteger</code></p>
</li>
<li>
<p><code>File</code></p>
</li>
<li>
<p><code>InetAddress</code></p>
</li>
<li>
<p><code>ObjectName</code></p>
</li>
<li>
<p><code>URI</code></p>
</li>
<li>
<p><code>URL</code></p>
</li>
<li>
<p><code>Pattern</code></p>
</li>
<li>
<p><code>LocalDateTime</code></p>
</li>
<li>
<p><code>ZonedDateTime</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_complex_objects"><a class="anchor" href="#_mapping_complex_objects"></a>Mapping complex objects</h4>
<div class="paragraph">
<p>The conversion from property to object uses the Dot notation.</p>
</div>
<div class="paragraph">
<p>For example, assuming the method parameter was configured with <code>@Option("file")</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">file.path = /home/user/input.csv
file.format = CSV</code></pre>
</div>
</div>
<div class="paragraph">
<p>matches</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class FileOptions {
    @Option("path")
    private File path;

    @Option("format")
    private Format format;
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_list_case"><a class="anchor" href="#_list_case"></a>List case</h5>
<div class="paragraph">
<p>Lists rely on an indexed syntax to define their elements.</p>
</div>
<div class="paragraph">
<p>For example, assuming that the list parameter is named <code>files</code> and that the elements are of the  <code>FileOptions</code> type, you can define a list of two elements as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">files[0].path = /home/user/input1.csv
files[0].format = CSV
files[1].path = /home/user/input2.xml
files[1].format = EXCEL</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
if you desire to override a config to truncate an array, use the index <code>length</code>, for example to truncate previous example to only CSV, you can set:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">files[length] = 1</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_map_case"><a class="anchor" href="#_map_case"></a>Map case</h5>
<div class="paragraph">
<p>Similarly to the list case, the map uses <code>.key[index]</code> and <code>.value[index]</code> to represent its keys and values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">// Map&lt;String, FileOptions&gt;
files.key[0] = first-file
files.value[0].path = /home/user/input1.csv
files.value[0].type = CSV
files.key[1] = second-file
files.value[1].path = /home/user/input2.xml
files.value[1].type = EXCEL</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">// Map&lt;FileOptions, String&gt;
files.key[0].path = /home/user/input1.csv
files.key[0].type = CSV
files.value[0] = first-file
files.key[1].path = /home/user/input2.xml
files.key[1].type = EXCEL
files.value[1] = second-file</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Avoid using the Map type. Instead, prefer configuring your component with an object if this is possible.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_constraints_and_validations_on_the_configuration"><a class="anchor" href="#_defining_constraints_and_validations_on_the_configuration"></a>Defining Constraints and validations on the configuration</h4>
<div class="paragraph">
<p>You can use metadata to specify that a field is required or has a minimum size, and so on. This is done using the <code>validation</code> metadata in the <code>org.talend.sdk.component.api.configuration.constraint</code> package:</p>
</div>
<div class="sect4">
<h5 id="_maxlength"><a class="anchor" href="#_maxlength"></a>MaxLength</h5>
<div class="paragraph">
<p>Ensure the decorated option size is validated with a higher bound.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Max</code></p>
</li>
<li>
<p>Name: <code>maxLength</code></p>
</li>
<li>
<p>Parameter Type: <code>double</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.lang.CharSequence</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::maxLength":"12.34"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_minlength"><a class="anchor" href="#_minlength"></a>MinLength</h5>
<div class="paragraph">
<p>Ensure the decorated option size is validated with a lower bound.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Min</code></p>
</li>
<li>
<p>Name: <code>minLength</code></p>
</li>
<li>
<p>Parameter Type: <code>double</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.lang.CharSequence</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::minLength":"12.34"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pattern"><a class="anchor" href="#_pattern"></a>Pattern</h5>
<div class="paragraph">
<p>Validate the decorated string with a <strong>javascript</strong> pattern (even into the Studio).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Pattern</code></p>
</li>
<li>
<p>Name: <code>pattern</code></p>
</li>
<li>
<p>Parameter Type: <code>java.lang.string</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.lang.CharSequence</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::pattern":"test"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_max"><a class="anchor" href="#_max"></a>Max</h5>
<div class="paragraph">
<p>Ensure the decorated option size is validated with a higher bound.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Max</code></p>
</li>
<li>
<p>Name: <code>max</code></p>
</li>
<li>
<p>Parameter Type: <code>double</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.lang.Number</code>&#8201;&#8212;&#8201;<code>int</code>&#8201;&#8212;&#8201;<code>short</code>&#8201;&#8212;&#8201;<code>byte</code>&#8201;&#8212;&#8201;<code>long</code>&#8201;&#8212;&#8201;<code>double</code>&#8201;&#8212;&#8201;<code>float</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::max":"12.34"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_min"><a class="anchor" href="#_min"></a>Min</h5>
<div class="paragraph">
<p>Ensure the decorated option size is validated with a lower bound.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Min</code></p>
</li>
<li>
<p>Name: <code>min</code></p>
</li>
<li>
<p>Parameter Type: <code>double</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.lang.Number</code>&#8201;&#8212;&#8201;<code>int</code>&#8201;&#8212;&#8201;<code>short</code>&#8201;&#8212;&#8201;<code>byte</code>&#8201;&#8212;&#8201;<code>long</code>&#8201;&#8212;&#8201;<code>double</code>&#8201;&#8212;&#8201;<code>float</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::min":"12.34"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_required"><a class="anchor" href="#_required"></a>Required</h5>
<div class="paragraph">
<p>Mark the field as being mandatory.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Required</code></p>
</li>
<li>
<p>Name: <code>required</code></p>
</li>
<li>
<p>Parameter Type: <code>-</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.lang.Object</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::required":"true"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_maxitems"><a class="anchor" href="#_maxitems"></a>MaxItems</h5>
<div class="paragraph">
<p>Ensure the decorated option size is validated with a higher bound.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Max</code></p>
</li>
<li>
<p>Name: <code>maxItems</code></p>
</li>
<li>
<p>Parameter Type: <code>double</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.util.Collection</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::maxItems":"12.34"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_minitems"><a class="anchor" href="#_minitems"></a>MinItems</h5>
<div class="paragraph">
<p>Ensure the decorated option size is validated with a lower bound.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Min</code></p>
</li>
<li>
<p>Name: <code>minItems</code></p>
</li>
<li>
<p>Parameter Type: <code>double</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.util.Collection</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::minItems":"12.34"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_uniqueitems"><a class="anchor" href="#_uniqueitems"></a>UniqueItems</h5>
<div class="paragraph">
<p>Ensure the elements of the collection must be distinct (kind of set).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.constraint.Uniques</code></p>
</li>
<li>
<p>Name: <code>uniqueItems</code></p>
</li>
<li>
<p>Parameter Type: <code>-</code></p>
</li>
<li>
<p>Supported Types:&#8201;&#8212;&#8201;<code>java.util.Collection</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "validation::uniqueItems":"true"
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using the programmatic API, metadata is prefixed by <code>tcomp::</code>. This prefix is stripped in the web for convenience, and the table above uses the web keys.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also note that these validations are executed before the runtime is started (when loading the component instance) and that the execution will fail if they don&#8217;t pass.
If it breaks your application, you can disable that validation on the JVM by setting the system property <code>talend.component.configuration.validation.skip</code> to <code>true</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_datasets_and_datastores_2"><a class="anchor" href="#_defining_datasets_and_datastores_2"></a>Defining datasets and datastores</h4>
<div id="dataset-and-datastore" class="paragraph">
<p>Datasets and datastores are configuration types that define how and where to pull the data from. They are used at design time to create shared configurations that can be stored and used at runtime.</p>
</div>
<div class="paragraph">
<p>All input and output components created using Talend Component Kit must reference a valid dataset. Each dataset must reference a datastore.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Datastore: The data you need to connect to the backend.</p>
</li>
<li>
<p>Dataset: A datastore coupled with the data you need to execute an action.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/datastore_and_dataset_validation.png" target="_blank" rel="noopener"><img src="_images/datastore_and_dataset_validation.png" alt="Dataset validation"></a>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a datastore is used in each dataset.</p>
</li>
<li>
<p>each dataset has a corresponding input component (mapper or emitter) which has a configuration that is usable if the software only fills the dataset part. All other properties must not be required.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These rules are enforced by the <code>validateDataSet</code> validation. If the conditions are not met, the component builds will fail.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_defining_a_datastore_3"><a class="anchor" href="#_defining_a_datastore_3"></a>Defining a datastore</h5>
<div class="paragraph">
<p>A datastore defines the information required to connect to a data source. For example, it can be made of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a URL</p>
</li>
<li>
<p>a username</p>
</li>
<li>
<p>a password.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can specify a datastore and its context of use (in which dataset, etc.) from the <a href="tutorial-generate-project-using-starter.html" class="page">Component Kit Starter</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once you generate and import the project into an IDE, you can find your datastores under a specific <code>datastore</code> node.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/datastore_view_intellij.png" target="_blank" rel="noopener"><img src="_images/datastore_view_intellij.png" alt="Datastore view"></a>
</div>
</div>
<div class="paragraph">
<p>Example of datastore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.mycomponent.components.datastore;

@DataStore("DatastoreA") <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
    // the generated layout put one configuration entry per line,
    // customize it as much as needed
    @GridLayout.Row({ "apiurl" }),
    @GridLayout.Row({ "username" }),
    @GridLayout.Row({ "password" })
})
@Documentation("A Datastore made of an API URL, a username, and a password. The password is marked as Credential.") <i class="conum" data-value="3"></i><b>(3)</b>
public class DatastoreA implements Serializable {
    @Option
    @Documentation("")
    private String apiurl;

    @Option
    @Documentation("")
    private String username;

    @Option
    @Credential
    @Documentation("")
    private String password;

    public String getApiurl() {
        return apiurl;
    }

    public DatastoreA setApiurl(String apiurl) {
        this.apiurl = apiurl;
        return this;
    }

    public String getUsername() {
        return Username;
    }

    public DatastoreA setuUsername(String username) {
        this.username = username;
        return this;
    }

    public String getPassword() {
        return password;
    }

    public DatastoreA setPassword(String password) {
        this.password = password;
        return this;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identifying the class as a datastore and naming it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defining the layout of the datastore configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defining each element of the configuration: a URL, a username, and a password. Note that the password is also marked as being a credential.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_defining_a_dataset_3"><a class="anchor" href="#_defining_a_dataset_3"></a>Defining a dataset</h5>
<div class="paragraph">
<p>A dataset represents the inbound data. It is generally made of:
* A datastore that defines the connection information needed to access the data.
* A query.</p>
</div>
<div class="paragraph">
<p>You can specify a dataset and its context of use (in which input and output component it is used) from the <a href="tutorial-generate-project-using-starter.html" class="page">Component Kit Starter</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once you generate and import the project into an IDE, you can find your datastores under a specific <code>dataset</code> node.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/dataset_view_intellij.png" target="_blank" rel="noopener"><img src="_images/dataset_view_intellij.png" alt="Dataset view"></a>
</div>
</div>
<div class="paragraph">
<p>Example of dataset referencing the datastore shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.datastorevalidation.components.dataset;

@DataSet("DatasetA") <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({
    // the generated layout put one configuration entry per line,
    // customize it as much as needed
    @GridLayout.Row({ "datastore" })
})
@Documentation("A Dataset configuration containing a simple datastore") <i class="conum" data-value="2"></i><b>(2)</b>
public class DatasetA implements Serializable {
    @Option
    @Documentation("Datastore")
    private DatastoreA datastore;

    public DatastoreA getDatastore() {
        return datastore;
    }

    public DatasetA setDatastore(DatastoreA datastore) {
        this.datastore = datastore;
        return this;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Identifying the class as a dataset and naming it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Implementing the dataset and referencing DatastoreA as the datastore to use.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_internationalizing_datasets_and_datastores_2"><a class="anchor" href="#_internationalizing_datasets_and_datastores_2"></a>Internationalizing datasets and datastores</h5>
<div class="paragraph">
<p>The display name of each dataset and datastore must be referenced in the <code>message.properties</code> file of the family package.</p>
</div>
<div class="paragraph">
<p>The key for dataset and datastore display names follows a defined pattern: <code>${family}.${configurationType}.${name}._displayName</code>. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ComponentFamily.dataset.DatasetA._displayName=Dataset A
ComponentFamily.datastore.DatastoreA._displayName=Datastore A</code></pre>
</div>
</div>
<div class="paragraph">
<p>These keys are automatically added for datasets and datastores defined from the Component Kit Starter.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reusing_datasets_and_datastores_in_talend_studio_2"><a class="anchor" href="#_reusing_datasets_and_datastores_in_talend_studio_2"></a>Reusing datasets and datastores in Talend Studio</h5>
<div class="paragraph">
<p>When deploying a component or set of components that include datasets and datastores to Talend Studio, a new node is created under <strong>Metadata</strong>. This node has the name of the component family that was deployed.</p>
</div>
<div class="paragraph">
<p>It allows users to create reusable configurations for datastores and datasets.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/studio_create_dataset.png" target="_blank" rel="noopener"><img src="_images/studio_create_dataset.png" alt="Dataset in Studio"></a>
</div>
</div>
<div class="paragraph">
<p>With predefined datasets and datastores, users can then quickly fill the component configuration in their jobs. They can do so by selecting <strong>Repository</strong> as <strong>Property Type</strong> and by browsing to the predefined dataset or datastore.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/studio_select_predefined_dataset.png" target="_blank" rel="noopener"><img src="_images/studio_select_predefined_dataset.png" alt="Dataset in Component"></a>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_how_does_the_component_server_interact_with_datasets_and_datastores_2"><a class="anchor" href="#_how_does_the_component_server_interact_with_datasets_and_datastores_2"></a>How does the component server interact with datasets and datastores</h5>
<div class="paragraph">
<p>The component server scans all configuration types and returns a configuration type index. This index can be used for the integration into the targeted platforms (Studio, web applications, and so on).</p>
</div>
<div class="sect5">
<h6 id="_dataset_2"><a class="anchor" href="#_dataset_2"></a>Dataset</h6>
<div class="paragraph">
<p>Mark a model (complex object) as being a dataset.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: @org.talend.sdk.component.api.configuration.type.DataSet</p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "tcomp::configurationtype::name":"test",
  "tcomp::configurationtype::type":"dataset"
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_datastore_2"><a class="anchor" href="#_datastore_2"></a>Datastore</h6>
<div class="paragraph">
<p>Mark a model (complex object) as being a datastore (connection to a backend).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: @org.talend.sdk.component.api.configuration.type.DataStore</p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "tcomp::configurationtype::name":"test",
  "tcomp::configurationtype::type":"datastore"
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The configuration type index is represented as a flat tree that contains all the configuration types, which themselves are represented as nodes and indexed by ID.</p>
</div>
<div class="paragraph">
<p>Every node can point to other nodes. This relation is represented as an array of edges that provides the child IDs.</p>
</div>
<div class="paragraph">
<p>As an illustration, a configuration type index for the example above can be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{nodes: {
             "idForDstore": { datastore:"datastore data", edges:[id:"idForDset"] },
             "idForDset":   { dataset:"dataset data" }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_links_between_properties"><a class="anchor" href="#_defining_links_between_properties"></a>Defining links between properties</h4>
<div class="paragraph">
<p>If you need to define a binding between properties, you can use a set of annotations:</p>
</div>
<div class="sect4">
<h5 id="_activeif"><a class="anchor" href="#_activeif"></a>ActiveIf</h5>
<div class="paragraph">
<p>If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.condition.ActiveIf</code></p>
</li>
<li>
<p>Type: <code>if</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "condition::if::evaluationStrategy":"DEFAULT",
  "condition::if::negate":"false",
  "condition::if::target":"test",
  "condition::if::value":"value1,value2"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_activeifs"><a class="anchor" href="#_activeifs"></a>ActiveIfs</h5>
<div class="paragraph">
<p>Allows to set multiple visibility conditions on the same property.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.condition.ActiveIfs</code></p>
</li>
<li>
<p>Type: <code>ifs</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "condition::if::evaluationStrategy::0":"DEFAULT",
  "condition::if::evaluationStrategy::1":"LENGTH",
  "condition::if::negate::0":"false",
  "condition::if::negate::1":"true",
  "condition::if::target::0":"sibling1",
  "condition::if::target::1":"../../other",
  "condition::if::value::0":"value1,value2",
  "condition::if::value::1":"SELECTED",
  "condition::ifs::operator":"AND"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>target</strong> is the element to evaluate.</p>
</li>
<li>
<p><strong>value</strong> is the value to compare against.</p>
</li>
<li>
<p><strong>strategy</strong> (optional) is the evaluation criteria. Possible values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>CONTAINS</code>: Checks if a string or list of strings contains the defined <strong>value</strong>.</p>
</li>
<li>
<p><code>DEFAULT</code>: Compares against the raw <strong>value</strong>.</p>
</li>
<li>
<p><code>LENGTH</code>: For an array or string, evaluates the size of the <strong>value</strong> instead of the <strong>value</strong> itself.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>negate</strong> (optional) defines if the test must be positive (default, set to <code>false</code>) or negative (set to <code>true</code>).</p>
</li>
<li>
<p><strong>operator</strong> (optional) is the comparison operator used to combine several conditions, if applicable. Possible values are <code>AND</code> and <code>OR</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <strong>target</strong> element location is specified as a relative path to the current location, using Unix path characters.
The configuration class delimiter is <code>/</code>.<br>
The parent configuration class is specified by <code>..</code>.<br>
Thus, <code>../targetProperty</code> denotes a property, which is located in the parent configuration class and is named <code>targetProperty</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using the programmatic API, metadata is prefixed with <code>tcomp::</code>. This prefix is stripped in the web for convenience, and the previous table uses the web keys.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more details, refer to the related <a href="apidocs.html" class="page">Javadocs</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_activeif_examples"><a class="anchor" href="#_activeif_examples"></a>ActiveIf examples</h5>
<div class="sect5">
<h6 id="_example_1"><a class="anchor" href="#_example_1"></a>Example 1</h6>
<div class="paragraph">
<p>A common use of the ActiveIf condition consists in testing if a target property has a value. To do that, it is possible to test if the length of the property value is different from 0:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>target: <code>foo</code> - the path to the property to evaluate.</p>
</li>
<li>
<p>strategy: <code>LENGTH</code> - the strategy consists here in testing the length of the property value.</p>
</li>
<li>
<p>value: <code>0</code> - the length of the property value is compared to <code>0</code>.</p>
</li>
<li>
<p>negate: <code>true</code> - setting <strong>negate</strong> to <code>true</code> means that the <strong>strategy</strong> of the <strong>target</strong> must be different from the <strong>value</strong> defined. In this case, the <code>LENGTH</code> of the value of the <code>foo</code> property must be different from <code>0</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">{
  "condition::if::target": "foo",
  "condition::if::value": "0",
  "condition::if::negate": "true",
  "condition::if::evaluationStrategy": "LENGTH",
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_example_2"><a class="anchor" href="#_example_2"></a>Example 2</h6>
<div class="paragraph">
<p>The following example shows how to implement visibility conditions on several fields based on several checkbox configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the first checkbox is selected, an additional input field is displayed.</p>
</li>
<li>
<p>if the second or the third checkbox is selected, an additional input field is displayed.</p>
</li>
<li>
<p>if both second and third checkboxes are selected, an additional input field is displayed.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
    // the generated layout put one configuration entry per line,
    // customize it as much as needed
    @GridLayout.Row({ "checkbox1" }),
    @GridLayout.Row({ "checkbox2" }),
    @GridLayout.Row({ "checkbox3" }),
    @GridLayout.Row({ "configuration4" }),
    @GridLayout.Row({ "configuration5" }),
    @GridLayout.Row({ "configuration6" })
})
@Documentation("A sample configuration with different visibility condition cases")
public class ActiveifProcessorProcessorConfiguration implements Serializable {
    @Option
    @Documentation("")
    private boolean checkbox1;

    @Option
    @Documentation("")
    private boolean checkbox2;

    @Option
    @Documentation("")
    private boolean checkbox3;

    @Option
    @ActiveIf(target = "checkbox1", value = "true")
    @Documentation("Active if checkbox1 is selected")
    private String configuration4;

    @Option
    @ActiveIfs(operator = ActiveIfs.Operator.OR, value = {
            @ActiveIf(target = "checkbox2", value = "true"),
            @ActiveIf(target = "checkbox3", value = "true")
    })
    @Documentation("Active if checkbox2 or checkbox 3 are selected")
    private String configuration5;

    @Option
    @ActiveIfs(operator = ActiveIfs.Operator.AND, value = {
            @ActiveIf(target = "checkbox2", value = "true"),
            @ActiveIf(target = "checkbox3", value = "true")
    })
    @Documentation("Active if checkbox2 and checkbox 3 are selected")
    private String configuration6;
  }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="documentation-ui-hints"><a class="anchor" href="#documentation-ui-hints"></a>Adding hints about the rendering</h4>
<div class="paragraph">
<p>In some cases, you may need to add metadata about the configuration to let the UI render that configuration properly.<br>
For example, a password value that must be hidden and not a simple clear input box. For these cases - if you want to change the UI rendering - you can use a particular set of annotations:</p>
</div>
<div class="sect4">
<h5 id="_defaultvalue"><a class="anchor" href="#_defaultvalue"></a>@DefaultValue</h5>
<div class="paragraph">
<p>Provide a default value the UI can use - only for primitive fields.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.DefaultValue</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets"><a class="anchor" href="#_snippets"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::defaultvalue::value":"test"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_optionsorder"><a class="anchor" href="#_optionsorder"></a>@OptionsOrder</h5>
<div class="paragraph">
<p>Allows to sort a class properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.OptionsOrder</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_2"><a class="anchor" href="#_snippets_2"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::optionsorder::value":"value1,value2"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_autolayout"><a class="anchor" href="#_autolayout"></a>@AutoLayout</h5>
<div class="paragraph">
<p>Request the rendered to do what it thinks is best.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.layout.AutoLayout</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_3"><a class="anchor" href="#_snippets_3"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::autolayout":"true"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_gridlayout"><a class="anchor" href="#_gridlayout"></a>@GridLayout</h5>
<div class="paragraph">
<p>Advanced layout to place properties by row, this is exclusive with <code>@OptionsOrder</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the logic to handle forms (gridlayout names) is to use the only layout if there is only one defined, else to check if there are <code>Main</code> and <code>Advanced</code> and if at least <code>Main</code> exists, use them, else use all available layouts.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.layout.GridLayout</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_4"><a class="anchor" href="#_snippets_4"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::gridlayout::value1::value":"first|second,third",
  "ui::gridlayout::value2::value":"first|second,third"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_gridlayouts"><a class="anchor" href="#_gridlayouts"></a>@GridLayouts</h5>
<div class="paragraph">
<p>Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.layout.GridLayouts</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_5"><a class="anchor" href="#_snippets_5"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::gridlayout::Advanced::value":"another",
  "ui::gridlayout::Main::value":"first|second,third"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_horizontallayout"><a class="anchor" href="#_horizontallayout"></a>@HorizontalLayout</h5>
<div class="paragraph">
<p>Put on a configuration class it notifies the UI an horizontal layout is preferred.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_6"><a class="anchor" href="#_snippets_6"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::horizontallayout":"true"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_verticallayout"><a class="anchor" href="#_verticallayout"></a>@VerticalLayout</h5>
<div class="paragraph">
<p>Put on a configuration class it notifies the UI a vertical layout is preferred.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_7"><a class="anchor" href="#_snippets_7"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::verticallayout":"true"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_code"><a class="anchor" href="#_code"></a>@Code</h5>
<div class="paragraph">
<p>Mark a field as being represented by some code widget (vs textarea for instance).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.widget.Code</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_8"><a class="anchor" href="#_snippets_8"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::code::value":"test"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_credential"><a class="anchor" href="#_credential"></a>@Credential</h5>
<div class="paragraph">
<p>Mark a field as being a credential. It is typically used to hide the value in the UI.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.widget.Credential</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_9"><a class="anchor" href="#_snippets_9"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::credential":"true"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_datetime"><a class="anchor" href="#_datetime"></a>@DateTime</h5>
<div class="paragraph">
<p>Mark a field as being a date. It supports and is <strong>implicit</strong> - which means you don&#8217;t need to put that annotation on the option - for <code>java.time.ZonedDateTime</code>, <code>java.time.LocalDate</code> and <code>java.time.LocalDateTime</code> and is unspecified for other types.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.widget.DateTime</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_10"><a class="anchor" href="#_snippets_10"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::datetime":"time"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::datetime":"date"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::datetime":"datetime"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::datetime":"zoneddatetime"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_structure"><a class="anchor" href="#_structure"></a>@Structure</h5>
<div class="paragraph">
<p>Mark a List&lt;String&gt; or List&lt;Object&gt; field as being represented as the component data selector.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.widget.Structure</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_11"><a class="anchor" href="#_snippets_11"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::structure::discoverSchema":"test",
  "ui::structure::type":"IN",
  "ui::structure::value":"test"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_textarea"><a class="anchor" href="#_textarea"></a>@TextArea</h5>
<div class="paragraph">
<p>Mark a field as being represented by a textarea(multiline text input).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.ui.widget.TextArea</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_snippets_12"><a class="anchor" href="#_snippets_12"></a>Snippets</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "ui::textarea":"true"
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When using the programmatic API, metadata is prefixed with <code>tcomp::</code>. This prefix is stripped in the web for convenience, and the previous table uses the web keys.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also check <a href="tutorial-configuration-sensitive-data.html" class="page">this example</a> about masking credentials.</p>
</div>
<div class="paragraph">
<p>Target support should cover <code>org.talend.core.model.process.EParameterFieldType</code> but you need to ensure that the web renderer is able to handle the same widgets.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_samples"><a class="anchor" href="#_implementation_samples"></a>Implementation samples</h4>
<div class="paragraph">
<p>You can find sample working components for each of the configuration cases below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=activeif-component-distribution">ActiveIf</a>: Add visibility conditions on some configurations.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=checkbox-component-distribution">Checkbox</a>: Add checkboxes or toggles to your component.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=code-component-distribution">Code</a>: Allow users to enter their own code.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=credentials-component-distribution">Credential</a>: Mark a configuration as sensitive data to avoid displaying it as plain text.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=datastorevalidation-component-distribution">Datastore</a>: Add a button allowing to check the connection to a datastore.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=dropdownlist-component-distribution">Datalist</a>: Two ways of implementing a dropdown list with predefined choices.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=integer-component-distribution">Integer</a>: Add numeric fields to your component configuration.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=minmaxvalidation-component-distribution">Min/Max</a>: Specify a minimum or a maximum value for a numeric configuration.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=multiselect-component-distribution">Multiselect</a>: Add a list and allow users to select multiple elements of that list.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=patternvalidation-component-distribution">Pattern</a>: Enforce rules based on a specific a pattern to prevent users from entering invalid values.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=requiredvalidation-component-distribution">Required</a>: Make a configuration mandatory.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=suggestions-component-distribution">Suggestions</a>: Suggest possible values in a field based on what the users are entering.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=table-component-distribution">Table</a>: Add a table to your component configuration.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=textarea-component-distribution">Textarea</a>: Add a text area for configurations expecting long texts or values.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=textinput-component-distribution">Input</a>: Add a simple text input field to the component configuration</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=updatable-component-distribution">Update</a>: Provide a button allowing to fill a part of the component configuration based on a service.</p>
</li>
<li>
<p><a href="https://oss.sonatype.org/service/local/artifact/maven/content?r=snapshots&amp;g=org.talend.sdk.component&amp;a=documentation-sample&amp;v=1.1.28-SNAPSHOT&amp;e=zip&amp;c=urlvalidation-component-distribution">Validation</a>: Specify constraints to make sure that a URL is well formed.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_10"><a class="anchor" href="#_related_articles_10"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="component-loading.html" class="page">Loading a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_component_execution_logic"><a class="anchor" href="#_component_execution_logic"></a>Component execution logic</h3>
<div class="paragraph">
<p>Each type of component has its own execution logic. The same basic logic is applied to all components of the same type, and is then extended to implement each component specificities.
The project generated from the starter already contains the basic logic for each component.</p>
</div>
<div class="paragraph">
<p>Talend Component Kit framework relies on several primitive components.</p>
</div>
<div class="paragraph">
<p>All components can use <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations to initialize or release some underlying resource at the beginning and the end of a processing.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In distributed environments, class constructor are called on cluster manager nodes. Methods annotated with <code>@PostConstruct</code> and <code>@PreDestroy</code> are called on worker nodes. Thus, partition plan computation and pipeline tasks are performed on different nodes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/deployment-diagram.png" target="_blank" rel="noopener"><img src="_images/deployment-diagram.png" alt="Deployment diagram"></a></span></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The created task is a JAR file containing class information, which describes the pipeline (flow) that should be processed in cluster.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>During the partition plan computation step, the pipeline is analyzed and split into stages. The cluster manager node instantiates mappers/processors, gets estimated data size using mappers, and splits created mappers according to the estimated data size.<br>
All instances are then serialized and sent to the worker node.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Serialized instances are received and deserialized. Methods annotated with <code>@PostConstruct</code> are called. After that, pipeline execution starts. The <code>@BeforeGroup</code> annotated method of the processor is called before processing the first element in chunk.<br>
After processing the number of records estimated as chunk size, the <code>@AfterGroup</code> annotated method of the processor is called. Chunk size is calculated depending on the environment the pipeline is processed by. Once the pipeline is processed, methods annotated with <code>@PreDestroy</code> are called.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All the methods managed by the framework must be public. Private methods are ignored.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/driver-processing-workflow.png" target="_blank" rel="noopener"><img src="_images/driver-processing-workflow.png" alt="Driver processing workflow"></a></span></p>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/worker-processing-workflow.png" target="_blank" rel="noopener"><img src="_images/worker-processing-workflow.png" alt="Worker processing workflow"></a></span></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The framework is designed to be as declarative as possible but also to stay extensible by not using fixed interfaces or method signatures. This allows to incrementally add new features of the underlying implementations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_internationalizing_components"><a class="anchor" href="#_internationalizing_components"></a>Internationalizing components</h3>
<div class="paragraph">
<p>In common cases, you can store messages using a properties file in your component module to use internationalization.</p>
</div>
<div class="paragraph">
<p>This properties file must be stored in the same package as the related components and named <code>Messages</code>. For example, <code>org.talend.demo.MyComponent</code> uses <code>org.talend.demo.Messages[locale].properties</code>.</p>
</div>
<div class="paragraph">
<p>This file already exists when you import a project generated from the starter.</p>
</div>
<div class="sect3">
<h4 id="_default_components_keys"><a class="anchor" href="#_default_components_keys"></a>Default components keys</h4>
<div class="paragraph">
<p>Out of the box components are internationalized using the same location logic for the resource bundle. The supported keys are:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name Pattern</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${family}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of the family</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${family}.${category}._category</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of the category <code>${category}</code> in the family <code>${family}</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${family}.${configurationType}.${name}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of a configuration type (dataStore or dataSet). Important: this key is read from the family package (not the class package), to unify the localization of the metadata.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${family}.actions.${actionType}.${actionName}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of an action of the family. Specifying it is optional and will default on the action name if not set.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${family}.${component_name}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of the component (used by the GUIs)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${property_path}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of the option.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${property_path}._documentation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>@Documentation("&#8230;&#8203;")</code> but supporting internationalization (see Maven/Gradle documentation goal/task).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${property_path}._placeholder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Placeholder of the option.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${simple_class_name}.${property_name}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of the option using its class name.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${simple_class_name}.${property_name}._documentation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>${property_path}._documentation</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${simple_class_name}.${property_name}._placeholder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code>${property_path}._placeholder</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${enum_simple_class_name}.${enum_name}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of the <code>enum_name</code> value of the <code>enum_simple_class_name</code> enumeration.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${property_path or simple_class_name}._gridlayout.${layout_name}._displayName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Display name of tab corresponding to the layout (tab). Note that this requires the server <code>talend.component.server.gridlayout.translation.support</code> option to be set to <code>true</code> and it is not yet supported by the Studio.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Example of configuration for a component named <code>list</code> and belonging to the <code>memory</code> family (<code>@Emitter(family = "memory", name = "list")</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>memory.list._displayName = Memory List</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_internationalizing_a_configuration_class"><a class="anchor" href="#_internationalizing_a_configuration_class"></a>Internationalizing a configuration class</h4>
<div class="paragraph">
<p>Configuration classes can be translated using the simple class name in the messages properties file.
This is useful in case of common configurations shared by multiple components.</p>
</div>
<div class="paragraph">
<p>For example, if you have a configuration class as follows :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyConfig {

    @Option
    private String host;

    @Option
    private int port;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can give it a translatable display name by adding <code>${simple_class_name}.${property_name}._displayName</code> to <code>Messages.properties</code> under the same package as the configuration class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>MyConfig.host._displayName = Server Host Name
MyConfig.host._placeholder = Enter Server Host Name...

MyConfig.port._displayName = Server Port
MyConfig.port._placeholder = Enter Server Port...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you have a display name using the property path, it overrides the display name defined using the simple class name. This rule also applies to placeholders.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_11"><a class="anchor" href="#_related_articles_11"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Defining component layout and configuration</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_managing_component_versions_and_migration"><a class="anchor" href="#_managing_component_versions_and_migration"></a>Managing component versions and migration</h3>
<div class="paragraph">
<p>If some changes impact the configuration, they can be managed through a migration handler at the <strong>component</strong> level (enabling trans-model migration support).</p>
</div>
<div class="paragraph">
<p>The <code>@Version</code> annotation supports a <code>migrationHandler</code> method which migrates the incoming configuration to the current model.</p>
</div>
<div class="paragraph">
<p>For example, if the <code>filepath</code> configuration entry from v1 changed to <code>location</code> in v2, you can remap the value in your <code>MigrationHandler</code> implementation.</p>
</div>
<div class="paragraph">
<p>A best practice is to split migrations into services that you can inject in the migration handler (through constructor) rather than managing all migrations directly in the handler. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// full component code structure skipped for brievity, kept only migration part
@Version(value = 3, migrationHandler = MyComponent.Migrations.class)
public class MyComponent {
    // the component code...


    private interface VersionConfigurationHandler {
        Map&lt;String, String&gt; migrate(Map&lt;String, String&gt; incomingData);
    }

    public static class Migrations {
        private final List&lt;VersionConfigurationHandler&gt; handlers;

        // VersionConfigurationHandler implementations are decorated with @Service
        public Migrations(final List&lt;VersionConfigurationHandler&gt; migrations) {
            this.handlers = migrations;
            this.handlers.sort(/*some custom logic*/);
        }

        @Override
        public Map&lt;String, String&gt; migrate(int incomingVersion, Map&lt;String, String&gt; incomingData) {
            Map&lt;String, String&gt; out = incomingData;
            for (MigrationHandler handler : handlers) {
                out = handler.migrate(out);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is important to notice in this snippet is the fact that you can organize your migrations the way that best fits your component.</p>
</div>
<div class="paragraph">
<p>If you need to apply migrations in a specific order, make sure that they are sorted.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Consider this API as a migration callback rather than a migration API.<br>
Adjust the migration code structure you need behind the <code>MigrationHandler</code>, based on your component requirements, using service injection.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_difference_between_migrating_a_component_configuration_and_a_nested_configuration"><a class="anchor" href="#_difference_between_migrating_a_component_configuration_and_a_nested_configuration"></a>Difference between migrating a component configuration and a nested configuration</h4>
<div class="paragraph">
<p>A nested configuration always migrates itself with any root prefix, whereas a component configuration always roots the full configuration.<br>
For example, if your model is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version
// ...
public class MyComponent implements Serializable {
  public MyComponent(@Option("configuration") final MyConfig config) {
    // ...
  }

  // ...
}

@DataStore
public class MyConfig implements Serializable {
  @Option
  private MyDataStore datastore;
}

@Version
@DataStore
public class MyDataStore implements Serializable {
  @Option
  private String url;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the component will see the path <code>configuration.datastore.url</code> for the datastore url whereas the datastore
will see the path <code>url</code> for the same property. You can see it as configuration types - <code>@DataStore</code>, <code>@DataSet</code> - being
configured with an empty root path.</p>
</div>
</div>
</div>
<div class="sect2 relatedlinks">
<h3 id="_masking_sensitive_data_in_your_configuration"><a class="anchor" href="#_masking_sensitive_data_in_your_configuration"></a>Masking sensitive data in your configuration</h3>
<div id="tutorial-configuration-sensitive-data" class="paragraph">
<p>This tutorial shows how to correctly mask the sensitive data of a component configuration.</p>
</div>
<div class="paragraph">
<p>It is very common to define credentials when configuring a component. Most common cases can include <strong>passwords</strong>, <strong>secrets</strong>, <strong>keys</strong> (it is also common to show them in plain text in a textarea), and <strong>tokens</strong>.</p>
</div>
<div class="paragraph">
<p>For example, this REST client configuration specifies that a username, a password and a token are needed to connect to the REST API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data // or getters/setters if you don't use lombok
@GridLayout({
        @GridLayout.Row({ "username", "password" }),
        @GridLayout.Row("token")
})
public class RestApiConfiguration implements Serializable {

    @Option
    private String username;

    @Option
    private String password;

    @Option
    private String token;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration defines that these credentials are three simple <code>String</code>, represented as plain inputs, which causes severe security concerns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The password and token are clearly readable in all Talend user interfaces (Studio or Web),</p>
</li>
<li>
<p>The password and token are potentially stored in clear.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To avoid this behavior, you need to mark sensitive data as <code>@Credential</code>.</p>
</div>
<div class="sect3">
<h4 id="_marking_sensitive_data"><a class="anchor" href="#_marking_sensitive_data"></a>Marking sensitive data</h4>
<div class="paragraph">
<p>Talend Component Kit provides you with the <code>@Credential</code> marker, that you can use
on any <code>@Option</code>. This marker has two effects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It Replaces the default input widget by a password oriented widget</p>
</li>
<li>
<p>It Requests the Studio or the Talend Cloud products to store the data as sensitive data (as encrypted values).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to ensure that the <code>password</code> and <code>token</code> are never stored in clear or shown in the code,
add the <code>@Credential</code> marker to the sensitive data. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data // or getters/setters if you don't use lombok
@GridLayout({
        @GridLayout.Row({ "username", "password" }),
        @GridLayout.Row("token")
})
public class RestApiConfiguration implements Serializable {

    @Option
    private String username;

    @Option
    @Credential
    private String password;

    @Option
    @Credential
    private String token;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your password and token (or any other sensitive data that you need to mask) are not accessible by error anymore.</p>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_12"><a class="anchor" href="#_related_articles_12"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Configuring a component</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="component-loading.html" class="page">Loading a component</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_batch_processing_2"><a class="anchor" href="#_implementing_batch_processing_2"></a>Implementing batch processing</h3>
<div class="paragraph">
<p>Depending on several requirements, including the system capacity and business needs, a processor can process records differently.</p>
</div>
<div class="paragraph">
<p>For example, for real-time or near-real time processing, it is more interesting to process small batches of data more often. On the other hand, in case of one-time processing, it is more optimal to adapt the way the component handles batches of data according to the system capacity.</p>
</div>
<div class="paragraph">
<p>By default, the runtime automatically estimates a group size that it considers good, according to the system capacity, to process the data. This group size can sometimes be too big and not optimal for your needs or for your system to handle effectively and correctly.</p>
</div>
<div class="paragraph">
<p>Users can then customize this size from the component settings in Talend Studio, by specifying a <code>maxBatchSize</code> that adapts the size of each group of data to be processed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The estimated group size logic is automatically implemented when a component is deployed to a Talend application. Besides defining the @BeforeGroup and @AfterGroup logic detailed below, no action is required on the implementation side of the component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The component batch processes the data as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Case 1 - No <code>maxBatchSize</code> is specified in the component configuration. The runtime estimates a group size of 4. Records are processed by groups of 4.</p>
</li>
<li>
<p>Case 2 - The runtime estimates a group size of 4 but a <code>maxBatchSize</code> of 3 is specified in the component configuration. The system adapts the group size to 3. Records are processed by groups of 3.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title"><strong>Processing schema (values are examples):</strong></div>
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/batch-processing-maxbatchsize.png" target="_blank" rel="noopener"><img src="_images/batch-processing-maxbatchsize.png" alt="Batch processing"></a></span></p>
</div>
<div class="paragraph">
<p>Each group is processed as follows until there is no record left:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>@BeforeGroup</code> method resets a record buffer at the beginning of each group.</p>
</li>
<li>
<p>The records of the group are assessed one by one and placed in the buffer as follows: The <code>@ElementListener</code> method tests if the buffer size is greater or equal to the defined <code>maxBatchSize</code>. If it is, the records are processed. If not, then the current record is buffered.</p>
</li>
<li>
<p>The previous step happens for all records of the group. Then the <code>@AfterGroup</code> method tests if the buffer is empty.</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title"><strong>Group execution detail (values are examples):</strong></div>
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/batch-processing-group.png" target="_blank" rel="noopener"><img src="_images/batch-processing-group.png" alt="Group batch processing"></a></span></p>
</div>
<div class="paragraph">
<p>You can define the following logic in the processor configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;

import javax.json.JsonObject;

import org.talend.sdk.component.api.processor.AfterGroup;
import org.talend.sdk.component.api.processor.BeforeGroup;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.processor.Processor;

@Processor(name = "BulkOutputDemo")
public class BulkProcessor implements Serializable {
    private Collection&lt;JsonObject&gt; buffer;

    @BeforeGroup
    public void begin() {
        buffer = new ArrayList&lt;&gt;();
    }

    @ElementListener
    public void bufferize(final JsonObject object) {
        buffer.add(object);
    }

    @AfterGroup
    public void commit() {
        // save buffered records at once (bulk)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the condensed syntax for this kind of processor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Processor(name = "BulkOutputDemo")
public class BulkProcessor implements Serializable {

    @AfterGroup
    public void commit(final Collection&lt;Record&gt; records) {
        // save records
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When writing tests for your components, you can force the <code>maxBatchSize</code> parameter value by setting it with the following syntax: <code>&lt;configuration prefix&gt;.$maxBatchSize=10</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can learn more about processors in <a href="component-define-processor-output.html" class="page">this document</a>.</p>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_13"><a class="anchor" href="#_related_articles_13"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor/output logic</a></p>
</li>
<li>
<p><a href="component-execution.html" class="page">General component execution logic</a></p>
</li>
<li>
<p><a href="concept-processor-and-batch-processing.html" class="page">Implementing bulk processing</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_streaming_on_a_component"><a class="anchor" href="#_implementing_streaming_on_a_component"></a>Implementing streaming on a component</h3>
<div class="paragraph">
<p>By default, input components are designed to receive a one-time batch of data to process. By enabling the streaming mode, you can instead set your component to process a continuous incoming flow of data.</p>
</div>
<div class="paragraph">
<p>When streaming is enabled on an input component, the component tries to pull data from its producer. When no data is pulled, it waits for a defined period of time before trying to pull data again, and so on. This period of time between tries is defined by a strategy.</p>
</div>
<div class="paragraph">
<p>This document explains how to configure this strategy and the cases where it can fit your needs.</p>
</div>
<div class="sect3">
<h4 id="_choosing_between_batch_and_streaming"><a class="anchor" href="#_choosing_between_batch_and_streaming"></a>Choosing between batch and streaming</h4>
<div class="paragraph">
<p>Before enabling streaming on your component, make sure that it fits the scope and requirements of your project and that regular batch processing cannot be used instead.</p>
</div>
<div class="paragraph">
<p>Streaming is designed to help you dealing with real-time or near real-time data processing cases, and should be used only for such cases.
Enabling streaming will impact the performance when processing batches of data.</p>
</div>
</div>
<div class="sect3">
<h4 id="_enabling_streaming_from_the_component_kit_starter"><a class="anchor" href="#_enabling_streaming_from_the_component_kit_starter"></a>Enabling streaming from the Component Kit starter</h4>
<div class="paragraph">
<p>You can enable streaming right from the design phase of the project by enabling the <strong>Stream</strong> toggle in the basic configuration of your future component in the Component Kit Starter.</p>
</div>
<div class="paragraph">
<p>Doing so adds a default streaming-ready configuration to your component when generating the project.<br>
This default configuration implements a constant pause duration of 500 ms between retries, with no limit of retries.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_enabling_streaming.png" target="_blank" rel="noopener"><img src="_images/starter/starter_enabling_streaming.png" alt="Stream Toggle"></a>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_streaming_from_the_project"><a class="anchor" href="#_configuring_streaming_from_the_project"></a>Configuring streaming from the project</h4>
<div class="paragraph">
<p>If streaming was not enabled at all during the project generation or if you need to implement a more specific configuration, you can change the default settings according to your needs:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the <code>infinite=true</code> parameter to your component class.</p>
</li>
<li>
<p>Define the number of retries allowed in the component family <a href="services-built-in.html#_localconfiguration" class="page">LocalConfiguration</a>, using the <code>talend.input.streaming.retry.maxRetries</code> parameter. It is set by default to <code>Integer.MAX_VALUE</code>.</p>
</li>
<li>
<p>Define the pausing strategy between retries in the component family <code>LocalConfiguration</code>, using the <code>talend.input.streaming.retry.strategy</code> parameter. Possible values are:</p>
<div class="ulist">
<ul>
<li>
<p><code>constant</code> (default). It sets a constant pause duration between retries.</p>
</li>
<li>
<p><code>exponential</code>. It sets an exponential backoff pause duration.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the tables below for more details about each strategy.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_constant_strategy"><a class="anchor" href="#_constant_strategy"></a>Constant strategy</h5>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.input.streaming.retry.constant.timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pause duration for the <code>constant</code> strategy, in ms.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>500</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_exponential_strategy"><a class="anchor" href="#_exponential_strategy"></a>Exponential strategy</h5>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.input.streaming.retry.exponential.exponent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exponent of the exponential calculation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.input.streaming.retry.exponential.randomizationFactor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Randomization factor used in the calculation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.5</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.input.streaming.retry.exponential.maxDuration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum pausing duration between two retries.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5*60*1000</code> (5 minutes)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.input.streaming.retry.exponential.initialBackOff</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial backoff value.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code> (1 second)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The values of these parameters are then used in the following calculations to determine the exact pausing duration between two retries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more clarity in the formulas below, parameter names have been replaced with variables.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First, the current interval duration is calculated:</p>
</div>
<div class="paragraph">
<p>\$A = min(B xx E^I, F)\$</p>
</div>
<div class="paragraph">
<p>Where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A: currentIntervalMillis</p>
</li>
<li>
<p>B: initialBackOff</p>
</li>
<li>
<p>E: exponent</p>
</li>
<li>
<p>I: current number of retries</p>
</li>
<li>
<p>F: maxDuration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then, from the current interval duration, the next interval duration is calculated:</p>
</div>
<div class="paragraph">
<p>\$D = min(F, A + ((R xx 2-1) xx C xx A))\$</p>
</div>
<div class="paragraph">
<p>Where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>D: nextBackoffMillis</p>
</li>
<li>
<p>F: maxDuration</p>
</li>
<li>
<p>A: currentIntervalMillis</p>
</li>
<li>
<p>R: random</p>
</li>
<li>
<p>C: randomizationFactor</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_building_components_with_maven"><a class="anchor" href="#_building_components_with_maven"></a>Building components with Maven</h3>
<div class="paragraph">
<p>To develop new components, Talend Component Kit requires a build tool in which you will import the component project generated from the starter.</p>
</div>
<div class="paragraph">
<p>You will then be able to install and deploy it to Talend applications.
A Talend Component Kit plugin is available for each of the supported build tools.</p>
</div>
<div class="paragraph">
<p><strong>talend-component-maven-plugin</strong> helps you write components that match best practices and generate transparently metadata used by Talend Studio.</p>
</div>
<div class="paragraph">
<p>You can use it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This plugin is also an extension so you can declare it in your <code>build/extensions</code> block as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;extension&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Used as an extension, the goals detailed in this document will be set up.</p>
</div>
<div class="sect3">
<h4 id="_maven_lifecycle"><a class="anchor" href="#_maven_lifecycle"></a>Maven lifecycle</h4>
<div class="paragraph">
<p>The Talend Component Kit plugin integrates some specific goals within Maven build lifecycle.
For example, to compile the project and prepare for deploying your component, run <code>mvn clean install</code>. Using this command, the following goals are executed:</p>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/mvn_clean_install.png" target="_blank" rel="noopener"><img src="_images/mvn_clean_install.png" alt="Maven clean install"></a></span></p>
</div>
<div class="paragraph">
<p>The build is split into several phases. The different goals are executed in the order shown above. Talend Component Kit uses default goals from the Maven build lifecycle and adds additional goals to the building and packaging phases.</p>
</div>
<div class="paragraph">
<p>Goals added to the build by Talend Component Kit are detailed below.
The default lifecycle is detailed in <a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">Maven documentation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_talend_component_kit_maven_goals"><a class="anchor" href="#_talend_component_kit_maven_goals"></a>Talend Component Kit Maven goals</h4>
<div class="paragraph">
<p>The Talend Component Kit plugin for Maven integrates several specific goals into Maven build lifecycle.</p>
</div>
<div class="paragraph">
<p>To run specific goals individually, run the following command from the root of the project, by adapting it with each goal name, parameters and values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mvn talend-component:&lt;name_of_the_goal&gt;[:&lt;execution id&gt;] -D&lt;param_user_property&gt;=&lt;param_value&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_dependencies"><a class="anchor" href="#_dependencies"></a>Dependencies</h5>
<div class="paragraph">
<p>The first goal is a shortcut for the <strong>maven-dependency-plugin</strong>. It creates the <code>TALEND-INF/dependencies.txt</code> file with the <code>compile</code> and <code>runtime</code> dependencies, allowing the component to use it at runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-dependencies&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;dependencies&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_scan"><a class="anchor" href="#_scan"></a>Scan</h5>
<div class="paragraph">
<p>The <code>scan-descriptor</code> goal scans the current module and optionally other configured folders to precompute the list of interesting classes for the framework (components, services). It allows to save some bootstrap time when launching a job, which can be useful in some execution cases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-scan-descriptor&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;scan-descriptor&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Configuration - excluding parameters used by default only:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Where to dump the scan result. Note: It is not supported to change that value in the runtime.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.scan.output</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${project.build.outputDirectory}/TALEND-INF/scanning.properties</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">scannedDirectories</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Explicit list of directories to scan.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.scan.scannedDirectories</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If not set, defaults to <code>${project.build.outputDirectory}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">scannedDependencies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Explicit list of dependencies to scan - set them in the <code>groupId:artifactId</code> format. The list is appended to the file to scan.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.scan.scannedDependencies</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_svg2png"><a class="anchor" href="#_svg2png"></a>SVG2PNG</h5>
<div class="paragraph">
<p>The <code>svg2png</code> goal scans a directory - default to <code>target/classes/icons</code> - to find <code>.svg</code> files and copy them in a PNG version size at 32x32px and named with the suffix <code>_icon32.png</code> to enable the studio to read it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-svg2png&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;svg2png&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Configuration:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">icons</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Where to scan for the SVG icons to convert in PNG.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">talend.icons.source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${project.build.outputDirectory}/icons</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">workarounds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default the shape of the icon will be enforce in the RGB channels (in white) using the alpha as reference. This is useful for black/white images using alpha to shape the picture because Eclipse - Talend Studio - caches icons using RGB but not alpha channel, pictures not using alpha channel to draw their shape should disable that workaround.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">talend.icons.workaround</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
if you use that plugin, ensure to set it before the validate mojo otherwise validation can miss some png files.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_validating_the_component_programming_model"><a class="anchor" href="#_validating_the_component_programming_model"></a>Validating the component programming model</h5>
<div class="paragraph">
<p>This goal helps you validate the common programming model of the component. To activate it, you can use following execution definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-component-validate&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;validate&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is bound to the <code>process-classes</code> phase by default. When executed, it performs several validations that can be disabled by setting the corresponding flags to <code>false</code> in the <code>&lt;configuration&gt;</code> block of the execution:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateInternationalization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validates that resource bundles are presents and contain commonly used keys (for example, <code>_displayName</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.internationalization</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateModel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that components pass validations of the <code>ComponentManager</code> and Talend Component runtime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateSerializable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that components are <code>Serializable</code>. This is a sanity check, the component is not actually serialized here. If you have a doubt, make sure to test it. It also checks that any <code>@Internationalized</code> class is valid and has its keys.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.serializable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateMetadata</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that components have an <code>@Icon</code> and a <code>@Version</code> defined.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.metadata</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateDataStore</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that any <code>@DataStore</code> defines a <code>@HealthCheck</code> and has a unique name.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.datastore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateDataSet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that any <code>@DataSet</code> has a unique name. Also ensures that there is a source instantiable just filling the dataset properties (all others not being required). Finally, the validation checks that each input or output component uses a dataset and that this dataset has a datastore.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.dataset</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateComponent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that the native programming model is respected. You can disable it when using another programming model like Beam.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.component</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateActions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validates action signatures for actions not tolerating dynamic binding (<code>@HealthCheck</code>, <code>@DynamicValues</code>, and so on). It is recommended to keep it set to <code>true</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.action</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateFamily</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Validates the family by verifying that the package containing the <code>@Components</code> has a <code>@Icon</code> property defined.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.family</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateDocumentation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that all components and <code>@Option</code> properties have a documentation using the <code>@Documentation</code> property.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.documentation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateLayout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that the layout is referencing existing options and properties.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.layout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateOptionNames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that the option names are compliant with the framework. It is highly recommended and safer to keep it set to <code>true</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.options</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateLocalConfiguration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that if any <code>TALEND-INF/local-configuration.properties</code> exists then keys start with the family name.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.localConfiguration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validateOutputConnection</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that an output has only one input branch.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.validateOutputConnection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">validatePlaceholder</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ensures that string options have a placeholder. It is highly recommended to turn this property on.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.placeholder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">locale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The locale used to validate internationalization.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.validation.locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">root</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_generating_the_component_documentation"><a class="anchor" href="#_generating_the_component_documentation"></a>Generating the component documentation</h5>
<div class="paragraph">
<p>The <code>asciidoc</code> goal generates an Asciidoc file documenting your component from the configuration model (<code>@Option</code>) and the <code>@Documentation</code> property that you can add to options and to the component itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${component.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;talend-component-documentation&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">level</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Level of the root title.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.level</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2 (<code>==</code>)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Output folder path. It is recommended to keep it to the default value.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.output</code></p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>${classes}/TALEND-INF/documentation.adoc</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">formats</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map of the renderings to do. Keys are the format (<code>pdf</code> or <code>html</code>) and values the output paths.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.formats</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">attributes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Asciidoctor attributes to use for the rendering when <strong>formats</strong> is set.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.attributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">templateEngine</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Template engine configuration for the rendering.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.templateEngine</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">templateDir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Template directory for the rendering.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.templateDir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">title</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Document title.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">${project.name}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The component version. It defaults to the pom version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">${project.version}</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">workDir</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The template directory for the Asciidoctor rendering - if 'formats' is set.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.workdDir</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">${project.build.directory}/talend-component/workdir</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">attachDocumentations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allows to attach (and deploy) the documentations (<code>.adoc</code>, and <code>formats</code> keys) to the project.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.attach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">htmlAndPdf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If you use the plugin as an extension, you can add this property and set it to <code>true</code> in your project to automatically get HTML and PDF renderings of the documentation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.documentation.htmlAndPdf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="_rendering_your_documentation"><a class="anchor" href="#_rendering_your_documentation"></a>Rendering your documentation</h6>
<div class="paragraph">
<p>To render the generated documentation in HTML or PDF, you can use the Asciidoctor Maven plugin (or Gradle equivalent). You can configure both executions if you want both HTML and PDF renderings.</p>
</div>
<div class="paragraph">
<p>Make sure to execute the rendering after the documentation generation.</p>
</div>
</div>
<div class="sect5">
<h6 id="_html_rendering"><a class="anchor" href="#_html_rendering"></a>HTML rendering</h6>
<div class="paragraph">
<p>If you prefer a HTML rendering, you can configure the following execution in the asciidoctor plugin. The example below:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Generates the components documentation in <code>target/classes/TALEND-INF/documentation.adoc</code>.</p>
</li>
<li>
<p>Renders the documentation as an HTML file stored in <code>target/documentation/documentation.html</code>.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt; <i class="conum" data-value="1"></i><b>(1)</b>
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${talend-component-kit.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;documentation&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
&lt;plugin&gt; <i class="conum" data-value="2"></i><b>(2)</b>
  &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
  &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.5.7&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;doc-html&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;process-asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sourceDirectory&gt;${project.build.outputDirectory}/TALEND-INF&lt;/sourceDirectory&gt;
        &lt;sourceDocumentName&gt;documentation.adoc&lt;/sourceDocumentName&gt;
        &lt;outputDirectory&gt;${project.build.directory}/documentation&lt;/outputDirectory&gt;
        &lt;backend&gt;html5&lt;/backend&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_pdf_rendering"><a class="anchor" href="#_pdf_rendering"></a>PDF rendering</h6>
<div class="paragraph">
<p>If you prefer a PDF rendering, you can configure the following execution in the asciidoctor plugin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
  &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.5.7&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;doc-html&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;process-asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sourceDirectory&gt;${project.build.outputDirectory}/TALEND-INF&lt;/sourceDirectory&gt;
        &lt;sourceDocumentName&gt;documentation.adoc&lt;/sourceDocumentName&gt;
        &lt;outputDirectory&gt;${project.build.directory}/documentation&lt;/outputDirectory&gt;
        &lt;backend&gt;pdf&lt;/backend&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
      &lt;artifactId&gt;asciidoctorj-pdf&lt;/artifactId&gt;
      &lt;version&gt;1.5.0-alpha.16&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_including_the_documentation_into_a_document"><a class="anchor" href="#_including_the_documentation_into_a_document"></a>Including the documentation into a document</h6>
<div class="paragraph">
<p>If you want to add some more content or a title, you can include the generated document into
another document using Asciidoc <code>include</code> directive.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-adoc hljs" data-lang="adoc">= Super Components
Super Writer
:toc:
:toclevels: 3
:source-highlighter: prettify
:numbered:
:icons: font
:hide-uri-scheme:
:imagesdir: images

include::{generated_doc}/documentation.adoc[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To be able to do that, you need to pass the <code>generated_doc</code> attribute to the plugin. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
  &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.5.7&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;doc-html&lt;/id&gt;
      &lt;phase&gt;prepare-package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;process-asciidoc&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;sourceDirectory&gt;${project.basedir}/src/main/asciidoc&lt;/sourceDirectory&gt;
        &lt;sourceDocumentName&gt;my-main-doc.adoc&lt;/sourceDocumentName&gt;
        &lt;outputDirectory&gt;${project.build.directory}/documentation&lt;/outputDirectory&gt;
        &lt;backend&gt;html5&lt;/backend&gt;
        &lt;attributes&gt;
          &lt;generated_adoc&gt;${project.build.outputDirectory}/TALEND-INF&lt;/generated_adoc&gt;
        &lt;/attributes&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is optional but allows to reuse Maven placeholders to pass paths, which can be convenient in an automated build.</p>
</div>
<div class="paragraph">
<p>You can find more customization options on Asciidoctor <a href="http://asciidoctor.org/docs/asciidoctor-maven-plugin/">website</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_testing_a_component_web_rendering"><a class="anchor" href="#_testing_a_component_web_rendering"></a>Testing a component web rendering</h5>
<div class="paragraph">
<p>Testing the rendering of your component configuration into the Studio requires deploying the component in Talend Studio. Refer to the <a href="studio.html">Studio documentation</a>.</p>
</div>
<div class="paragraph">
<p>In the case where you need to deploy your component into a Cloud (web) environment, you can test its web rendering by using the <code>web</code> goal of the plugin:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Run the <code>mvn talend-component:web</code> command.</p>
</li>
<li>
<p>Open the following URL in a web browser: <code><a href="http://localhost:8080" class="bare">localhost:8080</a></code>.</p>
</li>
<li>
<p>Select the component form you want to see from the treeview on the left. The selected form is displayed on the right.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Two parameters are available with the plugin:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>serverPort</code>, which allows to change the default port (8080) of the embedded server. Its associated user property is <code>talend.web.port</code>.</p>
</li>
<li>
<p><code>serverArguments</code>, that you can use to pass Meecrowave options to the server. Learn more about that configuration at <a href="http://openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html" class="bare">openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Make sure to install the artifact before using this command because it reads the component JAR from the local Maven repository.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, you can switch the lang of the component UI (documentation, form) using <code>language</code> query parameter in the webapp.
For instance <code><a href="http://localhost:8080?language=fr" class="bare">localhost:8080?language=fr</a></code>.</p>
</div>
<div class="sect5">
<h6 id="_changing_the_ui_bundle"><a class="anchor" href="#_changing_the_ui_bundle"></a>Changing the UI bundle</h6>
<div class="paragraph">
<p>If you built a custom UI (JS + CSS) bundle and want to test it in the web application, you can configure it in the <code>pom.xml</code> file as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;configuration&gt;
  &lt;uiConfiguration&gt;
    &lt;jsLocation&gt;https://cdn.talend.com/myapp.min.js&lt;/jsLocation&gt;
    &lt;cssLocation&gt;https://cdn.talend.com/myapp.min.css&lt;/cssLocation&gt;
  &lt;/uiConfiguration&gt;
&lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This is an advanced feature designed for expert users. Use it with caution.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_generating_the_component_archive"><a class="anchor" href="#_generating_the_component_archive"></a>Generating the component archive</h5>
<div class="paragraph">
<p>Component ARchive (<strong>.car</strong>) is the way to bundle a component to share it in the Talend ecosystem. It is an executable Java ARchive (<strong>.jar</strong>) containing a metadata file and a nested Maven repository containing the component and its dependencies.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>mvn talend-component:car</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command creates a <strong>.car</strong> file in your build directory. This file can be shared on Talend platforms.</p>
</div>
<div class="paragraph">
<p>This command has some optional parameters:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">attach</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies whether the component archive should be attached.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.car.attach</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The classifier to use if attach is set to true.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.car.classifier</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">component</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">metadata</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Additional custom metadata to bundle in the component archive.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the output path and name of the archive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.car.output</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">${project.build.directory}/${project.build.finalName}.car</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">packaging</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the packaging</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">${project.packaging}</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This CAR is executable and exposes the <code>studio-deploy</code> command which takes
a Talend Studio home path as parameter. When executed, it installs the dependencies into the Studio and registers the component in your instance. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># for a studio
java -jar mycomponent.car studio-deploy /path/to/my/studio
or
java -jar mycomponent.car studio-deploy --location /path/to/my/studio

# for a m2 provisioning
java -jar mycomponent.car maven-deploy /path/to/.m2/repository
or
java -jar mycomponent.car maven-deploy --location /path/to/.m2/repository</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also upload the dependencies to your Nexus server using the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java -jar mycomponent.car deploy-to-nexus --url &lt;nexus url&gt; --repo &lt;repository name&gt; --user &lt;username&gt; --pass &lt;password&gt; --threads &lt;parallel threads number&gt; --dir &lt;temp directory&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this command, Nexus URL and repository name are mandatory arguments. All other arguments are optional. If arguments contain spaces or special symbols, you need to quote the whole value of the argument. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">--pass "Y0u will \ not G4iess i' ^"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_deploying_to_the_studio"><a class="anchor" href="#_deploying_to_the_studio"></a>Deploying to the Studio</h5>
<div class="paragraph">
<p>The <code>deploy-in-studio</code> goal deploys the current component module into a local Talend Studio instance.</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<caption class="title">Table 1. Parameters</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">studioHome</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Path to the Studio home directory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.component.studioHome</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">studioM2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Path to the Studio maven repository if not the default one</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>talend.component.studioM2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can use the following command from the root folder of your project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ mvn talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;studio_path&gt;"</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_help"><a class="anchor" href="#_help"></a>Help</h5>
<div class="paragraph">
<p>The <code>help</code> goal displays help information on <code>talend-component-maven-plugin</code>.
Call <code>mvn talend-component:help -Ddetail=true -Dgoal=&lt;goal-name&gt;</code> to display the parameter details of a specific goal.</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<caption class="title">Table 2. Parameters</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">User property</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">detail</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Displays all settable properties for each goal.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>detail</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">goal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the goal for which to show help. If unspecified, all goals are displayed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>goal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">indentSize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of spaces per indentation level. This integer should be positive.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indentSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lineLength</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum length of a display line. This integer should be positive.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lineLength</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">80</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_14"><a class="anchor" href="#_related_articles_14"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
<li>
<p><a href="build-tools-gradle.html" class="page">Building components with Gradle</a></p>
</li>
<li>
<p><a href="studio.html" class="page">Integrating to the Studio</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_building_components_with_gradle"><a class="anchor" href="#_building_components_with_gradle"></a>Building components with Gradle</h3>
<div class="paragraph">
<p>To develop new components, Talend Component Kit requires a build tool in which you will import the component project generated from the starter. With this build tool, you will also be able to implement the logic of your component and to install and deploy it to Talend applications.
A Talend Component Kit plugin is available for each of the supported build tools.</p>
</div>
<div class="paragraph">
<p><strong>gradle-talend-component</strong> helps you write components that match the best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the <code>dependencies.txt</code> file used by the SDK to build the component classpath. For more information on the configuration, refer to the <a href="build-tools-maven.html" class="page">Maven</a> properties matching the attributes.</p>
</div>
<div class="paragraph">
<p>By default, Gradle does not log information messages. To see messages, use <code>--info</code> in your commands. Refer to <a href="https://docs.gradle.org/current/userguide/logging.html">Gradle&#8217;s documentation</a> to learn about log levels.</p>
</div>
<div class="paragraph">
<p>You can use it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
  }
  dependencies {
    classpath "org.talend.sdk.component:gradle-talend-component:${talendComponentVersion}"
  }
}

apply plugin: 'org.talend.sdk.component'
apply plugin: 'java'

// optional customization
talendComponentKit {
    // dependencies.txt generation, replaces maven-dependency-plugin
    dependenciesLocation = "TALEND-INF/dependencies.txt"
    boolean skipDependenciesFile = false;

    // classpath for validation utilities
    sdkVersion = "${talendComponentVersion}"
    apiVersion = "${talendComponentApiVersion}"

    // documentation
    skipDocumentation = false
    documentationOutput = new File(....)
    documentationLevel = 2 // first level will be == in the generated .adoc
    documentationTitle = 'My Component Family' // defaults to ${project.name}
    documentationAttributes = [:] // adoc attributes
    documentationFormats = [:] // renderings to do
    documentationVersion = 1.1 // defaults to the .pom version

    // validation
    skipValidation = false
    validateFamily = true
    validateSerializable = true
    validateInternationalization = true
    validateModel = true
    validateOptionNames = true
    validateMetadata = true
    validateComponent = true
    validateDataStore = true
    validateDataSet = true
    validateActions = true
    validateLocalConfiguration = true
    validateOutputConnection = true
    validateLayout = true
    validateDocumentation = true

    // web
    serverArguments = []
    serverPort = 8080

    // car
    carAttach = true
    carClassifier = component // classifier to use if carAttach is set to true
    carOutput = new File(....)
    carMetadata = [:] // custom meta (string key-value pairs)
    carPackaging = ${project.packaging}

    // deploy-in-studio
    studioHome = "C:\&lt;pathToSutdio&gt;"

    // svg2png
    icons = 'resources/main/icons'
    useIconWorkarounds = true
}</code></pre>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_15"><a class="anchor" href="#_related_articles_15"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
<li>
<p><a href="build-tools-maven.html" class="page">Building components with Maven</a></p>
</li>
<li>
<p><a href="studio.html" class="page">Integrating to the Studio</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wrapping_a_beam_io"><a class="anchor" href="#_wrapping_a_beam_io"></a>Wrapping a Beam I/O</h3>
<div class="sect3">
<h4 id="wrapping-a-beam-io__start"><a class="anchor" href="#wrapping-a-beam-io__start"></a>Limitations</h4>
<div class="paragraph">
<p>This part is limited to specific kinds of <a href="https://beam.apache.org/">Beam</a> <code>PTransform</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PTransform&lt;PBegin, PCollection&lt;?&gt;&gt;</code> for inputs.</p>
</li>
<li>
<p><code>PTransform&lt;PCollection&lt;?&gt;, PDone&gt;</code> for outputs. Outputs must use a single (composite or not) <code>DoFn</code> in their <code>apply</code> method.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_wrapping_an_input"><a class="anchor" href="#_wrapping_an_input"></a>Wrapping an input</h4>
<div class="paragraph">
<p>To illustrate the input wrapping, this procedure uses the following input as a starting point (based on existing Beam inputs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoValue
public abstract [static] class Read extends PTransform&lt;PBegin, PCollection&lt;String&gt;&gt; {

  // config

  @Override
  public PCollection&lt;String&gt; expand(final PBegin input) {
    return input.apply(
        org.apache.beam.sdk.io.Read.from(new BoundedElasticsearchSource(this, null)));
  }

  // ... other transform methods
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To wrap the <code>Read</code> in a framework component, create a transform delegating to that Read with at least a <code>@PartitionMapper</code> annotation and using <code>@Option</code> constructor injections to configure the component. Also make sure to follow the best practices and to specify <code>@Icon</code> and <code>@Version</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@PartitionMapper(family = "myfamily", name = "myname")
public class WrapRead extends PTransform&lt;PBegin, PCollection&lt;String&gt;&gt; {
  private PTransform&lt;PBegin, PCollection&lt;String&gt;&gt; delegate;

  public WrapRead(@Option("dataset") final WrapReadDataSet dataset) {
    delegate = TheIO.read().withConfiguration(this.createConfigurationFrom(dataset));
  }

  @Override
  public PCollection&lt;String&gt; expand(final PBegin input) {
    return delegate.expand(input);
  }

  // ... other methods like the mapping with the native configuration (createConfigurationFrom)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wrapping_an_output"><a class="anchor" href="#_wrapping_an_output"></a>Wrapping an output</h4>
<div class="paragraph">
<p>To illustrate the output wrapping, this procedure uses the following output as a starting point (based on existing Beam outputs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@AutoValue
public abstract [static] class Write extends PTransform&lt;PCollection&lt;String&gt;, PDone&gt; {


    // configuration withXXX(...)

    @Override
    public PDone expand(final PCollection&lt;String&gt; input) {
      input.apply(ParDo.of(new WriteFn(this)));
      return PDone.in(input.getPipeline());
    }

    // other methods of the transform
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can wrap this output exactly the same way you wrap an input, but using <code>@Processor</code> instead of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Processor(family = "myfamily", name = "myname")
public class WrapWrite extends PTransform&lt;PCollection&lt;String&gt;, PDone&gt; {
  private PTransform&lt;PCollection&lt;String&gt;, PDone&gt; delegate;

  public WrapWrite(@Option("dataset") final WrapWriteDataSet dataset) {
    delegate = TheIO.write().withConfiguration(this.createConfigurationFrom(dataset));
  }

  @Override
  public PDone expand(final PCollection&lt;String&gt; input) {
    return delegate.expand(input);
  }

  // ... other methods like the mapping with the native configuration (createConfigurationFrom)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tip"><a class="anchor" href="#_tip"></a>Tip</h4>
<div class="paragraph">
<p>Note that the <code>org.talend.sdk.component.runtime.beam.transform.DelegatingTransform</code> class fully delegates the "expansion" to another transform. Therefore, you can extend it and implement the configuration mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Processor(family = "beam", name = "file")
public class BeamFileOutput extends DelegatingTransform&lt;PCollection&lt;String&gt;, PDone&gt; {

    public BeamFileOutput(@Option("output") final String output) {
        super(TextIO.write()
            .withSuffix("test")
            .to(FileBasedSink.convertToFileResourceIfPossible(output)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_advanced"><a class="anchor" href="#_advanced"></a>Advanced</h4>
<div class="paragraph">
<p>In terms of classloading, when you write an I/O, the Beam SDK Java core stack is assumed as provided in Talend Component Kit runtime. This way, you don&#8217;t need to include it in the compile scope, it would be ignored anyway.</p>
</div>
<div class="sect4">
<h5 id="_coder"><a class="anchor" href="#_coder"></a>Coder</h5>
<div class="paragraph">
<p>If you need a JSonCoder, you can use the <code>org.talend.sdk.component.runtime.beam.factory.service.PluginCoderFactory</code> service,
which gives you access to the JSON-P and JSON-B coders.</p>
</div>
<div class="paragraph">
<p>There is also an Avro coder, which uses the <code>FileContainer</code>. It ensures it
is self-contained for <code>IndexedRecord</code> and it does not require—as the default Apache Beam <code>AvroCoder</code>—to set the schema when creating a pipeline.<br>
It consumes more space and therefore is slightly slower, but it is fine for <code>DoFn</code>, since it does not rely on serialization in most cases.
See <code>org.talend.sdk.component.runtime.beam.transform.avro.IndexedRecordCoder</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_jsonobject_to_indexedrecord"><a class="anchor" href="#_jsonobject_to_indexedrecord"></a>JsonObject to IndexedRecord</h5>
<div class="paragraph">
<p>If your <code>PCollection</code> is made of <code>JsonObject</code> records, and you want to convert them to <code>IndexedRecord</code>, you can use the following <code>PTransforms</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>IndexedRecordToJson</code></dt>
<dd>
<p>converts an <code>IndexedRecord</code> to a <code>JsonObject</code>.</p>
</dd>
<dt class="hdlist1"><code>JsonToIndexedRecord</code></dt>
<dd>
<p>converts a <code>JsonObject</code> to an <code>IndexedRecord</code>.</p>
</dd>
<dt class="hdlist1"><code>SchemalessJsonToIndexedRecord</code></dt>
<dd>
<p>converts a <code>JsonObject</code> to an <code>IndexedRecord</code> with AVRO schema inference.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_record_coder"><a class="anchor" href="#_record_coder"></a>Record coder</h5>
<div class="paragraph">
<p>There are two main provided coder for <code>Record</code>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>FullSerializationRecordCoder</code></dt>
<dd>
<p>it will unwrap the record as an Avro <code>IndexedRecord</code> and serialize it <strong>with its schema</strong>.
This can indeed have a performance impact but, due to the structure of component, it will not impact the runtime
performance in general - except with direct runner - because the runners will optimize the pipeline accurately.</p>
</dd>
<dt class="hdlist1"><code>SchemaRegistryCoder</code></dt>
<dd>
<p>it will serialize the Avro <code>IndexedRecord</code> as well but it will ensure the schema is in the
<code>SchemaRegistry</code> to be able to deserialize it when needed. This implementation is faster <strong>but</strong> the default implementation
of the registry is "in memory" so will only work with a single worker node. You can extend it using Java SPI mecanism to use a custom
distributed implementation.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_sample"><a class="anchor" href="#_sample"></a>Sample</h5>
<div class="paragraph">
<p>Sample input based on Beam Kafka:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version
@Icon(Icon.IconType.KAFKA)
@Emitter(name = "Input")
@AllArgsConstructor
@Documentation("Kafka Input")
public class KafkaInput extends PTransform&lt;PBegin, PCollection&lt;Record&gt;&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    private final InputConfiguration configuration;

    private final RecordBuilderFactory builder;

    private final PluginCoderFactory coderFactory;

    private KafkaIO.Read&lt;byte[], byte[]&gt; delegate() {
        final KafkaIO.Read&lt;byte[], byte[]&gt; read = KafkaIO.&lt;byte[], byte[]&gt; read()
                .withBootstrapServers(configuration.getBootstrapServers())
                .withTopics(configuration.getTopics().stream().map(InputConfiguration.Topic::getName).collect(toList()))
                .withKeyDeserializer(ByteArrayDeserializer.class).withValueDeserializer(ByteArrayDeserializer.class);
        if (configuration.getMaxResults() &gt; 0) {
            return read.withMaxNumRecords(configuration.getMaxResults());
        }
        return read;
    }

    @Override <i class="conum" data-value="2"></i><b>(2)</b>
    public PCollection&lt;Record&gt; expand(final PBegin pBegin) {
        final PCollection&lt;KafkaRecord&lt;byte[], byte[]&gt;&gt; kafkaEntries = pBegin.getPipeline().apply(delegate());
        return kafkaEntries.apply(ParDo.of(new BytesToRecord(builder))).setCoder(SchemaRegistryCoder.of()); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @AllArgsConstructor
    private static class BytesToRecord extends DoFn&lt;KafkaRecord&lt;byte[], byte[]&gt;, Record&gt; {

        private final RecordBuilderFactory builder;

        @ProcessElement
        public void onElement(final ProcessContext context) {
            context.output(toRecord(context.element()));
        }

        private Record toRecord(final KafkaRecord&lt;byte[], byte[]&gt; element) {
            return builder.newRecordBuilder().add("key", element.getKV().getKey())
                    .add("value", element.getKV().getValue()).build();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>PTransform</code> generics define that the component is an input (<code>PBegin</code> marker).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>expand</code> method chains the native I/O with a custom mapper (<code>BytesToRecord</code>).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The mapper uses the SchemaRegistry coder automatically created from the contextual component.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because the Beam wrapper does not respect the standard Talend Component Kit programming model ( for example, there is no <code>@Emitter</code>), you need to set the <code>&lt;talend.validation.component&gt;false&lt;/talend.validation.component&gt;</code> property in your <code>pom.xml</code> file (or equivalent for Gradle) to skip the component programming model validations of the framework.</p>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_16"><a class="anchor" href="#_related_articles_16"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Creating a job pipeline</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_talend_component_kit_best_practices"><a class="anchor" href="#_talend_component_kit_best_practices"></a>Talend Component Kit best practices</h3>
<div class="sect3">
<h4 id="_organizing_your_code"><a class="anchor" href="#_organizing_your_code"></a>Organizing your code</h4>
<div class="paragraph">
<p>Some recommendations apply to the way component packages are organized:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure to create a <code>package-info.java</code> file with the component family/categories at the root of your component package:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Components(family = "jdbc", categories = "Database")
package org.talend.sdk.component.jdbc;

import org.talend.sdk.component.api.component.Components;</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Create a package for the configuration.</p>
</li>
<li>
<p>Create a package for the actions.</p>
</li>
<li>
<p>Create a package for the component and one sub-package by type of component (input, output, processors, and so on).</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_components"><a class="anchor" href="#_configuring_components"></a>Configuring components</h4>
<div class="sect4">
<h5 id="_serializing_your_configuration"><a class="anchor" href="#_serializing_your_configuration"></a>Serializing your configuration</h5>
<div class="paragraph">
<p>It is recommended to serialize your configuration in order to be able to pass it through other components.</p>
</div>
</div>
<div class="sect4">
<h5 id="_input_and_output_components"><a class="anchor" href="#_input_and_output_components"></a>Input and output components</h5>
<div class="paragraph">
<p>When building a new component, the first step is to identify the way it must be configured.</p>
</div>
<div class="paragraph">
<p>The two main concepts are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <em>DataStore</em> which is the way you can access the backend.</p>
</li>
<li>
<p>The <em>DataSet</em> which is the way you interact with the backend.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Example description</th>
<th class="tableblock halign-left valign-top">DataStore</th>
<th class="tableblock halign-left valign-top">DataSet</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Accessing a relational database like MySQL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JDBC driver, URL, username, password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Query to execute, row mapper, and so on.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Accessing a file system</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File pattern (or directory + file extension/prefix/&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File format, buffer size, and so on.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>It is common to have the dataset including the datastore, because both are required to work. However, it is recommended to replace this pattern by defining both dataset and datastore in a higher level configuration model. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DataSet
public class MyDataSet {
    // ...
}

@DataStore
public class MyDataStore {
    // ...
}


public class MyComponentConfiguration {
    @Option
    private MyDataSet dataset;

    @Option
    private MyDataStore datastore;
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_about_actions"><a class="anchor" href="#_about_actions"></a>About actions</h6>
<div class="paragraph">
<p>Input and output components are particular because they can be linked to a set of actions. It is recommended to wire all the actions you can apply to ensure the consumers of your component can provide a rich experience to their users.</p>
</div>
<div class="paragraph">
<p>The most common actions are the following ones:</p>
</div>
<div class="sect6">
<h7 id="_checkable_datastore"><a class="anchor" href="#_checkable_datastore"></a>@Checkable (DataStore)</h7>
<div class="paragraph">
<p>This action exposes a way to ensure the datastore/connection works.</p>
</div>
<div class="paragraph">
<p>Configuration example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@DataStore
@Checkable
public class JdbcDataStore
  implements Serializable {

  @Option
  private String driver;

  @Option
  private String url;

  @Option
  private String username;

  @Option
  private String password;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Action example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@HealthCheck
public HealthCheckStatus healthCheck(@Option("datastore") JdbcDataStore datastore) {
    if (!doTest(dataStore)) {
        // often add an exception message mapping or equivalent
        return new HealthCheckStatus(Status.KO, "Test failed");
    }
    return new HealthCheckStatus(Status.KO, e.getMessage());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_limitations"><a class="anchor" href="#_limitations"></a>Limitations</h6>
<div class="paragraph">
<p>Until the studio integration is complete, it is recommended to limit processors to one input.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_processor_components"><a class="anchor" href="#_processor_components"></a>Processor components</h5>
<div class="paragraph">
<p>Configuring processor components is simpler than configuring input and output components because it is specific for each component. For example, a mapper takes the mapping between the input and output models:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MappingConfiguration {
    @Option
    private Map&lt;String, String&gt; fieldsMapping;

    @Option
    private boolean ignoreCase;

    //...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_ui_interactions"><a class="anchor" href="#_handling_ui_interactions"></a>Handling UI interactions</h4>
<div class="paragraph">
<p>It is recommended to provide as much information as possible to let the UI work with the data during its edition.</p>
</div>
<div class="sect4">
<h5 id="_validations"><a class="anchor" href="#_validations"></a>Validations</h5>
<div class="sect5">
<h6 id="_light_validations"><a class="anchor" href="#_light_validations"></a>Light validations</h6>
<div class="paragraph">
<p>Light validations are all the validations you can execute on the client side. They are listed in the <a href="component-configuration.html#documentation-ui-hints" class="page">UI hint</a> section.</p>
</div>
<div class="paragraph">
<p>Use light validations first before going with custom validations because they are more efficient.</p>
</div>
</div>
<div class="sect5">
<h6 id="_custom_validations"><a class="anchor" href="#_custom_validations"></a>Custom validations</h6>
<div class="paragraph">
<p>Custom validations enforce custom code to be executed, but are heavier to execute.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Prefer using light validations when possible.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Define an action with the parameters needed for the validation and link the option you want to validate to this action.
For example, to validate a dataset for a JDBC driver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ...
public class JdbcDataStore
  implements Serializable {

  @Option
  @Validable("driver")
  private String driver;

  // ...
}

@AsyncValidation("driver")
public ValidationResult validateDriver(@Option("value") String driver) {
  if (findDriver(driver) != null) {
    return new ValidationResult(Status.OK, "Driver found");
  }
  return new ValidationResult(Status.KO, "Driver not found");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also define a Validable class and use it to validate a form by setting it on your whole configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Note: some parts of the API were removed for clarity

public class MyConfiguration {

  // a lot of @Options
}

public MyComponent {
    public MyComponent(@Validable("configuration") MyConfiguration config) {
        // ...
    }

    //...
}

@AsyncValidation("configuration")
public ValidationResult validateDriver(@Option("value") MyConfiguration configuration) {
  if (isValid(configuration)) {
    return new ValidationResult(Status.OK, "Configuration valid");
  }
  return new ValidationResult(Status.KO, "Driver not valid ${because ...}");
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The parameter binding of the validation method uses the same logic as the component configuration injection. Therefore, the <code>@Option</code> method specifies the prefix to use to reference a parameter.<br>
It is recommended to use <code>@Option("value")</code> until you know exactly why you don&#8217;t use it. This way, the consumer can match the configuration model and just prefix it with <code>value.</code> to send the instance to validate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Validations are triggers based on "events". If you mark part of a configuration as <code>@Validable</code> but this configuration is translated to a widget without any interaction, then no validation will happen. The rule of thumb is to mark only
primitives and simple types (list of primitives) as <code>@Validable</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_completion"><a class="anchor" href="#_completion"></a>Completion</h5>
<div class="paragraph">
<p>It can be handy and user-friendly to provide completion on some fields.
For example, to define completion for available drivers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// ...
public class JdbcDataStore
  implements Serializable {

  @Option
  @Completable("driver")
  private String driver;

  // ...
}

@Completion("driver")
public CompletionList findDrivers() {
    return new CompletionList(findDriverList());
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_component_representation"><a class="anchor" href="#_component_representation"></a>Component representation</h5>
<div class="paragraph">
<p>Each component must have its own icon:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Icon(Icon.IconType.DB_INPUT)
@PartitionMapper(family = "jdbc", name = "input")
public class JdbcPartitionMapper
    implements Serializable {
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can use <a href="http://talend.surge.sh/icons/" class="bare">talend.surge.sh/icons/</a> to find the icon you want to use.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enforcing_versioning_on_components"><a class="anchor" href="#_enforcing_versioning_on_components"></a>Enforcing versioning on components</h4>
<div class="paragraph">
<p>It is recommended to enforce the version of your component, event though it is not mandatory for the first version.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(1)
@PartitionMapper(family = "jdbc", name = "input")
public class JdbcPartitionMapper
    implements Serializable {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you break a configuration entry in a later version;  make sure to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Upgrade the version.</p>
</li>
<li>
<p>Support a migration of the configuration.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(value = 2, migrationHandler = JdbcPartitionMapper.Migrations.class)
@PartitionMapper(family = "jdbc", name = "input")
public class JdbcPartitionMapper
    implements Serializable {

    public static class Migrations implements MigrationHandler {
        // implement your migration
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_testing_components"><a class="anchor" href="#_testing_components"></a>Testing components</h4>
<div class="paragraph">
<p>Testing your components is critical. You can use unit and simple standalone JUnit tests, but it is also highly recommended to have Beam tests in order to make sure that your component works in Big Data.</p>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_17"><a class="anchor" href="#_related_articles_17"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Configuring a component</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="component-loading.html" class="page">Loading a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="index-defining-services.html" class="page">Defining services</a></p>
</li>
<li>
<p><a href="index-testing-components.html" class="page">Testing components</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_component_loading"><a class="anchor" href="#_component_loading"></a>Component Loading</h3>
<div class="paragraph">
<p>Talend Component scanning is based on plugins. To make sure that plugins can be developed in parallel and avoid conflicts, they need to be isolated (component or group of components in a single jar/plugin).</p>
</div>
<div class="paragraph">
<p>Multiple options are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Graph classloading: this option allows you to link the plugins and dependencies together dynamically in any direction.<br>
For example, the graph classloading can be illustrated by OSGi containers.</p>
</li>
<li>
<p>Tree classloading: a shared classloader inherited by plugin classloaders. However, plugin classloader classes are not seen by the shared classloader, nor by other plugins.<br>
For example, the tree classloading is commonly used by Servlet containers where plugins are web applications.</p>
</li>
<li>
<p>Flat classpath: listed for completeness but rejected <em>by design</em> because it doesn&#8217;t comply with this requirement.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to avoid much complexity added by this layer, Talend Component Kit relies on a tree classloading. The advantage is that you don&#8217;t need to define the relationship with other plugins/dependencies, because it is built-in.</p>
</div>
<div class="paragraph">
<p>Here is a representation of this solution:</p>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/classloader-layout.png" target="_blank" rel="noopener"><img src="_images/classloader-layout.png" alt="Classloader layout"></a></span></p>
</div>
<div class="paragraph">
<p>The <em>shared</em> area contains Talend Component Kit API, which only contains by default the classes shared by the plugins.</p>
</div>
<div class="paragraph">
<p>Then, each plugin is loaded with its own classloader and dependencies.</p>
</div>
<div class="sect3">
<h4 id="_packaging_a_plugin"><a class="anchor" href="#_packaging_a_plugin"></a>Packaging a plugin</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This section explains the overall way to handle dependencies but the Talend Maven plugin provides a shortcut for that.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A plugin is a JAR file that was enriched with the list of its dependencies. By default, Talend Component Kit runtime is able to read the output of <code>maven-dependency-plugin</code> in <code>TALEND-INF/dependencies.txt</code>. You just need to make sure that your component defines the following plugin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.0.2&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;create-TALEND-INF/dependencies.txt&lt;/id&gt;
      &lt;phase&gt;process-resources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;list&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;outputFile&gt;${project.build.outputDirectory}/TALEND-INF/dependencies.txt&lt;/outputFile&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once build, check the JAR file and look for the following lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ unzip -p target/mycomponent-1.0.0-SNAPSHOT.jar TALEND-INF/dependencies.txt

The following files have been resolved:
   org.talend.sdk.component:component-api:jar:1.0.0-SNAPSHOT:provided
   org.apache.geronimo.specs:geronimo-annotation_1.3_spec:jar:1.0:provided
   org.superbiz:awesome-project:jar:1.2.3:compile
   junit:junit:jar:4.12:test
   org.hamcrest:hamcrest-core:jar:1.3:test</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is important to see is the scope related to the artifacts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The APIs (<strong>component-api</strong> and <strong>geronimo-annotation_1.3_spec</strong>) are <code>provided</code> because you can consider them to be there when executing (they come with the framework).</p>
</li>
<li>
<p>Your specific dependencies (<code>awesome-project</code> in the example above) are marked as <code>compile</code>: they are included as needed dependencies by the framework (note that using <code>runtime</code> works too).</p>
</li>
<li>
<p>the other dependencies are ignored. For example, <code>test</code> dependencies.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_packaging_an_application"><a class="anchor" href="#_packaging_an_application"></a>Packaging an application</h4>
<div class="paragraph">
<p>Even if a flat classpath deployment is possible, it is not recommended because it would then reduce the capabilities of the components.</p>
</div>
<div class="sect4">
<h5 id="_dependencies_2"><a class="anchor" href="#_dependencies_2"></a>Dependencies</h5>
<div class="paragraph">
<p>The way the framework resolves dependencies is based on a local Maven repository layout. As a quick reminder, it looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>.
├── groupId1
│   └── artifactId1
│       ├── version1
│       │   └── artifactId1-version1.jar
│       └── version2
│           └── artifactId1-version2.jar
└── groupId2
    └── artifactId2
        └── version1
            └── artifactId2-version1.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is all the layout the framework uses. The logic converts <code>t-uple {groupId, artifactId, version, type (jar)}</code> to the path in the repository.</p>
</div>
<div class="paragraph">
<p>Talend Component Kit runtime has two ways to find an artifact:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From the file system based on a configured Maven 2 repository.</p>
</li>
<li>
<p>From a fat JAR (uber JAR) with a nested Maven repository under <code>MAVEN-INF/repository</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first option uses either <code>${user.home}/.m2/repository</code> (default) or a specific path configured when creating a <code>ComponentManager</code>.
The nested repository option needs some configuration during the packaging to ensure the repository is correctly created.</p>
</div>
<div class="sect5">
<h6 id="_creating_a_nested_maven_repository_with_maven_shade_plugin"><a class="anchor" href="#_creating_a_nested_maven_repository_with_maven_shade_plugin"></a>Creating a nested Maven repository with maven-shade-plugin</h6>
<div class="paragraph">
<p>To create the nested <code>MAVEN-INF/repository</code> repository, you can use the <code>nested-maven-repository</code> extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.2.1&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;shade&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;transformers&gt;
          &lt;transformer implementation="org.talend.sdk.component.container.maven.shade.ContainerDependenciesTransformer"&gt;
            &lt;session&gt;${session}&lt;/session&gt;
          &lt;/transformer&gt;
        &lt;/transformers&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;nested-maven-repository&lt;/artifactId&gt;
      &lt;version&gt;${the.plugin.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_listing_needed_plugins"><a class="anchor" href="#_listing_needed_plugins"></a>Listing needed plugins</h5>
<div class="paragraph">
<p>Plugins are usually programmatically registered. If you want to make some of them automatically available, you need to generate a <code>TALEND-INF/plugins.properties</code> file that maps a plugin name to coordinates found with the Maven mechanism described above.</p>
</div>
<div class="paragraph">
<p>You can enrich <code>maven-shade-plugin</code> to do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.2.1&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;shade&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;transformers&gt;
          &lt;transformer implementation="org.talend.sdk.component.container.maven.shade.PluginTransformer"&gt;
            &lt;session&gt;${session}&lt;/session&gt;
          &lt;/transformer&gt;
        &lt;/transformers&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;nested-maven-repository&lt;/artifactId&gt;
      &lt;version&gt;${the.plugin.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_maven_shade_plugin_extensions"><a class="anchor" href="#_maven_shade_plugin_extensions"></a>maven-shade-plugin extensions</h5>
<div class="paragraph">
<p>Here is a final job/application bundle based on maven-shade-plugin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.2.1&lt;/version&gt;
  &lt;configuration&gt;
    &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;
    &lt;filters&gt;
      &lt;filter&gt;
        &lt;artifact&gt;*:*&lt;/artifact&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;META-INF/<strong>.SF&lt;/exclude&gt;
          &lt;exclude&gt;META-INF/</strong>.DSA&lt;/exclude&gt;
          &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/filter&gt;
    &lt;/filters&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;shade&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;shadedClassifierName&gt;shaded&lt;/shadedClassifierName&gt;
        &lt;transformers&gt;
          &lt;transformer implementation="org.apache.maven.plugins.shade.resource.ServicesResourceTransformer"/&gt;
          &lt;transformer
              implementation="org.talend.sdk.component.container.maven.shade.ContainerDependenciesTransformer"&gt;
            &lt;session&gt;${session}&lt;/session&gt;
            &lt;userArtifacts&gt;
              &lt;artifact&gt;
                &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
                &lt;artifactId&gt;sample-component&lt;/artifactId&gt;
                &lt;version&gt;1.0&lt;/version&gt;
                &lt;type&gt;jar&lt;/type&gt;
              &lt;/artifact&gt;
            &lt;/userArtifacts&gt;
          &lt;/transformer&gt;
          &lt;transformer implementation="org.talend.sdk.component.container.maven.shade.PluginTransformer"&gt;
            &lt;session&gt;${session}&lt;/session&gt;
            &lt;userArtifacts&gt;
              &lt;artifact&gt;
                &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
                &lt;artifactId&gt;sample-component&lt;/artifactId&gt;
                &lt;version&gt;1.0&lt;/version&gt;
                &lt;type&gt;jar&lt;/type&gt;
              &lt;/artifact&gt;
            &lt;/userArtifacts&gt;
          &lt;/transformer&gt;
        &lt;/transformers&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;nested-maven-repository&lt;/artifactId&gt;
      &lt;version&gt;${the.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The configuration unrelated to transformers depends on your application.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ContainerDependenciesTransformer</code> embeds a Maven repository and <code>PluginTransformer</code> to create a file that lists (one per line) artifacts (representing plugins).</p>
</div>
<div class="paragraph">
<p>Both transformers share most of their configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>session</code>: must be set to <code>${session}</code>. This is used to retrieve dependencies.</p>
</li>
<li>
<p><code>scope</code>: a comma-separated list of scopes to include in the artifact filtering (note that the default will rely on <code>provided</code> but you can replace it by <code>compile</code>, <code>runtime</code>, <code>runtime+compile</code>, <code>runtime+system</code> or <code>test</code>).</p>
</li>
<li>
<p><code>include</code>: a comma-separated list of artifacts to include in the artifact filtering.</p>
</li>
<li>
<p><code>exclude</code>: a comma-separated list of artifacts to exclude in the artifact filtering.</p>
</li>
<li>
<p><code>userArtifacts</code>: set of artifacts to include (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline. This parameter is mainly useful for <code>PluginTransformer</code>.</p>
</li>
<li>
<p><code>includeTransitiveDependencies</code>: should transitive dependencies of the components be included. Set to <code>true</code> by default. It is active for <code>userArtifacts</code>.</p>
</li>
<li>
<p><code>includeProjectComponentDependencies</code>: should component project dependencies be included. Set to <code>false</code> by default. It is not needed when a job project uses isolation for components.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
With the component tooling, it is recommended to keep default locations.<br>
Also if you need to use project dependencies, you can need to refactor your project structure to ensure component isolation.<br>
Talend Component Kit lets you handle that part but the recommended practice is to use <code>userArtifacts</code> for the components instead of project <code>&lt;dependencies&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_containerdependenciestransformer"><a class="anchor" href="#_containerdependenciestransformer"></a>ContainerDependenciesTransformer</h6>
<div class="paragraph">
<p><code>ContainerDependenciesTransformer</code> specific configuration is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>repositoryBase</code>: base repository location (<code>MAVEN-INF/repository</code> by default).</p>
</li>
<li>
<p><code>ignoredPaths</code>: a comma-separated list of folders not to create in the output JAR. This is common for folders already created by other transformers/build parts.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_plugintransformer"><a class="anchor" href="#_plugintransformer"></a>PluginTransformer</h6>
<div class="paragraph">
<p><code>ContainerDependenciesTransformer</code> specific configuration is the following one:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pluginListResource</code>: base repository location (default to <code>TALEND-INF/plugins.properties</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, if you want to list only the plugins you use, you can configure this transformer as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;transformer implementation="org.talend.sdk.component.container.maven.shade.PluginTransformer"&gt;
  &lt;session&gt;${session}&lt;/session&gt;
  &lt;include&gt;org.talend.sdk.component:component-x,org.talend.sdk.component:component-y,org.talend.sdk.component:component-z&lt;/include&gt;
&lt;/transformer&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_component_scanning_rules_and_default_exclusions"><a class="anchor" href="#_component_scanning_rules_and_default_exclusions"></a>Component scanning rules and default exclusions</h4>
<div class="paragraph">
<p>The framework uses two kind of filterings when scanning your component.
One based on the JAR content - the presence of <code>TALEND-INF/dependencies.txt</code> and one based on the package name.
Make sure that your component definitions (including services) are in a scanned module if they are not registered manually using <code>ComponentManager.instance().addPlugin()</code>, and that the component package is not excluded.</p>
</div>
<div class="sect4">
<h5 id="_package_scanning"><a class="anchor" href="#_package_scanning"></a>Package Scanning</h5>
<div class="paragraph">
<p>Since the framework can be used in the case of <em>fatjars</em> or <em>shades</em>,
and because it still uses scanning,
it is important to ensure we don&#8217;t scan the whole classes for performances reason.</p>
</div>
<div class="paragraph">
<p>Therefore, the following packages are ignored:</p>
</div>
<div class="ulist talend-filterlist">
<ul>
<li>
<p>avro.shaded</p>
</li>
<li>
<p>com.codehale.metrics</p>
</li>
<li>
<p>com.ctc.wstx</p>
</li>
<li>
<p>com.datastax.driver</p>
</li>
<li>
<p>com.fasterxml.jackson</p>
</li>
<li>
<p>com.google.common</p>
</li>
<li>
<p>com.google.thirdparty</p>
</li>
<li>
<p>com.ibm.wsdl</p>
</li>
<li>
<p>com.jcraft.jsch</p>
</li>
<li>
<p>com.kenai</p>
</li>
<li>
<p>com.sun.istack</p>
</li>
<li>
<p>com.sun.xml</p>
</li>
<li>
<p>com.talend.shaded</p>
</li>
<li>
<p>com.thoughtworks</p>
</li>
<li>
<p>io.jsonwebtoken</p>
</li>
<li>
<p>io.netty</p>
</li>
<li>
<p>io.swagger</p>
</li>
<li>
<p>javax</p>
</li>
<li>
<p>jnr</p>
</li>
<li>
<p>junit</p>
</li>
<li>
<p>net.sf.ehcache</p>
</li>
<li>
<p>net.shibboleth</p>
</li>
<li>
<p>org.aeonbits.owner</p>
</li>
<li>
<p>org.apache</p>
</li>
<li>
<p>org.bouncycastle</p>
</li>
<li>
<p>org.codehaus</p>
</li>
<li>
<p>org.cryptacular</p>
</li>
<li>
<p>org.eclipse</p>
</li>
<li>
<p>org.fusesource</p>
</li>
<li>
<p>org.h2</p>
</li>
<li>
<p>org.hamcrest</p>
</li>
<li>
<p>org.hsqldb</p>
</li>
<li>
<p>org.jasypt</p>
</li>
<li>
<p>org.jboss</p>
</li>
<li>
<p>org.joda</p>
</li>
<li>
<p>org.jose4j</p>
</li>
<li>
<p>org.junit</p>
</li>
<li>
<p>org.jvnet</p>
</li>
<li>
<p>org.metatype</p>
</li>
<li>
<p>org.objectweb</p>
</li>
<li>
<p>org.openejb</p>
</li>
<li>
<p>org.opensaml</p>
</li>
<li>
<p>org.slf4j</p>
</li>
<li>
<p>org.swizzle</p>
</li>
<li>
<p>org.terracotta</p>
</li>
<li>
<p>org.tukaani</p>
</li>
<li>
<p>org.yaml</p>
</li>
<li>
<p>serp</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
it is not recommanded but possible to add in your plugin module a
<code>TALEND-INF/scanning.properties</code> file with <code>classloader.includes</code> and
<code>classloader.excludes</code> entries to refine the scanning with custom rules.
In such a case, exclusions win over inclusions.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_18"><a class="anchor" href="#_related_articles_18"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the starter</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Defining component layout and configuration</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_components_2"><a class="anchor" href="#_testing_components_2"></a>Testing components</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Developing new components includes testing them in the required execution environments. Use the following articles to learn about the best practices and the available options to fully test your components.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Component testing kit</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
<li>
<p><a href="https://beam.apache.org/documentation/programming-guide/#creating-a-pipeline">Beam Pipeline API</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_testing_best_practices"><a class="anchor" href="#_testing_best_practices"></a>Testing best practices</h3>
<div class="paragraph">
<p>This section mainly concerns tools that can be used with JUnit. You can use most of these best practices with TestNG as well.</p>
</div>
<div class="sect3">
<h4 id="_parameterized_tests"><a class="anchor" href="#_parameterized_tests"></a>Parameterized tests</h4>
<div class="paragraph">
<p>Parameterized tests are a great solution to repeat the same test multiple times. This method of testing requires defining a test scenario (<code>I test function F</code>) and making the input/output data dynamic.</p>
</div>
<div class="sect4">
<h5 id="_junit_4"><a class="anchor" href="#_junit_4"></a>JUnit 4</h5>
<div class="paragraph">
<p>Here is a test example, which validates a connection URI using <code>ConnectionService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyConnectionURITest {
    @Test
    public void checkMySQL() {
        assertTrue(new ConnectionService().isValid("jdbc:mysql://localhost:3306/mysql"));
    }

    @Test
    public void checkOracle() {
        assertTrue(new ConnectionService().isValid("jdbc:oracle:thin:@//myhost:1521/oracle"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The testing method is always the same. Only values are changing. It can therefore be rewritten using JUnit <code>Parameterized</code> runner, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Parameterized.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class MyConnectionURITest {

    @Parameterized.Parameters(name = "{0}") <i class="conum" data-value="2"></i><b>(2)</b>
    public static Iterable&lt;String&gt; uris() { <i class="conum" data-value="3"></i><b>(3)</b>
        return asList(
            "jdbc:mysql://localhost:3306/mysql",
            "jdbc:oracle:thin:@//myhost:1521/oracle");
    }

    @Parameterized.Parameter <i class="conum" data-value="4"></i><b>(4)</b>
    public String uri;

    @Test
    public void isValid() { <i class="conum" data-value="5"></i><b>(5)</b>
        assertNotNull(uri);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Parameterized</code> is the runner that understands <code>@Parameters</code> and how to use it. If needed, you can generate random data here.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>By default the name of the executed test is the index of the data. Here, it is customized using the first <code>toString()</code> parameter value to have something more readable.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>@Parameters</code> method must be static and return an array or iterable of the data used by the tests.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You can then inject the current data using the <code>@Parameter</code> annotation. It can take a parameter if you use an array of array instead of an iterable of object in <code>@Parameterized</code>. You can select which item you want to inject.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>@Test</code> method is executed using the contextual data. In this sample, it gets executed twice with the two specified URIs.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You don&#8217;t have to define a single <code>@Test</code> method. If you define multiple methods, each of them is executed with all the data. For example, if another test is added to the previous example, four tests are executed - 2 per data).
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_junit_5"><a class="anchor" href="#_junit_5"></a>JUnit 5</h5>
<div class="paragraph">
<p>With JUnit 5, parameterized tests are easier to use. The full documentation is available at <a href="http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests" class="bare">junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests</a>.</p>
</div>
<div class="paragraph">
<p>The main difference with JUnit 4 is that you can also define inline that the test method is a parameterized test as well as the values to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ParameterizedTest
@ValueSource(strings = { "racecar", "radar", "able was I ere I saw elba" })
void mytest(String currentValue) {
    // do test
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, you can still use the previous behavior with a method binding configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ParameterizedTest
@MethodSource("stringProvider")
void mytest(String currentValue) {
    // do test
}

static Stream&lt;String&gt; stringProvider() {
    return Stream.of("foo", "bar");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This last option allows you to inject any type of value - not only primitives - which is common to define scenarios.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Add the <code>junit-jupiter-params</code> dependency to benefit from this feature.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_19"><a class="anchor" href="#_related_articles_19"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Testing component runtime</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_component_runtime_testing"><a class="anchor" href="#_component_runtime_testing"></a>component-runtime-testing</h3>
<div class="sect3">
<h4 id="_component_runtime_junit"><a class="anchor" href="#_component_runtime_junit"></a>component-runtime-junit</h4>
<div class="paragraph">
<p><code>component-runtime-junit</code> is a test library that allows you to validate simple logic based on the Talend Component Kit tooling.</p>
</div>
<div class="paragraph">
<p>To import it, add the following dependency to your project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;component-runtime-junit&lt;/artifactId&gt;
  &lt;version&gt;${talend-component.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This dependency also provides mocked components that you can use with your own component to create tests.</p>
</div>
<div class="paragraph">
<p>The mocked components are provided under the <code>test</code> family:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>emitter</code>     : a mock of an input component</p>
</li>
<li>
<p><code>collector</code>   : a mock of an output component</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The collector is "per thread" by default. If you are executing a Beam (or concurrent) job, it will not work.
To switch to a JVM wide storage, set the <code>talend.component.junit.handler.state</code> system property to <code>static</code> (default being <code>thread</code>).
You can do it in a <code>maven-surefire-plugin</code> <code>execution</code>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_junit_4_2"><a class="anchor" href="#_junit_4_2"></a>JUnit 4</h5>
<div class="paragraph">
<p>You can define a standard JUnit test and use the <code>SimpleComponentRule</code> rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyComponentTest {

    @Rule <i class="conum" data-value="1"></i><b>(1)</b>
    public final SimpleComponentRule components = new SimpleComponentRule("org.talend.sdk.component.mycomponent");

    @Test
    public void produce() {
        Job.components() <i class="conum" data-value="2"></i><b>(2)</b>
             .component("mycomponent","yourcomponentfamily://yourcomponent?"+createComponentConfig())
             .component("collector", "test://collector")
           .connections()
             .from("mycomponent").to("collector")
           .build()
           .run();

        final List&lt;MyRecord&gt; records = components.getCollectedData(MyRecord.class); <i class="conum" data-value="3"></i><b>(3)</b>
        doAssertRecords(records); // depending your test
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The rule creates a component manager and provides two mock components: an emitter and a collector. Set the root package of your component to enable it.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Define any chain that you want to test. It generally uses the mock as source or collector.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Validate your component behavior. For a source, you can assert that the right records were emitted in the mock collect.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The rule can also be defined as a <code>@ClassRule</code> to start it once per class and not per test as with <code>@Rule</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To go further, you can add the <code>ServiceInjectionRule</code> rule, which allows to inject all the component family services into the test class by marking test class fields with <code>@InjectService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SimpleComponentRuleTest {

    @ClassRule
    public static final SimpleComponentRule COMPONENT_FACTORY = new SimpleComponentRule("...");

    @Rule <i class="conum" data-value="1"></i><b>(1)</b>
    public final ServiceInjectionRule injections = new ServiceInjectionRule(COMPONENT_FACTORY, this); <i class="conum" data-value="2"></i><b>(2)</b>

    @Service <i class="conum" data-value="3"></i><b>(3)</b>
    private LocalConfiguration configuration;

    @Service
    private Jsonb jsonb;

    @Test
    public void test() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The injection requires the test instance, so it must be a <code>@Rule</code> rather than a <code>@ClassRule</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>ComponentsController</code> is passed to the rule, which for JUnit 4 is the <code>SimpleComponentRule</code>, as well as the test instance to inject services in.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>All service fields are marked with <code>@Service</code> to let the rule inject them before the test is ran.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_junit_5_2"><a class="anchor" href="#_junit_5_2"></a>JUnit 5</h5>
<div class="paragraph">
<p>The JUnit 5 integration is very similar to JUnit 4, except that it uses the JUnit 5 extension mechanism.</p>
</div>
<div class="paragraph">
<p>The entry point is the <code>@WithComponents</code> annotation that you add to your test class, and which takes the component package you want to test. You can use <code>@Injected</code> to inject an instance of <code>ComponentsHandler</code> - which exposes the same utilities than the JUnit 4 rule - in a test class field :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithComponents("org.talend.sdk.component.junit.component") <i class="conum" data-value="1"></i><b>(1)</b>
public class ComponentExtensionTest {
    @Injected <i class="conum" data-value="2"></i><b>(2)</b>
    private ComponentsHandler handler;

    @Test
    public void manualMapper() {
        final Mapper mapper = handler.createMapper(Source.class, new Source.Config() {

            {
                values = asList("a", "b");
            }
        });
        assertFalse(mapper.isStream());
        final Input input = mapper.create();
        assertEquals("a", input.next());
        assertEquals("b", input.next());
        assertNull(input.next());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The annotation defines which components to register in the test context.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The field allows to get the handler to be able to orchestrate the tests.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use JUnit 5 for the first time, keep in mind that the imports changed and that you need to use <code>org.junit.jupiter.api.Test</code> instead of <code>org.junit.Test</code>.
Some IDE versions and <code>surefire</code> versions can also require you to install either a plugin or a specific configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As for JUnit 4, you can go further by injecting test class fields marked with <code>@InjectService</code>, but there is no additional extension to specify in this case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithComponents("...")
class ComponentExtensionTest {

    @Service <i class="conum" data-value="1"></i><b>(1)</b>
    private LocalConfiguration configuration;

    @Service
    private Jsonb jsonb;

    @Test
    void test() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>All service fields are marked with <code>@Service</code> to let the rule inject them before the test is ran.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_streaming_components"><a class="anchor" href="#_streaming_components"></a>Streaming components</h5>
<div class="paragraph">
<p>Streaming components have the issue to not stop by design. The Job DSL exposes two properties to help with that issue:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>streaming.maxRecords</code>: enables to request a maximum number of records</p>
</li>
<li>
<p><code>streaming.maxDurationMs</code>: enables to request a maximum duration for the execution of the input</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can set them as properties on the job:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">job.property("streaming.maxRecords", 5);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_mocking_the_output"><a class="anchor" href="#_mocking_the_output"></a>Mocking the output</h5>
<div class="paragraph">
<p>Using the <code>test://collector</code> component as shown in the previous sample stores all records emitted by the chain (typically your source) in memory. You can then access them using <code>theSimpleComponentRule.getCollectedData(type)</code>.</p>
</div>
<div class="paragraph">
<p>Note that this method filters by type. If you don&#8217;t need any specific type, you can use <code>Object.class</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mocking_the_input"><a class="anchor" href="#_mocking_the_input"></a>Mocking the input</h5>
<div class="paragraph">
<p>The input mocking is symmetric to the output. In this case, you provide the data you want to inject:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyComponentTest {

    @Rule
    public final SimpleComponentRule components = new SimpleComponentRule("org.talend.sdk.component.mycomponent");

    @Test
    public void produce() {
        components.setInputData(asList(createData(), createData(), createData())); <i class="conum" data-value="1"></i><b>(1)</b>

        Job.components()
             .component("emitter","test://emitter")
             .component("out", "yourcomponentfamily://myoutput?"+createComponentConfig())
           .connections()
              .from("emitter").to("out")
           .build()
           .run();

        assertMyOutputProcessedTheInputData();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>using <code>setInputData</code>, you prepare the execution(s) to have a fake input when using the "test"/"emitter" component.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_creating_runtime_configuration_from_component_configuration"><a class="anchor" href="#_creating_runtime_configuration_from_component_configuration"></a>Creating runtime configuration from component configuration</h5>
<div class="paragraph">
<p>The component configuration is a POJO (using <code>@Option</code> on fields) and the runtime configuration (<code>ExecutionChainBuilder</code>) uses a <code>Map&lt;String, String&gt;</code>. To make the conversion easier, the JUnit integration provides a <code>SimpleFactory.configurationByExample</code> utility to get this map instance from a configuration instance.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final MyComponentConfig componentConfig = new MyComponentConfig();
componentConfig.setUser("....");
// .. other inits

final Map&lt;String, String&gt; configuration = configurationByExample(componentConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same factory provides a fluent DSL to create the configuration by calling <code>configurationByExample</code> without any parameter.
The advantage is to be able to convert an object as a <code>Map&lt;String, String&gt;</code> or as a query string
in order to use it with the <code>Job</code> DSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final String uri = "family://component?" +
    configurationByExample().forInstance(componentConfig).configured().toQueryString();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It handles the encoding of the URI to ensure it is correctly done.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When writing tests for your components, you can force the <code>maxBatchSize</code> parameter value by setting it with the following syntax: <code>$configuration.$maxBatchSize=10</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_testing_a_mapper"><a class="anchor" href="#_testing_a_mapper"></a>Testing a Mapper</h5>
<div class="paragraph">
<p>The <code>SimpleComponentRule</code> also allows to test a mapper unitarily. You can get an instance from a configuration and execute this instance to collect the output.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapperTest {

    @ClassRule
    public static final SimpleComponentRule COMPONENT_FACTORY = new SimpleComponentRule(
            "org.company.talend.component");

    @Test
    public void mapper() {
        final Mapper mapper = COMPONENT_FACTORY.createMapper(MyMapper.class, new Source.Config() {{
            values = asList("a", "b");
        }});
        assertEquals(asList("a", "b"), COMPONENT_FACTORY.collectAsList(String.class, mapper));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_testing_a_processor"><a class="anchor" href="#_testing_a_processor"></a>Testing a Processor</h5>
<div class="paragraph">
<p>As for a mapper, a processor is testable unitary. However, this case can be more complex in case of multiple inputs or outputs.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ProcessorTest {

    @ClassRule
    public static final SimpleComponentRule COMPONENT_FACTORY = new SimpleComponentRule(
            "org.company.talend.component");

    @Test
    public void processor() {
        final Processor processor = COMPONENT_FACTORY.createProcessor(Transform.class, null);
        final SimpleComponentRule.Outputs outputs = COMPONENT_FACTORY.collect(processor,
                        new JoinInputFactory().withInput("__default__", asList(new Transform.Record("a"), new Transform.Record("bb")))
                                              .withInput("second", asList(new Transform.Record("1"), new Transform.Record("2")))
                );
        assertEquals(2, outputs.size());
        assertEquals(asList(2, 3), outputs.get(Integer.class, "size"));
        assertEquals(asList("a1", "bb2"), outputs.get(String.class, "value"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rule allows you to instantiate a <code>Processor</code> from your code, and then to <code>collect</code> the output from the inputs you pass in. There are two convenient implementations of the input factory:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>MainInputFactory</code> for processors using only the default input.</p>
</li>
<li>
<p><code>JoinInputfactory</code> with the <code>withInput(branch, data)</code> method for processors using multiple inputs. The first argument is the branch name and the second argument is the data used by the branch.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If needed, you can also implement your own input representation using <code>org.talend.sdk.component.junit.ControllableInputFactory</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_component_runtime_testing_spark"><a class="anchor" href="#_component_runtime_testing_spark"></a>component-runtime-testing-spark</h4>
<div class="paragraph">
<p>The following artifact allows you to test against a Spark cluster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;component-runtime-testing-spark&lt;/artifactId&gt;
  &lt;version&gt;${talend-component.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_junit_4_3"><a class="anchor" href="#_junit_4_3"></a>JUnit 4</h5>
<div class="paragraph">
<p>The testing relies on a JUnit <code>TestRule</code>. It is recommended to use it as a <code>@ClassRule</code>, to make sure that a single instance of a Spark cluster is built. You can also use it as a simple <code>@Rule</code>, to create the Spark cluster instances per method instead of per test class.</p>
</div>
<div class="paragraph">
<p>The <code>@ClassRule</code> takes the Spark and Scala versions to use as parameters. It then forks a master and N slaves.
Finally, the <code>submit*</code> method allows you to send jobs either from the test classpath or from a shade if you run it as an integration test.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SparkClusterRuleTest {

    @ClassRule
    public static final SparkClusterRule SPARK = new SparkClusterRule("2.10", "1.6.3", 1);

    @Test
    public void classpathSubmit() throws IOException {
        SPARK.submitClasspath(SubmittableMain.class, getMainArgs());

        // wait for the test to pass
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This testing methodology works with <code>@Parameterized</code>. You can submit several jobs with different arguments and even combine it with Beam <code>TestPipeline</code> if you make it <code>transient</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_junit_5_3"><a class="anchor" href="#_junit_5_3"></a>JUnit 5</h5>
<div class="paragraph">
<p>The integration of that Spark cluster logic with JUnit 5 is done using the <code>@WithSpark</code> marker for the extension. Optionally, it allows you to inject—through <code>@SparkInject</code>—the <code>BaseSpark&lt;?&gt;</code> handler to access the Spark cluster meta information. For example, its host/port.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@WithSpark
class SparkExtensionTest {

    @SparkInject
    private BaseSpark&lt;?&gt; spark;

    @Test
    void classpathSubmit() throws IOException {
        final File out = new File(jarLocation(SparkClusterRuleTest.class).getParentFile(), "classpathSubmitJunit5.out");
        if (out.exists()) {
            out.delete();
        }
        spark.submitClasspath(SparkClusterRuleTest.SubmittableMain.class, spark.getSparkMaster(), out.getAbsolutePath());

        await().atMost(5, MINUTES).until(
                () -&gt; out.exists() ? Files.readAllLines(out.toPath()).stream().collect(joining("\n")).trim() : null,
                equalTo("b -&gt; 1\na -&gt; 1"));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_checking_the_job_execution_status"><a class="anchor" href="#_checking_the_job_execution_status"></a>Checking the job execution status</h5>
<div class="paragraph">
<p>Currently, <code>SparkClusterRule</code> does not allow to know when a job execution is done, even by exposing and polling the web UI URL to check. The best solution at the moment is to make sure that the output of your job exists and contains the right value.</p>
</div>
<div class="paragraph">
<p><code>awaitability</code> or any equivalent library can help you to implement such logic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.awaitility&lt;/groupId&gt;
  &lt;artifactId&gt;awaitility&lt;/artifactId&gt;
  &lt;version&gt;3.0.0&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To wait until a file exists and check that its content (for example) is the expected one, you can use the following logic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">await()
    .atMost(5, MINUTES)
    .until(
        () -&gt; out.exists() ? Files.readAllLines(out.toPath()).stream().collect(joining("\n")).trim() : null,
        equalTo("the expected content of the file"));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="component-runtime-http-junit"><a class="anchor" href="#component-runtime-http-junit"></a>component-runtime-http-junit</h4>
<div class="paragraph">
<p>The HTTP JUnit module allows you to mock REST API very simply. The module coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;component-runtime-http-junit&lt;/artifactId&gt;
  &lt;version&gt;${talend-component.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This module uses Apache Johnzon and Netty. If you have any conflict (in particular with Netty), you can add the <code>shaded</code> classifier to the dependency. This way, both dependencies are shaded, which avoids conflicts with your component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It supports both JUnit 4 and JUnit 5. The concept is the exact same one: the extension/rule
is able to serve precomputed responses saved in the classpath.</p>
</div>
<div class="paragraph">
<p>You can plug your own <code>ResponseLocator</code> to map a request to a response, but the default implementation - which should be sufficient in most cases - looks in <code>talend/testing/http/&lt;class name&gt;_&lt;method name&gt;.json</code>. Note that you can also put it in <code>talend/testing/http/&lt;request path&gt;.json</code>.</p>
</div>
<div class="sect4">
<h5 id="_junit_4_4"><a class="anchor" href="#_junit_4_4"></a>JUnit 4</h5>
<div class="paragraph">
<p>JUnit 4 setup is done through two rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JUnit4HttpApi</code>, which is starts the server.</p>
</li>
<li>
<p><code>JUnit4HttpApiPerMethodConfigurator</code>, which configures the server per test and also handles the capture mode.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you don&#8217;t use the <code>JUnit4HttpApiPerMethodConfigurator</code>, the capture feature is disabled and the per test mocking is not available.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Test example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyRESTApiTest {
    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi();

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);

    @Test
    public void direct() throws Exception {
        // ... do your requests
    }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_ssl"><a class="anchor" href="#_ssl"></a>SSL</h6>
<div class="paragraph">
<p>For tests using SSL-based services, you need to use <code>activeSsl()</code> on the <code>JUnit4HttpApi</code> rule.</p>
</div>
<div class="paragraph">
<p>You can access the client SSL socket factory through the API handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ClassRule
public static final JUnit4HttpApi API = new JUnit4HttpApi()<strong>.activeSsl()</strong>;

@Test
public void test() throws Exception {
    final HttpsURLConnection connection = getHttpsConnection();
    connection.setSSLSocketFactory(API.getSslContext().getSocketFactory());
    // ....
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_query_parameters"><a class="anchor" href="#_query_parameters"></a>Query Parameters</h6>
<div class="paragraph">
<p>Sometimes the query parameters are sensitive and you don&#8217;t want to store them when capturing.
In such cases, you can drop them from the captured data (<code>.json</code>) and the mock implementation will
be able to match the request ignoring the query parameters.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_junit_5_4"><a class="anchor" href="#_junit_5_4"></a>JUnit 5</h5>
<div class="paragraph">
<p>JUnit 5 uses a JUnit 5 extension based on the <code>HttpApi</code> annotation that you can add to your test class. You can inject the test handler - which has some utilities for advanced cases - through <code>@HttpApiInject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@HttpApi
class JUnit5HttpApiTest {
    @HttpApiInject
    private HttpApiHandler&lt;?&gt; handler;

    @Test
    void getProxy() throws Exception {
        // .... do your requests
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The injection is optional and the <code>@HttpApi</code> annotation allows you to configure several test behaviors.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_ssl_2"><a class="anchor" href="#_ssl_2"></a>SSL</h6>
<div class="paragraph">
<p>For tests using SSL-based services, you need to use <code>@HttpApi(useSsl = true)</code>.</p>
</div>
<div class="paragraph">
<p>You can access the client SSL socket factory through the API handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@HttpApi*(useSsl = true)*
class MyHttpsApiTest {
    @HttpApiInject
    private HttpApiHandler&lt;?&gt; handler;

    @Test
    void test() throws Exception {
        final HttpsURLConnection connection = getHttpsConnection();
        connection.setSSLSocketFactory(handler.getSslContext().getSocketFactory());
        // ....
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_capturing_mode"><a class="anchor" href="#_capturing_mode"></a>Capturing mode</h5>
<div class="paragraph">
<p>The strength of this implementation is to run a small proxy server and to auto-configure the JVM:
<code>http[s].proxyHost</code>, <code>http[s].proxyPort</code>, <code>HttpsURLConnection#defaultSSLSocketFactory</code> and <code>SSLContext#default</code> are auto-configured to work out-of-the-box with the proxy.</p>
</div>
<div class="paragraph">
<p>It allows you to keep the native and real URLs in your tests. For example, the following test is valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class GoogleTest {
    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi();

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);

    @Test
    public void google() throws Exception {
        assertEquals(HttpURLConnection.HTTP_OK, get("https://google.fr?q=Talend"));
    }

    private int get(final String uri) throws Exception {
        // do the GET request, skipped for brievity
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute this test, it fails with an HTTP 400 error because the proxy does not find the mocked response.<br>
You can create it manually, as described in <a href="#component-runtime-http-junit">component-runtime-http-junit</a>, but you can also set the <code>talend.junit.http.capture</code> property to the folder storing the captures. It must be the root folder and not the folder where the JSON files are located (not prefixed by <code>talend/testing/http</code> by default).</p>
</div>
<div class="paragraph">
<p>In most cases, use <code>src/test/resources</code>. If <code>new File("src/test/resources")</code> resolves the valid folder when executing your test (Maven default), then you can just set the system property to <code>true</code>. Otherwise, you need to adjust accordingly the system property value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When set to <code>false</code>, the capture is enabled. Instead, captures are saved in a <code>false/</code> directory.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the tests run with this system property, the testing framework creates the correct mock response files. After that, you can remove the system property. The tests will still pass, using <code>google.com</code>, even if you disconnect your machine from the Internet.</p>
</div>
</div>
<div class="sect4">
<h5 id="_passthrough_mode"><a class="anchor" href="#_passthrough_mode"></a>Passthrough mode</h5>
<div class="paragraph">
<p>If you set the <code>talend.junit.http.passthrough</code> system property to <code>true</code>, the server acts as a proxy and executes each request to the actual server - similarly to the capturing mode.</p>
</div>
</div>
<div class="sect4">
<h5 id="_junit_5_and_capture_names"><a class="anchor" href="#_junit_5_and_capture_names"></a>JUnit 5 and capture names</h5>
<div class="paragraph">
<p>With its <code>@ParameterizedTest</code>, you can want to customize the name of the output file for JUnit 5 based captures/mocks.
Concretely you want to ensure the replay of the same method with different data lead to different mock files.
By default the framework will use the display name of the test to specialize it but it is not always very friendly.
If you want some more advanced control over the name you can use <code>@HttpApiName("myCapture.json")</code> on the test method.
To parameterize the name using <code>@HttpApiName</code>, you can use the placeholders <code>${class}</code> and <code>${method}</code> which represents
the declaring class and method name, and <code>${displayName}</code> which represents the method name.</p>
</div>
<div class="paragraph">
<p>Here is an example to use the same capture file for all repeated test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@HttpApiName("${class}_${method}")
@RepeatedTest(5)
void run() throws Exception {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here, the same example but using different files for each repetition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@HttpApiName("${class}_${method}_${displayName}")
@RepeatedTest(5)
void run() throws Exception {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_20"><a class="anchor" href="#_related_articles_20"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_beam_testing"><a class="anchor" href="#_beam_testing"></a>Beam testing</h3>
<div class="paragraph">
<p>If you want to make sure that your component works in Beam and don&#8217;t want to use Spark, you can try with the Direct Runner.</p>
</div>
<div class="paragraph">
<p>Check <a href="https://beam.apache.org/contribute/testing/" class="bare">beam.apache.org/contribute/testing/</a> for more details.</p>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_21"><a class="anchor" href="#_related_articles_21"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Testing component runtime</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing_on_multiple_environments"><a class="anchor" href="#_testing_on_multiple_environments"></a>Testing on multiple environments</h3>
<div class="paragraph">
<p>JUnit (4 or 5) already provides ways to parameterize tests and execute the same "test logic"
against several sets of data. However, it is not very convenient for testing multiple environments.</p>
</div>
<div class="paragraph">
<p>For example, with Beam, you can test your code against multiple runners. But it requires resolving conflicts between runner dependencies, setting the correct classloaders, and so on.</p>
</div>
<div class="paragraph">
<p>To simplify such cases, the framework provides you a multi-environment support for your tests, through the JUnit module, which works with both JUnit 4 and JUnit 5.</p>
</div>
<div class="sect3">
<h4 id="_junit_4_5"><a class="anchor" href="#_junit_4_5"></a>JUnit 4</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(MultiEnvironmentsRunner.class)
@Environment(Env1.class)
@Environment(Env2.class)
public class TheTest {
    @Test
    public void test1() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MultiEnvironmentsRunner</code> executes the tests for each defined environments. With the example above, it means that it runs <code>test1</code> for <code>Env1</code> and <code>Env2</code>.</p>
</div>
<div class="paragraph">
<p>By default, the <code>JUnit4</code> runner is used to execute the tests in one environment, but you can use <code>@DelegateRunWith</code> to use another runner.</p>
</div>
</div>
<div class="sect3">
<h4 id="_junit_5_5"><a class="anchor" href="#_junit_5_5"></a>JUnit 5</h4>
<div class="paragraph">
<p>The multi-environment configuration with JUnit 5 is similar to JUnit 4:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Environment(EnvironmentsExtensionTest.E1.class)
@Environment(EnvironmentsExtensionTest.E2.class)
class TheTest {

    @EnvironmentalTest
    void test1() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main differences are that no runner is used because they do not exist in JUnit 5, and that you need to replace <code>@Test</code> by <code>@EnvironmentalTest</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
With JUnit5, tests are executed one after another for all environments, while tests are ran sequentially in each environments with JUnit 4. For example, this means that <code>@BeforeAll</code> and <code>@AfterAll</code> are executed once for all runners.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_provided_environments"><a class="anchor" href="#_provided_environments"></a>Provided environments</h4>
<div class="paragraph">
<p>The provided environment sets the contextual classloader in order to load the related runner of Apache Beam.</p>
</div>
<div class="paragraph">
<p>Package: <code>org.talend.sdk.component.junit.environment.builtin.beam</code></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the configuration is read from system properties, environment variables, &#8230;&#8203;.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Contextual</dt>
<dd>
<p><em>_class: ContextualEnvironment</em>.</p>
</dd>
<dt class="hdlist1">Direct</dt>
<dd>
<p><em>_class: DirectRunnerEnvironment</em>.</p>
</dd>
<dt class="hdlist1">Flink</dt>
<dd>
<p><em>_class: FlinkRunnerEnvironment</em>.</p>
</dd>
<dt class="hdlist1">Spark</dt>
<dd>
<p><em>_class: SparkRunnerEnvironment</em>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_environments"><a class="anchor" href="#_configuring_environments"></a>Configuring environments</h4>
<div class="paragraph">
<p>If the environment extends <code>BaseEnvironmentProvider</code> and therefore defines an environment name - which is the case of the default ones - you can use <code>EnvironmentConfiguration</code> to customize the system properties used for that environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Environment(DirectRunnerEnvironment.class)
@EnvironmentConfiguration(
    environment = "Direct",
    systemProperties = @EnvironmentConfiguration.Property(key = "beamTestPipelineOptions", value = "..."))

@Environment(SparkRunnerEnvironment.class)
@EnvironmentConfiguration(
    environment = "Spark",
    systemProperties = @EnvironmentConfiguration.Property(key = "beamTestPipelineOptions", value = "..."))

@Environment(FlinkRunnerEnvironment.class)
@EnvironmentConfiguration(
    environment = "Flink",
    systemProperties = @EnvironmentConfiguration.Property(key = "beamTestPipelineOptions", value = "..."))
class MyBeamTest {

    @EnvironmentalTest
    void execute() {
        // run some pipeline
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you set the <code>&lt;environment name&gt;.skip</code> system property to <code>true</code>, the environment-related executions are skipped.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_advanced_usage"><a class="anchor" href="#_advanced_usage"></a>Advanced usage</h5>
<div class="paragraph">
<p>This usage assumes that Beam 2.4.0 or later is used.</p>
</div>
<div class="paragraph">
<p>The following dependencies bring the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit into the test scope.</p>
</div>
<div class="paragraph">
<p>Dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
    &lt;artifactId&gt;component-runtime-junit&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.jboss.shrinkwrap.resolver&lt;/groupId&gt;
    &lt;artifactId&gt;shrinkwrap-resolver-impl-maven&lt;/artifactId&gt;
    &lt;version&gt;3.1.3&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
    &lt;artifactId&gt;component-runtime-beam&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the fluent DSL to define jobs, you can write a test as follows:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Your job must be linear and each step must send a single value (no multi-input or multi-output).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Environment(ContextualEnvironment.class)
@Environment(DirectRunnerEnvironment.class)
class TheComponentTest {
    @EnvironmentalTest
    void testWithStandaloneAndBeamEnvironments() {
        from("myfamily://in?config=xxxx")
            .to("myfamily://out")
            .create()
            .execute();
        // add asserts on the output if needed
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It executes the chain twice:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>With a standalone environment to simulate the Studio.</p>
</li>
<li>
<p>With a Beam (direct runner) environment to ensure the portability of your job.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_22"><a class="anchor" href="#_related_articles_22"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Testing component runtime</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_secretspasswords_and_maven"><a class="anchor" href="#_secretspasswords_and_maven"></a>Secrets/Passwords and Maven</h3>
<div class="paragraph">
<p>You can reuse Maven <code>settings.xml</code> server files, including the encrypted ones.
<code>org.talend.sdk.component.maven.MavenDecrypter</code> allows yo to find a <code>username</code>/<code>password</code> from
a server identifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final MavenDecrypter decrypter = new MavenDecrypter();
final Server decrypted = decrypter.find("my-test-server");
// decrypted.getUsername();
// decrypted.getPassword();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is very useful to avoid storing secrets and to perform tests on real systems on a continuous integration platform.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Even if you do not use Maven on the platform, you can generate the <code>settings.xml</code> and`settings-security.xml` files to use that feature. See <a href="https://maven.apache.org/guides/mini/guide-encryption.html" class="bare">maven.apache.org/guides/mini/guide-encryption.html</a> for more details.
</td>
</tr>
</table>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_23"><a class="anchor" href="#_related_articles_23"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Testing component runtime</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_generating_data"><a class="anchor" href="#_generating_data"></a>Generating data</h3>
<div class="paragraph">
<p>Several data generators exist if you want to populate objects with a semantic that is more evolved than a plain random string like <code>commons-lang3</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/Codearte/jfairy" class="bare">github.com/Codearte/jfairy</a></p>
</li>
<li>
<p><a href="https://github.com/DiUS/java-faker" class="bare">github.com/DiUS/java-faker</a></p>
</li>
<li>
<p><a href="https://github.com/andygibson/datafactory" class="bare">github.com/andygibson/datafactory</a></p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Even more advanced, the following generators allow to directly bind generic data on a model. However, data quality is not always optimal:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/devopsfolks/podam" class="bare">github.com/devopsfolks/podam</a></p>
</li>
<li>
<p><a href="https://github.com/benas/random-beans" class="bare">github.com/benas/random-beans</a></p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are two main kinds of implementation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implementations using a <em>pattern</em> and random generated data.</p>
</li>
<li>
<p>Implementations using a set of precomputed data extrapolated to create new values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Check your use case to know which one fits best.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An alternative to data generation can be to import <em>real</em> data and use Talend Studio to sanitize the data, by removing sensitive information and replacing it with generated or anonymized data. Then you just need to inject that file into the system.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are using JUnit 5, you can have a look at <a href="https://glytching.github.io/junit-extensions/randomBeans" class="bare">glytching.github.io/junit-extensions/randomBeans</a>.</p>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_24"><a class="anchor" href="#_related_articles_24"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Testing component runtime</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="services-pipeline.html" class="page">Simple/Test Pipeline API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_job_pipeline"><a class="anchor" href="#_creating_a_job_pipeline"></a>Creating a job pipeline</h3>
<div class="sect3">
<h4 id="_job_builder"><a class="anchor" href="#_job_builder"></a>Job Builder</h4>
<div class="paragraph">
<p>The <strong>Job builder</strong> lets you create a job pipeline programmatically using Talend components
(<a href="component-define-processor-output.html" class="page">Producers and Processors</a>).
The job pipeline is an acyclic graph, allowing you to build complex pipelines.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s take a simple use case where two data sources (employee and salary) are formatted to CSV and the result is written to a file.</p>
</div>
<div class="paragraph">
<p>A job is defined based on components (nodes) and links (edges) to connect their branches together.</p>
</div>
<div class="paragraph">
<p>Every component is defined by a unique <code>id</code> and an URI that identify the component.</p>
</div>
<div class="paragraph">
<p>The URI follows the form <code>[family]://[component][?version][&amp;configuration]</code>, where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>family</strong> is the name of the component family.</p>
</li>
<li>
<p><strong>component</strong> is the name of the component.</p>
</li>
<li>
<p><strong>version</strong> is the version of the component. It is represented in a <em>key=value</em> format. The key is <code>__version</code> and the value is a number.</p>
</li>
<li>
<p><strong>configuration</strong> is component configuration. It is represented in a <em>key=value</em> format. The key is the path of the configuration and the value is a `string' corresponding to the configuration value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>URI example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>job://csvFileGen?__version=1&amp;path=/temp/result.csv&amp;encoding=utf-8"</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
configuration parameters must be URI/URL encoded.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Job example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Job.components()   <i class="conum" data-value="1"></i><b>(1)</b>
        .component("employee","db://input")
        .component("salary", "db://input")
        .component("concat", "transform://concat?separator=;")
        .component("csv", "file://out?__version=2")
    .connections()  <i class="conum" data-value="2"></i><b>(2)</b>
        .from("employee").to("concat", "string1")
        .from("salary").to("concat", "string2")
        .from("concat").to("csv")
    .build()    <i class="conum" data-value="3"></i><b>(3)</b>
    .run(); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defining all components used in the job pipeline.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defining the connections between the components to construct the job pipeline. The links <code>from</code>/<code>to</code> use the component id and the default input/output branches.<br>
You can also connect a specific branch of a component, if it has multiple or named input/output branches, using the methods <code>from(id, branchName)</code> and <code>to(id, branchName)</code>.<br>
In the example above, the <em>concat</em> component has two inputs ("string1" and "string2").</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Validating the job pipeline by asserting that:
<div class="ulist">
<ul>
<li>
<p>It has some starting components (components that don&#8217;t have a <code>from</code> connection and that need to be of the <strong>producer</strong> type).</p>
</li>
<li>
<p>There are no cyclic connections. The job pipeline needs to be an acyclic graph.</p>
</li>
<li>
<p>All components used in the connections are already declared.</p>
</li>
<li>
<p>Each connection is used only once. You cannot connect a component input/output branch twice.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Running the job pipeline.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In this version, the execution of the job is linear. Components are not executed in parallel even if some steps may be independents.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_environmentrunner"><a class="anchor" href="#_environmentrunner"></a>Environment/Runner</h5>
<div class="paragraph">
<p>Depending on the configuration, you can select the environment which you execute your job in.</p>
</div>
<div class="paragraph">
<p>To select the environment, the logic is the following one:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If an <code>org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder</code> class is passed through the job properties, then use it. The supported types are an <code>ExecutionBuilder</code> instance, a <code>Class</code> or a <code>String</code>.</p>
</li>
<li>
<p>If an <code>ExecutionBuilder</code> SPI is present, use it. It is the case if <code>component-runtime-beam</code> is present in your classpath.</p>
</li>
<li>
<p>Else, use a local/standalone execution.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the case of a Beam execution, you can customize the pipeline options using system properties. They have to be prefixed with <code>talend.beam.job.</code>. For example, to set the <code>appName</code> option, you need to use <code>-Dtalend.beam.job.appName=mytest</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_key_provider"><a class="anchor" href="#_key_provider"></a>Key Provider</h5>
<div class="paragraph">
<p>The job builder lets you set a key provider to join your data when a component has multiple inputs.
The key provider can be set contextually to a component or globally to the job.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Job.components()
        .component("employee","db://input")
            .property(GroupKeyProvider.class.getName(),
                 (GroupKeyProvider) context -&gt; context.getData().getString("id")) <i class="conum" data-value="1"></i><b>(1)</b>
        .component("salary", "db://input")
        .component("concat", "transform://concat?separator=;")
    .connections()
        .from("employee").to("concat", "string1")
        .from("salary").to("concat", "string2")
    .build()
    .property(GroupKeyProvider.class.getName(), <i class="conum" data-value="2"></i><b>(2)</b>
                 (GroupKeyProvider) context -&gt; context.getData().getString("employee_id"))
    .run();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defining a key provider for the data produced by the <code>employee</code> component.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defining a key provider for all data manipulated in the job.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the incoming data has different IDs, you can provide a complex global key provider that relies on the context given by the component <code>id</code> and the branch <code>name</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">GroupKeyProvider keyProvider = context -&gt; {
    if ("employee".equals(context.getComponentId())) {
        return context.getData().getString("id");
    }
    return context.getData().getString("employee_id");
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_beam_case"><a class="anchor" href="#_beam_case"></a>Beam case</h4>
<div class="paragraph">
<p>For <a href="https://beam.apache.org/">Beam</a> case, you need to rely on Beam pipeline definition and use the <code>component-runtime-beam</code> dependency, which provides Beam bridges.</p>
</div>
<div class="sect4">
<h5 id="_inputs_and_outputs"><a class="anchor" href="#_inputs_and_outputs"></a>Inputs and Outputs</h5>
<div class="paragraph">
<p><code>org.talend.sdk.component.runtime.beam.TalendIO</code> provides a way to convert a partition mapper or a processor to an input or processor using the <code>read</code> or <code>write</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Main {
    public static void main(final String[] args) {
        final ComponentManager manager = ComponentManager.instance()
        Pipeline pipeline = Pipeline.create();
        //Create beam input from mapper and apply input to pipeline
        pipeline.apply(TalendIO.read(manager.findMapper(manager.findMapper("sample", "reader", 1, new HashMap&lt;String, String&gt;() {{
                    put("fileprefix", "input");
                }}).get()))
                .apply(new ViewsMappingTransform(emptyMap(), "sample")) // prepare it for the output record format (see next part)
        //Create beam processor from talend processor and apply to pipeline
                .apply(TalendIO.write(manager.findProcessor("test", "writer", 1, new HashMap&lt;String, String&gt;() {{
                    put("fileprefix", "output");
                }}).get(), emptyMap()));

        //... run pipeline
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_processors"><a class="anchor" href="#_processors"></a>Processors</h5>
<div class="paragraph">
<p><code>org.talend.sdk.component.runtime.beam.TalendFn</code> provides the way to wrap a processor in a Beam <code>PTransform</code> and to integrate it into the pipeline.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Main {
    public static void main(final String[] args) {
        //Component manager and pipeline initialization...

        //Create beam PTransform from processor and apply input to pipeline
        pipeline.apply(TalendFn.asFn(manager.findProcessor("sample", "mapper", 1, emptyMap())).get())), emptyMap());

        //... run pipeline
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The multiple inputs and outputs are represented by a <code>Map</code> element in Beam case to avoid using multiple inputs and outputs.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can use <code>ViewsMappingTransform</code> or <code>CoGroupByKeyResultMappingTransform</code> to adapt the input/output format to the record format representing the multiple inputs/output, like <code>Map&lt;String, List&lt;?&gt;&gt;</code>, but materialized as a <code>Record</code>. Input data must be of the <code>Record</code> type in this case.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_converting_a_beam_io_into_a_component_io"><a class="anchor" href="#_converting_a_beam_io_into_a_component_io"></a>Converting a Beam.io into a component I/O</h5>
<div class="paragraph">
<p>For simple inputs and outputs, you can get an automatic and transparent conversion of the Beam.io into an I/O component, if you decorated your <code>PTransform</code> with <code>@PartitionMapper</code> or <code>@Processor</code>.</p>
</div>
<div class="paragraph">
<p>However, there are limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inputs must implement <code>PTransform&lt;PBegin, PCollection&lt;?&gt;&gt;</code> and must be a <code>BoundedSource</code>.</p>
</li>
<li>
<p>Outputs must implement <code>PTransform&lt;PCollection&lt;?&gt;, PDone&gt;</code> and register a <code>DoFn</code> on the input <code>PCollection</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more information, see the <a href="wrapping-a-beam-io.html" class="page">How to wrap a Beam I/O</a> page.</p>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_25"><a class="anchor" href="#_related_articles_25"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="testing-best-practices.html" class="page">Component testing best practices</a></p>
</li>
<li>
<p><a href="index-sub-testing-runtime.html" class="page">Testing component runtime</a></p>
</li>
<li>
<p><a href="testing-beam.html" class="page">Beam testing</a></p>
</li>
<li>
<p><a href="testing-multiple-envs.html" class="page">Testing in multiple environments</a></p>
</li>
<li>
<p><a href="testing-maven-passwords.html" class="page">Reusing Maven credentials</a></p>
</li>
<li>
<p><a href="testing-generating-data.html" class="page">Generating data for testing</a></p>
</li>
<li>
<p><a href="wrapping-a-beam-io.html" class="page">Wrapping a Beam I/O</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_defining_services"><a class="anchor" href="#_defining_services"></a>Defining services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Services are configurations that can be reused across several classes.
Talend Component Kit comes with a predefined set of services that you can easily use.</p>
</div>
<div class="paragraph">
<p>You can still define your own services under the <strong>service</strong> node of your component project. By default, the Component Kit Starter generates a dedicated class in your project in which you can implement services.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="services-built-in.html" class="page">Built-in services</a></p>
</li>
<li>
<p><a href="services-internationalization.html" class="page">Internationalizing a service</a></p>
</li>
<li>
<p><a href="services-actions.html" class="page">Providing actions through a service</a></p>
</li>
<li>
<p><a href="services-interceptors.html" class="page">Services and interceptors</a></p>
</li>
<li>
<p><a href="services-custom-api.html" class="page">Defining a custom API</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_built_in_services"><a class="anchor" href="#_built_in_services"></a>Built-in services</h3>
<div class="paragraph">
<p>The framework provides built-in services that you can inject by type in components and actions.</p>
</div>
<div class="sect3">
<h4 id="_lisf_of_built_in_services"><a class="anchor" href="#_lisf_of_built_in_services"></a>Lisf of built-in services</h4>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.cache.LocalCache</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides a small abstraction to cache data that does not need to be recomputed very often. Commonly used by actions for UI interactions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.dependency.Resolver</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allows to resolve a dependency from its Maven coordinates. It can either try to resolve a local file or (better) creates for you a preinitialized classloader.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.bind.Jsonb</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-B instance. If your model is static and you don&#8217;t want to handle the serialization manually using JSON-P, you can inject that instance.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.spi.JsonProvider</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-P instance. Prefer other JSON-P instances if you don&#8217;t exactly know why you use this one.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.JsonBuilderFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.JsonWriterFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.JsonReaderFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.stream.JsonParserFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>javax.json.stream.JsonGeneratorFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.dependency.Resolver</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allows to resolve files from Maven coordinates (like <code>dependencies.txt</code> for component). Note that it assumes that the files are available in the component Maven repository.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.injector.Injector</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Utility to inject services in fields marked with <code>@Service</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.factory.ObjectFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allows to instantiate an object from its class name and properties.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.record.RecordBuilderFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allows to instantiate a <a href="record-types.html#record" class="page">record</a>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.record.RecordPointerFactory</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Allows to instantiate a <code>RecordPointer</code> which enables to extract a data from a <code>Record</code> based on <a href="https://tools.ietf.org/html/rfc6901">jsonpointer</a> specification.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.record.RecordService</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Some utilities to create records from another one. It is typically what is used when you want to add an entry in a record and passthrough the other ones. It also provides a nice <code>RecordVisitor</code> API for advanced cases.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.talend.sdk.component.api.service.configuration.LocalConfiguration</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Represents the local configuration that can be used during the design.</p>
</div>
<div class="paragraph">
<p>It is not recommended to use it for the runtime because the local configuration is usually different and the instances are distinct.</p>
</div>
<div class="paragraph">
<p>You can also use the local cache as an interceptor with <code>@Cached</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Every interface that extends <code>HttpClient</code> and that contains methods annotated with <code>@Request</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Lets you define an HTTP client in a declarative manner using an annotated interface.</p>
</div>
<div class="paragraph">
<p>See the <a href="#httpclient_usage">Using HttpClient</a> for more details.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All these <strong>injected</strong> services are serializable, which is important for big data environments. If you create the instances yourself, you cannot benefit from these features, nor from the memory optimization done by the runtime. Prefer reusing the framework instances over custom ones.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_localconfiguration"><a class="anchor" href="#_localconfiguration"></a>LocalConfiguration</h5>
<div class="paragraph">
<p>The local configuration uses system properties and the environment (replacing dots per underscores) to look up the values.
You can also put a <code>TALEND-INF/local-configuration.properties</code> file with default values. This allows to use the <code>local_configuration:&lt;key&gt;</code>
syntax in <code>@Ui</code> annotation. Here is an example to read the default value of a property from the configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@DefaultValue("local_configuration:myfamily.model.key")
private String value;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Ensure your key is unique across all components to avoid global overrides on the JVM. In practice, it is strongly recommended to always use the family as a prefix.<br>
Also note that you can use <code>@Configuration("prefix")</code> to inject a mapping of the <code>LocalConfiguration</code> in a component. It uses the same rules as for any configuration object.
If you prefer to inject you configuration in a service, ensure to wrap it in a <code>Supplier</code> to always have
an up to date version.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to ignore the <code>local-configuration.properties</code>, you can set the system property: <code>talend.component.configuration.${componentPluginId}.ignoreLocalConfiguration=true</code>.</p>
</div>
<div class="paragraph">
<p>Here a sample <code>@Configuration</code> model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data // from lombok, optional
public class MyConfig {
  @Option
  private String defaultUrl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how to use it from a service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class ConfiguredService {
  @Configuration("myprefix")
  private Supplier&lt;MyConfig&gt; config;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally, here is how to use it in a component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class ConfiguredComponent {
  public ConfiguredComponent(@Configuration("myprefix") final MyConfig config) {
    // ...
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
it is recommended to convert this configuration in a runtime model in components
to avoid to transport more than desired during the job distribution.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="httpclient_usage"><a class="anchor" href="#httpclient_usage"></a>Using HttpClient</h4>
<div class="paragraph">
<p>You can access the API reference in the <a href="https://talend.github.io/component-runtime/apidocs/1.1.28/api/org/talend/sdk/component/api/service/http/package-summary.html">Javadocs</a>.</p>
</div>
<div class="paragraph">
<p>The HttpClient usage is described in this section by using the REST API example below. Assuming that it requires a basic authentication header:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET     <code>/api/records/{id}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST    <code>/api/records</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON payload to be created: <code>{"id":"some id", "data":"some data"}</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To create an HTTP client that is able to consume the REST API above, you need to define an interface that extends <code>HttpClient</code>.</p>
</div>
<div class="paragraph">
<p>The <code>HttpClient</code> interface lets you set the <code>base</code> for the HTTP address that the client will hit.</p>
</div>
<div class="paragraph">
<p>The <code>base</code> is the part of the address that needs to be added to the request path to hit the API.</p>
</div>
<div class="paragraph">
<p>Every method annotated with <code>@Request</code> in the interface defines an HTTP request.
Every request can have a <code>@Codec</code> parameter that allows to encode or decode the request/response payloads.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can ignore the encoding/decoding for <code>String</code> and <code>Void</code> payloads.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface APIClient extends HttpClient {
    @Request(path = "api/records/{id}", method = "GET")
    @Codec(decoder = RecordDecoder.class) //decoder =  decode returned data to Record class
    Record getRecord(@Header("Authorization") String basicAuth, @Path("id") int id);

    @Request(path = "api/records", method = "POST")
    @Codec(encoder = RecordEncoder.class, decoder = RecordDecoder.class) //encoder = encode record to fit request format (json in this example)
    Record createRecord(@Header("Authorization") String basicAuth, Record record);
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The interface should extend <code>HttpClient</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the codec classes (that implement Encoder/Decoder), you can inject any of your service annotated with <code>@Service</code> or <code>@Internationalized</code> into the constructor.
Internationalization services can be useful to have internationalized messages for errors handling.</p>
</div>
<div class="paragraph">
<p>The interface can be injected into component classes or services to consume the defined API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyService {

    private APIClient client;

    public MyService(...,APIClient client){
        //...
        this.client = client;
        client.base("http://localhost:8080");// init the base of the api, often in a PostConstruct or init method
    }

    //...
    // Our get request
    Record rec =  client.getRecord("Basic MLFKG?VKFJ", 100);

    //...
    // Our post request
    Record newRecord = client.createRecord("Basic MLFKG?VKFJ", new Record());
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, <code><strong>/</strong>+json</code> are mapped to JSON-P and <code><strong>/</strong>+xml</code> to JAX-B if the model has a <code>@XmlRootElement</code> annotation.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_customizing_http_client_requests"><a class="anchor" href="#_customizing_http_client_requests"></a>Customizing HTTP client requests</h5>
<div class="paragraph">
<p>For advanced cases, you can customize the <code>Connection</code> by directly using <code>@UseConfigurer</code> on the method. It calls your custom instance of <code>Configurer</code>. Note that you can use <code>@ConfigurerOption</code> in the method signature to pass some <code>Configurer</code> configurations.</p>
</div>
<div class="paragraph">
<p>For example, if you have the following <code>Configurer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class BasicConfigurer implements Configurer {
    @Override
    public void configure(final Connection connection, final ConfigurerConfiguration configuration) {
        final String user = configuration.get("username", String.class);
        final String pwd = configuration.get("password", String.class);
        connection.withHeader(
            "Authorization",
            Base64.getEncoder().encodeToString((user + ':' + pwd).getBytes(StandardCharsets.UTF_8)));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then set it on a method to automatically add the basic header with this kind of API usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface APIClient extends HttpClient {
    @Request(path = "...")
    @UseConfigurer(BasicConfigurer.class)
    Record findRecord(@ConfigurerOption("username") String user, @ConfigurerOption("password") String pwd);
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_built_in_configurer"><a class="anchor" href="#_built_in_configurer"></a>Built-In configurer</h6>
<div class="paragraph">
<p>The framework provides in the <code>component-api</code> an <code>OAuth1.Configurer</code> which can be used as an example
of configurer implementation. It expects a single <code>OAuth1.Configuration</code> parameter to be passed
to the request as a <code>@ConfigurationOption</code>.</p>
</div>
<div class="paragraph">
<p>Here is a sample showing how it can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface OAuth1Client extends HttpClient {
    @Request(path = "/oauth1")
    @UseConfigurer(OAuth1.Configurer.class)
    String get(@ConfigurerOption("oauth1") final OAuth1.Configuration configuration);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_big_data_streams"><a class="anchor" href="#_big_data_streams"></a>Big data streams</h5>
<div class="paragraph">
<p>By default, the client loads in memory the payload. In case of big payloads, it can consume too much memory.
For these cases, you can get the payload as an <code>InputStream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface APIClient extends HttpClient {
    @Request(path = "/big/http/data")
    InputStream getData();
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can use the <code>Response</code> wrapper, or not.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_26"><a class="anchor" href="#_related_articles_26"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="services-internationalization.html" class="page">Internationalizing a service</a></p>
</li>
<li>
<p><a href="services-actions.html" class="page">Providing actions through a service</a></p>
</li>
<li>
<p><a href="services-interceptors.html" class="page">Services and interceptors</a></p>
</li>
<li>
<p><a href="services-custom-api.html" class="page">Defining a custom API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_internationalizing_services"><a class="anchor" href="#_internationalizing_services"></a>Internationalizing services</h3>
<div class="paragraph">
<p>Internationalization requires following several best practices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Storing messages using <code>ResourceBundle</code> properties file in your component module.</p>
</li>
<li>
<p>The location of the properties is in the same package than the related components and is named <code>Messages</code>. For example, <code>org.talend.demo.MyComponent</code> uses <code>org.talend.demo.Messages[locale].properties</code>.</p>
</li>
<li>
<p>Use the internationalization API for your own messages.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_internationalization_api"><a class="anchor" href="#_internationalization_api"></a>Internationalization API</h4>
<div class="paragraph">
<p>The Internationalization API is the mechanism to use to internationalize your own messages in your own components.</p>
</div>
<div class="paragraph">
<p>The principle of the API is to design messages as methods returning <code>String</code> values and get back a template using a <code>ResourceBundle</code> named <code>Messages</code> and located in the same package than the interface that defines these methods.</p>
</div>
<div class="paragraph">
<p>To ensure your internationalization API is identified, you need to mark it with the <code>@Internationalized</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.superbiz;

@Internationalized <i class="conum" data-value="1"></i><b>(1)</b>
public interface Translator {

    String message();

    String templatizedMessage(String arg0, int arg1); <i class="conum" data-value="2"></i><b>(2)</b>

    String localized(String arg0, @Language Locale locale); <i class="conum" data-value="3"></i><b>(3)</b>

    String localized(String arg0, @Language String locale); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@Internationalized</code> allows to mark a class as an internationalized service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You can pass parameters. The message uses the <code>MessageFormat</code> syntax to be resolved, based on the <code>ResourceBundle</code> template.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>You can use <code>@Language</code> on a <code>Locale</code> parameter to specify manually the locale to use. Note that a single value is used (the first parameter tagged as such).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>@Language</code> also supports the <code>String</code> type.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The corresponding <code>Messages.properties</code> placed in the <code>org/superbiz</code> resource folder contains the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">org.superbiz.Translator.message = Some message
org.superbiz.Translator.templatizedMessage = Some message with string {0} and with number {1}
org.superbiz.Translator.localized = Some other message with string {0}

# or the short version

Translator.message = Some message
Translator.templatizedMessage = Some message with string {0} and with number {1}
Translator.localized = Some other message with string {0}</code></pre>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_27"><a class="anchor" href="#_related_articles_27"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="services-actions.html" class="page">Providing actions through a service</a></p>
</li>
<li>
<p><a href="services-built-in.html" class="page">Built-in services</a></p>
</li>
<li>
<p><a href="services-interceptors.html" class="page">Services and interceptors</a></p>
</li>
<li>
<p><a href="services-custom-api.html" class="page">Defining a custom API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_providing_actions_for_consumers"><a class="anchor" href="#_providing_actions_for_consumers"></a>Providing actions for consumers</h3>
<div class="paragraph">
<p>In some cases you can need to add some actions that are not related to the runtime. For example,
enabling users of the plugin/library to test if a connection works properly.</p>
</div>
<div class="paragraph">
<p>To do so, you need to define an <code>@Action</code>, which is a method with a name (representing the event name), in a class decorated with <code>@Service</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Service
public class MyDbTester {
    @Action(family = "mycomp", "test")
    public Status doTest(final IncomingData data) {
        return ...;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Services are singleton. If you need some thread safety, make sure that they match that requirement. Services should not store any status either because they can be serialized at any time. Status are held by the component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Services can be used in components as well (matched by type). They allow to reuse some shared logic, like a client. Here is a sample with a service used to access files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Emitter(family = "sample", name = "reader")
public class PersonReader implements Serializable {
    // attributes skipped to be concise

    public PersonReader(@Option("file") final File file,
                        final FileService service) {
        this.file = file;
        this.service = service;
    }

    // use the service
    @PostConstruct
    public void open() throws FileNotFoundException {
        reader = service.createInput(file);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The service is automatically passed to the constructor. It can be used as a bean. In that case, it is only necessary to call the service method.</p>
</div>
<div class="sect3">
<h4 id="_particular_action_types"><a class="anchor" href="#_particular_action_types"></a>Particular action types</h4>
<div class="paragraph">
<p>Some common actions need a clear contract so they are defined as API first-class citizen. For example, this is the case for wizards or health checks. Here is the list of the available actions:</p>
</div>
<div class="sect4">
<h5 id="_dynamic_values"><a class="anchor" href="#_dynamic_values"></a>Dynamic Values</h5>
<div class="paragraph">
<p>Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn&#8217;t take any parameter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>dynamic_values</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.completion.DynamicValues</code></p>
</li>
<li>
<p>Returned type: <code>org.talend.sdk.component.api.service.completion.Values</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "items":[
    {
      "id":"value",
      "label":"label"
    }
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_healthcheck"><a class="anchor" href="#_healthcheck"></a>Healthcheck</h5>
<div class="paragraph">
<p>This class marks an action doing a connection test</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>healthcheck</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.healthcheck.HealthCheck</code></p>
</li>
<li>
<p>Returned type: <code>org.talend.sdk.component.api.service.healthcheck.HealthCheckStatus</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "comment":"Something went wrong",
  "status":"KO"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_schema"><a class="anchor" href="#_schema"></a>Schema</h5>
<div class="paragraph">
<p>Mark an action as returning a discovered schema. Its parameter MUST be a dataset. Dataset is configuration type annotated with @DataSet. If component has multiple datasets, then dataset used as action parameter should have the same identifier as this @DiscoverSchema.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>schema</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.schema.DiscoverSchema</code></p>
</li>
<li>
<p>Returned type: <code>org.talend.sdk.component.api.record.Schema</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "entries":[
    {
      "comment":"The column 1",
      "name":"column1",
      "nullable":false,
      "rawName":"column 1",
      "type":"STRING"
    },
    {
      "comment":"The int column",
      "name":"column2",
      "nullable":false,
      "rawName":"column 2",
      "type":"INT"
    }
  ],
  "type":"RECORD"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_suggestions"><a class="anchor" href="#_suggestions"></a>Suggestions</h5>
<div class="paragraph">
<p>Mark a method as being useful to fill potential values of a string option. You can link a field as being completable using @Suggestable(value). The resolution of the completion action is then done when the user requests it (generally by clicking on a button or entering the field depending the environment).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>suggestions</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.completion.Suggestions</code></p>
</li>
<li>
<p>Returned type: <code>org.talend.sdk.component.api.service.completion.SuggestionValues</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "cacheable":false,
  "items":[
    {
      "id":"value",
      "label":"label"
    }
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_update"><a class="anchor" href="#_update"></a>Update</h5>
<div class="paragraph">
<p>This class marks an action returning a new instance replacing part of a form/configuration.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>update</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.update.Update</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_user"><a class="anchor" href="#_user"></a>User</h5>
<div class="paragraph">
<p>Extension point for custom UI integrations and custom actions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>user</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.Action</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_validation"><a class="anchor" href="#_validation"></a>Validation</h5>
<div class="paragraph">
<p>Mark a method as being used to validate a configuration.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
this is a server validation so only use it if you can&#8217;t use other client side validation to implement it.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Type: <code>validation</code></p>
</li>
<li>
<p>API: <code>@org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation</code></p>
</li>
<li>
<p>Returned type: <code>org.talend.sdk.component.api.service.asyncvalidation.ValidationResult</code></p>
</li>
<li>
<p>Sample:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-js hljs" data-lang="js">{
  "comment":"Something went wrong",
  "status":"KO"
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_built_in_actions"><a class="anchor" href="#_built_in_actions"></a>Built In Actions</h6>
<div class="paragraph">
<p>These actions are provided - or not - by the application the UI runs within.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
always ensure you don&#8217;t require this action in your component.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_built_in_suggestable"><a class="anchor" href="#_built_in_suggestable"></a>built_in_suggestable</h5>
<div class="paragraph">
<p>Mark the decorated field as supporting suggestions, i.e. dynamically get a list of valid values the user can use. It is however different from <code>@Suggestable</code> by looking up the implementation in the current application and not the services. Finally, it is important to note that it can do nothing in some environments too and that there is no guarantee the specified action is supported.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API: <code>@org.talend.sdk.component.api.configuration.action.BuiltInSuggestable</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_internationalization"><a class="anchor" href="#_internationalization"></a>Internationalization</h4>
<div class="paragraph">
<p>Internationalization is supported through the injection of the <code>$lang</code> parameter, which allows you to get the correct locale to use with an <code>@Internationalized</code> service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>public SuggestionValues findSuggestions(@Option("someParameter") final String param,
                                        @Option("$lang") final String lang) {
    return ...;
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can combine the <code>$lang</code> option with the <code>@Internationalized</code> and <code>@Language</code> parameters.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_28"><a class="anchor" href="#_related_articles_28"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="services-internationalization.html" class="page">Internationalizing a service</a></p>
</li>
<li>
<p><a href="services-built-in.html" class="page">Built-in services</a></p>
</li>
<li>
<p><a href="services-interceptors.html" class="page">Services and interceptors</a></p>
</li>
<li>
<p><a href="services-custom-api.html" class="page">Defining a custom API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_services_and_interceptors"><a class="anchor" href="#_services_and_interceptors"></a>Services and interceptors</h3>
<div class="paragraph">
<p>For common concerns such as caching, auditing, and so on, you can use an interceptor-like API. It is enabled on services by the framework.</p>
</div>
<div class="paragraph">
<p>An interceptor defines an annotation marked with <code>@Intercepts</code>, which defines the implementation of the interceptor (<code>InterceptorHandler</code>).</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Intercepts(LoggingHandler.class)
@Target({ TYPE, METHOD })
@Retention(RUNTIME)
public @interface Logged {
    String value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The handler is created from its constructor and can take service injections (by type). The first parameter, however, can be <code>BiFunction&lt;Method, Object[], Object&gt;</code>, which represents the invocation chain if your interceptor can be used with others.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you make a generic interceptor, pass the invoker as first parameter. Otherwise you cannot combine interceptors at all.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example of interceptor implementation for the <code>@Logged</code> API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class LoggingHandler implements InterceptorHandler {
    // injected
    private final BiFunction&lt;Method, Object[], Object&gt; invoker;
    private final SomeService service;

    // internal
    private final ConcurrentMap&lt;Method, String&gt; loggerNames = new ConcurrentHashMap&lt;&gt;();

    public CacheHandler(final BiFunction&lt;Method, Object[], Object&gt; invoker, final SomeService service) {
        this.invoker = invoker;
        this.service = service;
    }

    @Override
    public Object invoke(final Method method, final Object[] args) {
        final String name = loggerNames.computeIfAbsent(method, m -&gt; findAnnotation(m, Logged.class).get().value());
        service.getLogger(name).info("Invoking {}", method.getName());
        return invoker.apply(method, args);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This implementation is compatible with interceptor chains because it takes the invoker as first constructor parameter and it also takes a service injection. Then, the implementation simply does what is needed, which is logging the invoked method in this case.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>findAnnotation</code> annotation, inherited from <code>InterceptorHandler</code>, is an utility method to find an annotation on a method or class (in this order).
</td>
</tr>
</table>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_29"><a class="anchor" href="#_related_articles_29"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="services-internationalization.html" class="page">Internationalizing a service</a></p>
</li>
<li>
<p><a href="services-actions.html" class="page">Providing actions through a service</a></p>
</li>
<li>
<p><a href="services-built-in.html" class="page">Built-in services</a></p>
</li>
<li>
<p><a href="services-custom-api.html" class="page">Defining a custom API</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_a_custom_api"><a class="anchor" href="#_defining_a_custom_api"></a>Defining a custom API</h3>
<div class="paragraph">
<p>It is possible to extend the <a href="https://talend.github.io/component-runtime/apidocs/api/index.html">Component API</a> for custom front features.</p>
</div>
<div class="paragraph">
<p>What is important here is to keep in mind that you should do it only if it targets not portable components (only used by the Studio or Beam).</p>
</div>
<div class="paragraph">
<p>It is recommended to create a custom <code>xxxx-component-api</code> module with the new set of annotations.</p>
</div>
<div class="sect3">
<h4 id="_extending_the_ui"><a class="anchor" href="#_extending_the_ui"></a>Extending the UI</h4>
<div class="paragraph">
<p>To extend the UI, add an annotation that can be put on <code>@Option</code> fields, and that is decorated with <code>@Ui</code>.
All its members are then put in the metadata of the parameter. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Ui
@Target(TYPE)
@Retention(RUNTIME)
public @interface MyLayout {
}</code></pre>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_30"><a class="anchor" href="#_related_articles_30"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="services-internationalization.html" class="page">Internationalizing a service</a></p>
</li>
<li>
<p><a href="services-actions.html" class="page">Providing actions through a service</a></p>
</li>
<li>
<p><a href="services-built-in.html" class="page">Built-in services</a></p>
</li>
<li>
<p><a href="services-interceptors.html" class="page">Services and interceptors</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrating_components_into_talend_studio"><a class="anchor" href="#_integrating_components_into_talend_studio"></a>Integrating components into Talend Studio</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To be able to see and use your newly developed components, you need to integrate them to the right application.</p>
</div>
<div class="paragraph">
<p>Currently, you can deploy your components to Talend Studio as part of your development process to iterate on them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="studio.html" class="page">Iterating on component development with Talend Studio</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also share your components externally and install them using a component archive (.car) file.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="studio-from-car.html" class="page">Sharing and installing components in Talend Studio</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Check the versions of the framework that are compatible with your version of Talend Studio in <a href="compatibility.html" class="page">this document</a>.</p>
</div>
<div class="paragraph">
<p>If you were used to create custom components with the Javajet framework and want to get to know the new approach and main differences of the Component Kit framework, refer to <a href="javajet-to-componentkit.html" class="page">this document</a>.</p>
</div>
<div class="sect2">
<h3 id="_version_compatibility"><a class="anchor" href="#_version_compatibility"></a>Version compatibility</h3>
<div class="paragraph">
<p>You can integrate and start using components developed using Talend Component Kit in Talend applications very easily.</p>
</div>
<div class="paragraph">
<p>As both the development framework and Talend applications evolve over time, you need to ensure compatibility between the components you develop and the versions of Talend applications that you are targeting, by making sure that you use the right version of Talend Component Kit.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
<div class="sect3">
<h4 id="_compatibility_matrix"><a class="anchor" href="#_compatibility_matrix"></a>Compatibility matrix</h4>
<div class="paragraph">
<p>The version of Talend Component Kit you need to use to develop new components depends on the versions of the Talend applications in which these components will be integrated.</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><strong>Talend product</strong></th>
<th class="tableblock halign-left valign-top"><strong>Talend Component Kit version</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Talend Studio 7.3.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Framework until 1.1.15</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Talend Studio 7.2.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Framework until 1.1.10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Talend Studio 7.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Framework until 1.1.1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Talend Studio 7.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Framework until 0.0.5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Talend Cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Framework from 1.1.x</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>More recent versions of Talend Component Kit contain many fixes, improvements and features that help developing your components. However, they can cause some compatibility issues when deploying these components to older/different versions of Talend Studio and Talend Cloud. Choose the version of Talend Component Kit that best fits your needs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_changing_the_talend_component_kit_version_of_your_project"><a class="anchor" href="#_changing_the_talend_component_kit_version_of_your_project"></a>Changing the Talend Component Kit version of your project</h4>
<div class="paragraph">
<p>Creating a project using the Component Kit Starter always uses the latest release of Talend Component Kit.</p>
</div>
<div class="paragraph">
<p>However, you can manually change the version of Talend Component Kit directly in the generated project.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to your IDE and access the project root .pom file.</p>
</li>
<li>
<p>Look for the <code>org.talend.sdk.component</code> dependency nodes.</p>
</li>
<li>
<p>Replace the <strong>version</strong> in the relevant nodes with the version that you need to use for your project.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can use a Snapshot of the version under development using the <code>-SNAPSHOT</code> version and Sonatype snapshot <a href="https://oss.sonatype.org/content/repositories/snapshots/">repository</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_31"><a class="anchor" href="#_related_articles_31"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="studio.html" class="page">Integrating components into Talend Studio</a></p>
</li>
<li>
<p><a href="build-tools-maven.html" class="page">Building components with Maven</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iterating_on_component_development_with_talend_studio"><a class="anchor" href="#_iterating_on_component_development_with_talend_studio"></a>Iterating on component development with Talend Studio</h3>
<div class="paragraph">
<p>Integrate components you developed using Talend Component Kit to <a href="https://sourceforge.net/projects/talend-studio/">Talend Studio</a> in a few steps. Also learn how to enable the developer and debugging modes to iterate on your component development.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
<div class="sect3">
<h4 id="_version_compatibility_2"><a class="anchor" href="#_version_compatibility_2"></a>Version compatibility</h4>
<div class="paragraph">
<p>The version of Talend Component Kit you need to use to develop new components depends on the version of Talend Studio in which components will be integrated.</p>
</div>
<div class="paragraph">
<p>Refer to <a href="compatibility.html" class="page">this document</a> to learn about compatibility between Talend Component Kit and the different versions of Talend applications.</p>
</div>
</div>
<div class="sect3">
<h4 id="_installing_the_components"><a class="anchor" href="#_installing_the_components"></a>Installing the components</h4>
<div class="paragraph">
<p>Learn how to build and deploy components to Talend Studio using <a href="build-tools-maven.html" class="page">Maven</a> or <a href="build-tools-gradle.html" class="page">Gradle</a> Talend Component Kit plugins.</p>
</div>
<div class="paragraph">
<p>This can be done using the <code>deploy-in-studio</code> goal from your development environment.</p>
</div>
<div class="paragraph">
<p>If you are unfamiliar with component development, you can also follow <a href="tutorial-create-my-first-component.html" class="page">this example</a> to go through the entire process, from creating a project to using your new component in Talend Studio.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_the_component_server"><a class="anchor" href="#_configuring_the_component_server"></a>Configuring the component server</h4>
<div class="paragraph">
<p>The Studio integration relies on the Component Server, that the Studio uses to gather data about components created using Talend Component Kit.</p>
</div>
<div class="paragraph">
<p>You can change the default configuration of component server by modifying the <code>$STUDIO_HOME/configuration/config.ini</code> file.</p>
</div>
<div class="paragraph">
<p>The following parameters are available:</p>
</div>
<table class="tableblock frame-all grid-all stretch table-striped table-hover table-ordered">
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.environment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables the developer mode when set to <code>dev</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.debounce.timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the timeout (in milliseconds) before calling listeners in components Text fields</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">750</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.kit.skip</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to <code>true</code>, the plugin is not enabled. It is useful if you don&#8217;t have any component developed with the framework.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.java.arguments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Component server additional options</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.java.m2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maven repository that the server uses to resolve components</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defaults to the global Studio configuration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.java.coordinates</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A list of comma-separated GAV (groupId:artifactId:version) of components to register</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.java.registry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A properties file with values matching component GAV (groupId:artifactId:version) registered at startup. Only use slashes (even on windows) in the path.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.java.port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the port to use for the server</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">random</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">components.server.beam.active</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active, if set to true, Beam support (<em>Experimental</em>). It requires Beam SDK Java core dependencies to be available.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">component.server.jul.forceConsole</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Adds a console handler to JUL to see logs in the console. This can be helpful in development because the formatting is clearer than the OSGi one in <code>workspace/.metadata/.log</code>.</p>
</div>
<div class="paragraph">
<p>It uses the <code>java.util.logging.SimpleFormatter.format</code> property to define its format. By default, it
is <code>%1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n</code>, but for development purposes
<code>[%4$s] %5$s%6$s%n</code> is simpler and more readable.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Here is an example of a common developer <code>configuration/config.ini</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># use local .m2 instead of embedded studio one
maven.repository = global

# during development, see developer model part
component.environment = dev

# log into the console the component interactions - optional
component.server.jul.forceConsole = true
java.util.logging.SimpleFormatter.format = [%4$s] %5$s%6$s%n</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="developer-mode"><a class="anchor" href="#developer-mode"></a>Enabling the developer mode</h5>
<div class="paragraph">
<p>The developer mode is especially useful to iterate on your component development and to avoid closing and restarting Talend Studio every time you make a change to a component. It adds a Talend Component Kit button in the main toolbar:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/studio-reload-button.png" target="_blank" rel="noopener"><img src="_images/studio-reload-button.png" alt="Studio Reload Button"></a>
</div>
</div>
<div class="paragraph">
<p>When clicking this button, all components developed with the Talend Component Kit framework are reloaded. The cache is invalidated and the components refreshed.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You still need to add and remove the components to see the changes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable it, simply set the <code>component.environment</code> parameter to <code>dev</code> in the <code>config.ini</code> configuration file of the component server.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_debugging_your_custom_component_in_talend_studio"><a class="anchor" href="#_debugging_your_custom_component_in_talend_studio"></a>Debugging your custom component in Talend Studio</h4>
<div class="paragraph">
<p>Several methods allow you to debug custom components created with Talend Component Kit in Talend Studio.</p>
</div>
<div class="sect4">
<h5 id="_debugging_the_runtime_or_the_guess_schema_option_of_a_component"><a class="anchor" href="#_debugging_the_runtime_or_the_guess_schema_option_of_a_component"></a>Debugging the runtime or the Guess schema option of a component</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From your development tool, create a new <strong>Remote configuration</strong>, and copy the <strong>Command line arguments for running remote JVM</strong> field. For example, <code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p>the <strong>suspend</strong> parameter of the -agentlib argument specifies whether you want to suspend the debugged JVM until the debugger attaches to it. Possible values are <code>n</code> (no, default value) or <code>y</code> (yes).</p>
</li>
<li>
<p>the <strong>address</strong> parameter of the -agentlib argument is the port used for the remote configuration. Make sure this port is available.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/talend_studio_debug_remote_config_1.png" target="_blank" rel="noopener"><img src="_images/talend_studio_debug_remote_config_1.png" alt="IntelliJ remote configuration"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Open Talend Studio.</p>
</li>
<li>
<p>Create a new Job that uses the component you want to debug or open an existing one that already uses it.</p>
</li>
<li>
<p>Go to the <strong>Run</strong> tab of the Job and select <strong>Use specific JVM arguments</strong>.</p>
</li>
<li>
<p>Click <strong>New</strong> to add an argument.</p>
</li>
<li>
<p>In the popup window, paste the arguments copied from the IDE.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/talend_studio_debug_remote_config_2.png" target="_blank" rel="noopener"><img src="_images/talend_studio_debug_remote_config_2.png" alt="IntelliJ remote configuration"></a>
</div>
</div>
</li>
<li>
<p>Enter the corresponding debug mode:</p>
<div class="ulist">
<ul>
<li>
<p>To debug the runtime, run the Job and access the remote host configured in the IDE.</p>
</li>
<li>
<p>To debug the <strong>Guess schema</strong> option, click the <strong>Guess schema</strong> action button of the component and access the remote host configured in the IDE.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_debugging_ui_actions_and_validations"><a class="anchor" href="#_debugging_ui_actions_and_validations"></a>Debugging UI actions and validations</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From your development tool, create a new <strong>Remote configuration</strong>, and copy the <strong>Command line arguments for running remote JVM</strong> field. For example, <code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><strong>suspend</strong> defines whether you need to access the defined configuration to run the remote JVM. Possible values are <code>n</code> (no, default value) or <code>y</code> (yes).</p>
</li>
<li>
<p><strong>address</strong> is the port used for the remote configuration. Make sure this port is available.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/talend_studio_debug_remote_config_1.png" target="_blank" rel="noopener"><img src="_images/talend_studio_debug_remote_config_1.png" alt="IntelliJ remote configuration"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Access the installation directory of your Talend Sutdio.</p>
</li>
<li>
<p>Open the <code>.ini</code> file corresponding to your Operating System. For example, <code>TOS_DI-win-x86_64.ini</code>.</p>
</li>
<li>
<p>Paste the arguments copied from the IDE in a new line of the file.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/talend_studio_debug_remote_config_3.png" target="_blank" rel="noopener"><img src="_images/talend_studio_debug_remote_config_3.png" alt="IntelliJ remote configuration"></a>
</div>
</div>
</li>
<li>
<p>Go to Talend Studio to use the component, and access the host host configured in the IDE.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_random_port_when_running_concurrent_studio_instances"><a class="anchor" href="#_random_port_when_running_concurrent_studio_instances"></a>Random port when running concurrent studio instances</h4>
<div class="paragraph">
<p>If you run multiple Studio instances automatically in parallel, you can run into some issues with the random port computation. For example on a CI platform. For that purpose, you can create the  <code>$HOME/.talend/locks/org.talend.sdk.component.studio-integration.lock</code> file.</p>
</div>
<div class="paragraph">
<p>Then, when a server starts, it acquires a lock on that file and prevents another server to get a port until it is started. It ensures that you can&#8217;t have two concurrent processes getting the same port allocated.</p>
</div>
<div class="paragraph">
<p>However, it is highly unlikely to happen on a desktop. In that case, forcing a different value through <code>component.java.port</code> in your <code>config.ini</code> file is a better solution for local installations.</p>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_32"><a class="anchor" href="#_related_articles_32"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
<li>
<p><a href="build-tools-maven.html" class="page">Building components with Maven</a></p>
</li>
<li>
<p><a href="build-tools-gradle.html" class="page">Building components with Gradle</a></p>
</li>
<li>
<p><a href="creating-dataset-datastore.html" class="page">Learn how to use datasets and datastores with TAlend Studio</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_installing_components_using_a_car_file"><a class="anchor" href="#_installing_components_using_a_car_file"></a>Installing components using a CAR file</h3>
<div class="paragraph">
<p>Components built using Talend Component Kit can be shared as component archives (.car). These CAR files are executable files allowing to easily deploy the components it contains to any compatible version of <a href="https://sourceforge.net/projects/talend-studio/">Talend Studio</a>.</p>
</div>
<div class="paragraph">
<p>Component developers can generate .car files from their projects to share their components and make them available for other users, as detailed in <a href="build-tools-maven.html" class="page">this document</a>.</p>
</div>
<div class="paragraph">
<p>This document assumes that you have a component archive (.car) file and need to deploy it to Talend Studio.</p>
</div>
<div class="sect3">
<h4 id="_deploying_from_the_car_file_to_talend_studio"><a class="anchor" href="#_deploying_from_the_car_file_to_talend_studio"></a>Deploying from the CAR file to Talend Studio</h4>
<div class="paragraph">
<p>The component archive (.car) is executable and exposes the <code>studio-deploy</code> command which takes a Talend Studio home path as parameter. When executed, it installs the dependencies into the Studio and registers the component in your instance. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># for a studio
java -jar mycomponent.car studio-deploy /path/to/my/studio
or
java -jar mycomponent.car studio-deploy --location /path/to/my/studio

# for a m2 provisioning
java -jar mycomponent.car maven-deploy /path/to/.m2/repository
or
java -jar mycomponent.car maven-deploy --location /path/to/.m2/repository</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also upload the dependencies to your Nexus server using the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java -jar mycomponent.car deploy-to-nexus --url &lt;nexus url&gt; --repo &lt;repository name&gt; --user &lt;username&gt; --pass &lt;password&gt; --threads &lt;parallel threads number&gt; --dir &lt;temp directory&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this command, Nexus URL and repository name are mandatory arguments. All other arguments are optional. If arguments contain spaces or special symbols, you need to quote the whole value of the argument. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">--pass "Y0u will \ not G4iess i' ^"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deploying_a_component_archive_to_a_remote_project_from_talend_studio"><a class="anchor" href="#_deploying_a_component_archive_to_a_remote_project_from_talend_studio"></a>Deploying a component archive to a remote project from Talend Studio</h4>
<div class="paragraph">
<p>Talend Studio allows you to share components you have created using Talend Component Kit to other users working on the same remote project.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remote projects are available with Enterprise versions of Talend Studio only.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Make sure you are connected to a remote project and the artifact repository for component sharing has been properly configured.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>On the toolbar of the Studio main window, click  or click <strong>File</strong> &gt; <strong>Edit Project Properties</strong> from the menu bar to open the Project Settings dialog box.</p>
</li>
<li>
<p>In the tree view of the dialog box, select <strong>Repository Share</strong> to open the corresponding view.</p>
</li>
<li>
<p>Select the <strong>Propagate components update to Artifact Repository</strong> check box.</p>
</li>
<li>
<p>In the Repository ID field, specify the artifact repository configured for component sharing, and then click <strong>Check connection</strong> to verify the connectivity.</p>
</li>
<li>
<p>Click <strong>Apply and Close</strong> to validate the settings and close the dialog box.</p>
</li>
<li>
<p>Create a folder named <code>patches</code> at the root of your Talend Studio installation directory, then copy the .car files of the components you want share to this folder.</p>
</li>
<li>
<p>Restart your Talend Studio and connect to the remote project.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The components are deployed automatically to the repository and available in the Palette for other users when connected to a remote project with the same sharing repository configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_troubleshooting"><a class="anchor" href="#_troubleshooting"></a>Troubleshooting</h4>
<div class="paragraph">
<p><strong>My custom component builds correctly but does not appear in Talend Studio, how to fix it?</strong>
This issue can be caused by the icon specified in the component metadata.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make sure to specify a custom icon for the component and the component family.</p>
</li>
<li>
<p>These custom icons must be in PNG format to be properly handled by Talend Studio.</p>
</li>
<li>
<p>Remove SVG parameters from the <code>talend.component.server.icon.paths</code> property in the HTTP server configuration. Refer to <a href="ref-server-configuration.html" class="page">this section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Learn more about defining custom icons for components in <a href="component-registering.html" class="page">this document</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_from_javajet_to_talend_component_kit"><a class="anchor" href="#_from_javajet_to_talend_component_kit"></a>From Javajet to Talend Component Kit</h3>
<div class="paragraph">
<p>From the version 7.0 of Talend Studio, Talend Component Kit becomes the recommended framework to use to develop components.</p>
</div>
<div class="paragraph">
<p>This framework is being introduced to ensure that newly developed components can be deployed and executed both in on-premise/local and cloud/big data environments.</p>
</div>
<div class="paragraph">
<p>From that new approach comes the need to provide a complete yet unique and compatible way of developing components.</p>
</div>
<div class="paragraph">
<p>With the Component Kit, custom components are entirely implemented in Java. To help you get started with a new custom component development project, a <a href="https://starter-toolkit.talend.io/">Starter</a> is available. Using it, you will be able to generate the skeleton of your project. By importing this skeleton in a development tool, you can then implement the components layout and execution logic in Java.</p>
</div>
<div class="sect3">
<h4 id="_defining_the_component_configuration"><a class="anchor" href="#_defining_the_component_configuration"></a>Defining the component configuration</h4>
<div class="paragraph">
<p>With the previous Javajet framework, metadata,  widgets and configurable parts of a custom component were specified in XML.
With the Component Kit, they are now defined in the <code>&lt;component_name&gt;&lt;component_type&gt;Configuration</code> (for example, <code>LoggerProcessorConfiguration</code>) Java class of your development project.</p>
</div>
<div class="paragraph">
<p>Note that most of this configuration is transparent if you specified the Configuration Model of your components right before generating the project from the Starter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any undocumented feature or option is considered not supported by the Component Kit framework.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can find examples of output in Studio or Cloud environments in the <a href="gallery.html" class="page">Gallery</a>.</p>
</div>
<div class="sect4">
<h5 id="_widgets"><a class="anchor" href="#_widgets"></a>Widgets</h5>
<div class="sect5">
<h6 id="_inputtext"><a class="anchor" href="#_inputtext"></a>Input/Text</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER
    NAME="CONFIG"
    FIELD="TEXT"
    NUM_ROW="10"&gt;
        &lt;DEFAULT&gt;""&lt;/DEFAULT&gt;
&lt;/PARAMETER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
String config;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_password"><a class="anchor" href="#_password"></a>Password</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER
    NAME="PASSWORD"
    FIELD="PASSWORD"
    NUM_ROW="10"
    REQUIRED="true"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@Credential
String password;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_textarea_2"><a class="anchor" href="#_textarea_2"></a>Textarea</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER NAME="QUERY"
    FIELD="MEMO"
    NUM_ROW="1"&gt;
        &lt;DEFAULT&gt;""&lt;/DEFAULT&gt;
&lt;/PARAMETER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@Textarea
String query;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_integer"><a class="anchor" href="#_integer"></a>Integer</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;!-- There were no specific widget for number fields --&gt;
&lt;PARAMETER
    NAME="CONFIG"
    FIELD="TEXT"
    NUM_ROW="10"&gt;
        &lt;DEFAULT&gt;""&lt;/DEFAULT&gt;
&lt;/PARAMETER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@Documentation("This is a number")
public Integer number;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_checkbox"><a class="anchor" href="#_checkbox"></a>Checkbox</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER
    NAME="PRETTY_FORMAT"
    FIELD="CHECK"
    NUM_ROW="10"&gt;
        &lt;DEFAULT&gt;false&lt;/DEFAULT&gt;
&lt;/PARAMETER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
Boolean pretty_format;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_list"><a class="anchor" href="#_list"></a>List</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER
    NAME="ACTION"
    FIELD="CLOSED_LIST"
    NUM_ROW="10"&gt;
    &lt;ITEMS DEFAULT="1"&gt;
        &lt;ITEM NAME="DELETE" VALUE="1" /&gt;
        &lt;ITEM NAME="INSERT" VALUE="2" /&gt;
        &lt;ITEM NAME="UPDATE" VALUE="3" /&gt;
    &lt;/ITEMS&gt;
&lt;/PARAMETER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@Proposable("valuesProvider")
String action;
/** service class */
@DynamicValues("valuesProvider")
public Values actions(){
  return new Values(asList(new Values.Item("1", "Delete"),
                    new Values.Item("2", "Insert"),
                    new Values.Item("3", "Update")));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
ActionEnum action;

/** Define enum */
enum ActionEnum {
    Delete,
    Insert,
    Update
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_suggestions_2"><a class="anchor" href="#_suggestions_2"></a>Suggestions</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;!-- There were no simple way to load proposals from service in javajet --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@Suggestable(value = "loadModules", parameters = { "myconfig" })
@Documentation("module names are loaded using service")
public String moduleName;


// In Service class
@Suggestions("loadModules")
public SuggestionValues loadModules(@Option final MyConfig myconfig) { }</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_table"><a class="anchor" href="#_table"></a>Table</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;!-- There were no simple way to select complex objects in javajet --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
List&lt;MyObject&gt; config;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_code_2"><a class="anchor" href="#_code_2"></a>Code</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETERS&gt;
    &lt;PARAMETER NAME="CODE" FIELD="MEMO_JAVA" RAW="true" REQUIRED="false" NUM_ROW="10" NB_LINES="10"&gt;
        &lt;DEFAULT&gt;String foo = "bar";&lt;/DEFAULT&gt;
    &lt;/PARAMETER&gt;
&lt;/PARAMETERS&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Code("java")
@Option
String code;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_schema_2"><a class="anchor" href="#_schema_2"></a>Schema</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER
    NAME="COLUMNS"
    FIELD="COLUMN_LIST"
    NUM_ROW="10"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Option
@Structure
List&lt;String&gt; columns;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_validations_2"><a class="anchor" href="#_validations_2"></a>Validations</h5>
<div class="sect5">
<h6 id="_property_validation"><a class="anchor" href="#_property_validation"></a>Property validation</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;!-- There were no url pattern validation in javajet --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/** configuration class */
@Option
@Validable("url")
String config;

/** service class */
@AsyncValidation("url")
ValidationResult doValidate(String url) {
//validate the property
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_property_validation_with_pattern"><a class="anchor" href="#_property_validation_with_pattern"></a>Property validation with Pattern</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;!-- There were no regex validation in javajet --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/** configuration class */
@Option
@Pattern("/^[a-zA-Z\\-]+$/")
String username;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_data_store_validation"><a class="anchor" href="#_data_store_validation"></a>Data store validation</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;!-- There were no healthcheck javajet --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Datastore
@Checkable
public class config {
/** config ...*/
}

/** service class */
@HealthCheck
public HealthCheckStatus testConnection(){

//validate the connection
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_binding_properties"><a class="anchor" href="#_binding_properties"></a>Binding properties</h5>
<div class="sect5">
<h6 id="_activeif_2"><a class="anchor" href="#_activeif_2"></a>ActiveIf</h6>
<div class="paragraph">
<p>Javajet</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;PARAMETER
    NAME="AUTH_TYPE"
    FIELD="CLOSED_LIST"
    NUM_ROW="10"&gt;
    &lt;ITEMS DEFAULT="NOAUTH"&gt;
        &lt;ITEM NAME="NOAUTH" VALUE="NOAUTH" /&gt;
        &lt;ITEM NAME="BASIC" VALUE="BASIC" /&gt;
        &lt;ITEM NAME="BASIC" VALUE="OAUTH2" /&gt;
    &lt;/ITEMS&gt;
&lt;/PARAMETER&gt;

&lt;PARAMETER
    NAME="LOGIN"
    FIELD="TEXT"
    NUM_ROW="20"
    SHOW_IF="AUTH_TYPE == 'BASIC'"&gt;
        &lt;DEFAULT&gt;"login"&lt;/DEFAULT&gt;
&lt;/PARAMETER&gt;

&lt;PARAMETER
    NAME="LOGIN"
    FIELD="PASSWORD"
    NUM_ROW="20"
    SHOW_IF="AUTH_TYPE='BASIC'"&gt;
        &lt;DEFAULT&gt;"login"&lt;/DEFAULT&gt;
&lt;/PARAMETER&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Component Kit</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java"> enum AuthorizationType {
        NoAuth,
        Basic,
        oauth2
}

@Option
@Required
@Documentation("")
private AuthorizationType type = AuthorizationType.NoAuth;

@Option
@required
@ActiveIf(target = "type", value = "Basic")
@Documentation("Username for the basic authentication")
private String login;

@Option
@required
@credential
@ActiveIf(target = "type", value = "Basic")
@Documentation("password for the basic authentication")
private String password;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_runtime"><a class="anchor" href="#_defining_the_runtime"></a>Defining the runtime</h4>
<div class="paragraph">
<p>Previously, the execution of a custom component was described through several Javajet files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;component_name&gt;_begin.javajet, containing the code required to initialize the component.</p>
</li>
<li>
<p>&lt;component_name&gt;_main.javajet, containing the code required to process each line of the incoming data.</p>
</li>
<li>
<p>&lt;component_name&gt;_end.javajet, containing the code required to end the processing and go to the following step of the execution.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the Component Kit, the entire execution flow of a component is described through its main Java class <code>&lt;component_name&gt;&lt;component_type&gt;</code> (for example, <code>LoggerProcessor</code>) and through services for reusable parts.</p>
</div>
</div>
<div class="sect3">
<h4 id="_component_execution_logic_2"><a class="anchor" href="#_component_execution_logic_2"></a>Component execution logic</h4>
<div class="paragraph">
<p>Each type of component has its own execution logic. The same basic logic is applied to all components of the same type, and is then extended to implement each component specificities.
The project generated from the starter already contains the basic logic for each component.</p>
</div>
<div class="paragraph">
<p>Talend Component Kit framework relies on several primitive components.</p>
</div>
<div class="paragraph">
<p>All components can use <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations to initialize or release some underlying resource at the beginning and the end of a processing.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
In distributed environments, class constructor are called on cluster manager nodes. Methods annotated with <code>@PostConstruct</code> and <code>@PreDestroy</code> are called on worker nodes. Thus, partition plan computation and pipeline tasks are performed on different nodes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/deployment-diagram.png" target="_blank" rel="noopener"><img src="_images/deployment-diagram.png" alt="Deployment diagram"></a></span></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The created task is a JAR file containing class information, which describes the pipeline (flow) that should be processed in cluster.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>During the partition plan computation step, the pipeline is analyzed and split into stages. The cluster manager node instantiates mappers/processors, gets estimated data size using mappers, and splits created mappers according to the estimated data size.<br>
All instances are then serialized and sent to the worker node.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Serialized instances are received and deserialized. Methods annotated with <code>@PostConstruct</code> are called. After that, pipeline execution starts. The <code>@BeforeGroup</code> annotated method of the processor is called before processing the first element in chunk.<br>
After processing the number of records estimated as chunk size, the <code>@AfterGroup</code> annotated method of the processor is called. Chunk size is calculated depending on the environment the pipeline is processed by. Once the pipeline is processed, methods annotated with <code>@PreDestroy</code> are called.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All the methods managed by the framework must be public. Private methods are ignored.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/driver-processing-workflow.png" target="_blank" rel="noopener"><img src="_images/driver-processing-workflow.png" alt="Driver processing workflow"></a></span></p>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/worker-processing-workflow.png" target="_blank" rel="noopener"><img src="_images/worker-processing-workflow.png" alt="Worker processing workflow"></a></span></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The framework is designed to be as declarative as possible but also to stay extensible by not using fixed interfaces or method signatures. This allows to incrementally add new features of the underlying implementations.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_main_changes"><a class="anchor" href="#_main_changes"></a>Main changes</h5>
<div class="paragraph">
<p>To ensure that the Cloud-compatible approach of the Component Kit framework is respected, some changes were introduced on the implementation side, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <strong>File</strong> mode is no longer supported. You can still work with URIs and remote storage systems to use files. The file collection must be handled at the component implementation level.</p>
</li>
<li>
<p>The input and output connections between two components can only be of the <strong>Flow</strong> or <strong>Reject</strong> types. Other types of connections are not supported.</p>
</li>
<li>
<p>Every Output component must have a corresponding Input component and use a dataset. All datasets must use a datastore.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resources_and_examples"><a class="anchor" href="#_resources_and_examples"></a>Resources and examples</h4>
<div class="paragraph">
<p>To get started with the Component Kit framework, you can go through the following documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="getting-started.html" class="page">Learn the basics about Talend Component Kit</a></p>
</li>
<li>
<p><a href="tutorial-create-my-first-component.html" class="page">Create and deploy your first Component Kit component</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Learn about the Starter</a></p>
</li>
<li>
<p><a href="index-creating-components.html" class="page">Start implementing components</a></p>
</li>
<li>
<p><a href="index-deploying-components.html" class="page">Integrate a component to Talend Studio</a></p>
</li>
<li>
<p><a href="https://github.com/Talend/connectors-se">Check some examples of components built with Talend Component Kit</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrating_components_into_talend_cloud"><a class="anchor" href="#_integrating_components_into_talend_cloud"></a>Integrating components into Talend Cloud</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Learn about the Component Server with the following articles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="documentation-rest.html" class="page">Component server and HTTP API</a></p>
</li>
<li>
<p><a href="vault-proxy.html" class="page">Component Server Vault Proxy</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_component_server_and_http_api"><a class="anchor" href="#_component_server_and_http_api"></a>Component server and HTTP API</h3>
<div class="sect3">
<h4 id="_http_api"><a class="anchor" href="#_http_api"></a>HTTP API</h4>
<div class="paragraph">
<p>The HTTP API intends to expose most Talend Component Kit features over HTTP. It is a standalone Java HTTP server.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The WebSocket protocol is activated for the endpoints. Endpoints then use <code>/websocket/v1</code> as base instead of <code>/api/v1</code>. See <a href="#websocket-transport">WebSocket</a> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Browse the API description using <a href="rest-openapi.html" class="page"><span class="image img-inline"><img src="_images/openapi/OpenAPI.svg" alt="OpenAPI"></span></a> interface.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To make sure that the migration can be enabled, you need to set the version the component was created with in the execution configuration that you send to the server (component version is in component the detail endpoint). To do that, use <code>tcomp::component::version</code> key.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_deprecated_endpoints"><a class="anchor" href="#_deprecated_endpoints"></a>Deprecated endpoints</h5>
<div class="paragraph">
<p>Endpoints that are intended to disappear will be deprecated. A <code>X-Talend-Warning</code> header will be returned with a message as value.</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-transport"><a class="anchor" href="#websocket-transport"></a>WebSocket transport</h5>
<div class="paragraph">
<p>You can connect yo any endpoint by:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Replacing <code>/api</code> with <code>/websocket</code></p>
</li>
<li>
<p>Appending <code>/&lt;http method&gt;</code> to the URL</p>
</li>
<li>
<p>Formatting the request as:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>SEND
destination: &lt;endpoint after v1&gt;
&lt;headers&gt;

&lt;payload&gt;^@</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>SEND
destination: /component/index
Accept: application/json

^@</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response is formatted as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>MESSAGE
status: &lt;http status code&gt;
&lt;headers&gt;

&lt;payload&gt;^@</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
All endpoints are logged at startup. You can then find them in the logs if you have a doubt about which one to use.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to create a pool of connections per endpoint/verb, you can use the bus endpoint: <code>/websocket/v1/bus</code>.
This endpoint requires that you add the <code>destinationMethod</code> header to each request with the verb value (<code>GET</code> by default):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>SEND
destination: /component/index
destinationMethod: GET
Accept: application/json

^@</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_server_configuration"><a class="anchor" href="#_server_configuration"></a>Server configuration</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the configuration is read from system properties, environment variables, &#8230;&#8203;.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">talend.component.server.cache.maxSize</dt>
<dd>
<p>Default value: <code>1000</code>. Maximum items a cache can store, used for index endpoints.</p>
</dd>
<dt class="hdlist1">talend.component.server.component.coordinates</dt>
<dd>
<p>A comma separated list of gav to locate the components</p>
</dd>
<dt class="hdlist1">talend.component.server.component.documentation.translations</dt>
<dd>
<p>Default value: <code>${home}/documentations</code>. A component translation repository. This is where you put your documentation translations. Their name must follow the pattern <code>documentation_${container-id}_language.adoc</code> where <code>${container-id}</code> is the component jar name (without the extension and version, generally the artifactId).</p>
</dd>
<dt class="hdlist1">talend.component.server.component.extend.dependencies</dt>
<dd>
<p>Default value: <code>true</code>. Should the component extensions add required dependencies.</p>
</dd>
<dt class="hdlist1">talend.component.server.component.extension.maven.repository</dt>
<dd>
<p>If you deploy some extension, where they can create their dependencies if needed.</p>
</dd>
<dt class="hdlist1">talend.component.server.component.extension.startup.timeout</dt>
<dd>
<p>Default value: <code>180000</code>. Timeout for extension initialization at startup, since it ensures the startup wait extensions are ready and loaded it allows to control the latency it implies.</p>
</dd>
<dt class="hdlist1">talend.component.server.component.registry</dt>
<dd>
<p>A property file (or multiple comma separated) where the value is a gav of a component to register(complementary with <code>coordinates</code>). Note that the path can end up with <code><strong></code> or <code></strong>.properties</code> to take into account all properties in a folder.</p>
</dd>
<dt class="hdlist1">talend.component.server.documentation.active</dt>
<dd>
<p>Default value: <code>true</code>. Should the /documentation endpoint be activated. Note that when called on localhost the doc is always available.</p>
</dd>
<dt class="hdlist1">talend.component.server.environment.active</dt>
<dd>
<p>Default value: <code>true</code>. Should the /api/v1/environment endpoint be activated. It shows some internal versions and git commit which are not always desirable over the wire.</p>
</dd>
<dt class="hdlist1">talend.component.server.filter.secured.tokens</dt>
<dd>
<p>Default value: <code>-</code>. Accepted tokens in Authorization header for remote calls to secured endpoints (/api/v1/environment or /documentation).</p>
</dd>
<dt class="hdlist1">talend.component.server.gridlayout.translation.support</dt>
<dd>
<p>Default value: <code>false</code>. Should the components using a <code>@GridLayout</code> support tab translation. Studio does not suppot that feature yet so this is not enabled by default.</p>
</dd>
<dt class="hdlist1">talend.component.server.icon.paths</dt>
<dd>
<p>Default value: <code>icons/%s.svg,icons/svg/%s.svg,icons/%s_icon32.png,icons/png/%s_icon32.png</code>. These patterns are used to find the icons in the classpath(s).</p>
</dd>
<dt class="hdlist1">talend.component.server.jaxrs.exceptionhandler.defaultMessage</dt>
<dd>
<p>Default value: <code>false</code>. If set it will replace any message for exceptions. Set to <code>false</code> to use the actual exception message.</p>
</dd>
<dt class="hdlist1">talend.component.server.lastUpdated.useStartTime</dt>
<dd>
<p>Default value: <code>false</code>. Should the lastUpdated timestamp value of <code>/environment</code> endpoint be updated with server start time.</p>
</dd>
<dt class="hdlist1">talend.component.server.locale.mapping</dt>
<dd>
<p>Default value: <code>en*=en
fr*=fr
zh*=zh_CN
ja*=ja</code>. For caching reasons the goal is to reduce the locales to the minimum required numbers. For instance we avoid <code>fr</code> and <code>fr_FR</code> which would lead to the same entries but x2 in terms of memory. This mapping enables that by whitelisting allowed locales, default being <code>en</code>. If the key ends with <code><strong></code> it means all string starting with the prefix will match. For instance <code>fr</strong></code> will match <code>fr_FR</code> but also <code>fr_CA</code>.</p>
</dd>
<dt class="hdlist1">talend.component.server.maven.repository</dt>
<dd>
<p>The local maven repository used to locate components and their dependencies</p>
</dd>
<dt class="hdlist1">talend.component.server.request.log</dt>
<dd>
<p>Default value: <code>false</code>. Should the all requests/responses be logged (debug purposes - only work when running with CXF).</p>
</dd>
<dt class="hdlist1">talend.component.server.security.command.handler</dt>
<dd>
<p>Default value: <code>securityNoopHandler</code>. How to validate a command/request. Accepted values: securityNoopHandler.</p>
</dd>
<dt class="hdlist1">talend.component.server.security.connection.handler</dt>
<dd>
<p>Default value: <code>securityNoopHandler</code>. How to validate a connection. Accepted values: securityNoopHandler.</p>
</dd>
<dt class="hdlist1">talend.component.server.user.extensions.location</dt>
<dd>
<p>A folder available for the server - don&#8217;t forget to mount it in docker if you are using the image - which accepts subfolders named as component plugin id (generally the artifactId or jar name without the version, ex: jdbc). Each family folder can contain:</p>
<div class="ulist">
<ul>
<li>
<p>a <code>user-configuration.properties</code> file which will be merged with component configuration system (see services). This properties file enables the function <code>userJar(xxxx)</code> to replace the jar named <code>xxxx</code> by its virtual gav (<code>groupId:artifactId:version</code>),</p>
</li>
<li>
<p>a list of jars which will be merged with component family classpath</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">talend.component.server.user.extensions.provisioning.location</dt>
<dd>
<p>Default value: <code>auto</code>. Should the implicit artifacts be provisionned to a m2. If set to <code>auto</code> it tries to detect if there is a m2 to provision - recommended, if set to <code>skip</code> it is ignored, else it uses the value as a m2 path.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="_configuration_mechanism"><a class="anchor" href="#_configuration_mechanism"></a>Configuration mechanism</h5>
<div class="paragraph">
<p>The configuration uses Microprofile Config for most entries. It means it can be passed through system properties and environment variables (by replacing dots with underscores and making the keys uppercase).</p>
</div>
<div class="paragraph">
<p>To configure a Docker image rather than a standalone instance, Docker Config and secrets integration allows you to read the configuration from files. You can customize the configuration of these integrations through system properties.</p>
</div>
<div class="paragraph">
<p>Docker integration provides a <code>secure:</code> support to encrypt values and  system properties, when required.</p>
</div>
<div class="paragraph">
<p>It is fully implemented using the <a href="http://geronimo.apache.org/microprofile/extensions.html">Apache Geronimo Microprofile Config</a> extensions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_https_activation"><a class="anchor" href="#_https_activation"></a>HTTPS activation</h4>
<div class="paragraph">
<p>Using the server ZIP (or <a href="https://github.com/Talend/component-runtime/blob/master/.docker/Dockerfile">Docker image</a>), you can configure HTTPS by adding properties to <code>_JAVA_OPTIONS</code>. Assuming that you have a certificate in <code>/opt/certificates/component.p12</code> (don&#8217;t forget to add/mount it in the Docker image if you use it), you can activate it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># use -e for Docker and `--https=8443` to set the port
#
# this skips the http port binding and only binds https on the port 8443, and setups the correct certificate
export _JAVA_OPTIONS="-Dskip-http=true -Dssl=true -Dhttps=8443 -Dkeystore-type=PKCS12 -Dkeystore-alias=talend -Dkeystore-password=talend -Dkeystore-file=/opt/certificates/component.p12"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_queries"><a class="anchor" href="#_defining_queries"></a>Defining queries</h4>
<div class="paragraph">
<p>You can define simple queries on the <a href="rest-openapi.html#/Configuration%20Type/getRepositoryModel">configuration types</a> and <a href="rest-openapi.html#/Component/getIndex">components</a> endpoints. These two endpoints support different parameters.</p>
</div>
<div class="paragraph">
<p>Queries on the <code>configurationtype/index</code> endpoint supports the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type</code></p>
</li>
<li>
<p><code>id</code></p>
</li>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>metadata</code> of the first configuration property as parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Queries on the <code>component/index</code> endpoint supports the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>plugin</code></p>
</li>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>id</code></p>
</li>
<li>
<p><code>familyId</code></p>
</li>
<li>
<p><code>metadata</code> of the first configuration property as parameters.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In both cases, you can combine several conditions using <code>OR</code> and <code>AND</code> operators. If you combine more than two conditions, note that they are evaluated in the order they are written.</p>
</div>
<div class="paragraph">
<p>Each supported parameter in a condition can be "equal to" (<code>=</code>) or "not equal to" (<code>!=</code>) a defined value (case-sensitive).</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">(metadata[configurationtype::type] = dataset) AND (plugin = jdbc-component) OR (name = input)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the query gets components that have a dataset and belong to the jdbc-component plugin, or components that are named <code>input</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_forms_and_rest_api"><a class="anchor" href="#_web_forms_and_rest_api"></a>Web forms and REST API</h4>
<div class="paragraph">
<p>The <code>component-form</code> library provides a way to build a component REST API facade that is compatible with React form library.</p>
</div>
<div class="paragraph">
<p>for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("tacokit-facade")
@ApplicationScoped
public class ComponentFacade {
    private static final String[] EMPTY_ARRAY = new String[0];

    @Inject
    private Client client;

    @Inject
    private ActionService actionService;

    @Inject
    private UiSpecService uiSpecService;

    @Inject // assuming it is available in your app, use any client you want
    private WebTarget target;

    @POST
    @Path("action")
    public void action(@Suspended final AsyncResponse response, @QueryParam("family") final String family,
            @QueryParam("type") final String type, @QueryParam("action") final String action,
            final Map&lt;String, Object&gt; params) {
        client.action(family, type, action, params).handle((r, e) -&gt; {
            if (e != null) {
                onException(response, e);
            } else {
                response.resume(actionService.map(type, r));
            }
            return null;
        });
    }

    @GET
    @Path("index")
    public void getIndex(@Suspended final AsyncResponse response,
            @QueryParam("language") @DefaultValue("en") final String language) {
        target
                .path("component/index")
                .queryParam("language", language)
                .request(APPLICATION_JSON_TYPE)
                .rx()
                .get(ComponentIndices.class)
                .toCompletableFuture()
                .handle((index, e) -&gt; {
            if (e != null) {
                onException(response, e);
            } else {
                index.getComponents().stream().flatMap(c -&gt; c.getLinks().stream()).forEach(
                        link -&gt; link.setPath(link.getPath().replaceFirst("/component/", "/application/").replace(
                                "/details?identifiers=", "/detail/")));
                response.resume(index);
            }
            return null;
        });
    }

    @GET
    @Path("detail/{id}")
    public void getDetail(@Suspended final AsyncResponse response,
            @QueryParam("language") @DefaultValue("en") final String language, @PathParam("id") final String id) {
        target
                .path("component/details")
                .queryParam("language", language)
                .queryParam("identifiers", id)
                .request(APPLICATION_JSON_TYPE)
                .rx()
                .get(ComponentDetailList.class)
                .toCompletableFuture()
                .thenCompose(result -&gt; uiSpecService.convert(result.getDetails().iterator().next()))
                .handle((result, e) -&gt; {
                    if (e != null) {
                        onException(response, e);
                    } else {
                        response.resume(result);
                    }
                    return null;
                });
    }

    private void onException(final AsyncResponse response, final Throwable e) {
        final UiActionResult payload;
        final int status;
        if (WebException.class.isInstance(e)) {
            final WebException we = WebException.class.cast(e);
            status = we.getStatus();
            payload = actionService.map(we);
        } else if (CompletionException.class.isInstance(e)) {
            final CompletionException actualException = CompletionException.class.cast(e);
            log.error(actualException.getMessage(), actualException);
            status = Response.Status.BAD_GATEWAY.getStatusCode();
            payload = actionService.map(new WebException(actualException, -1, emptyMap()));
        } else {
            log.error(e.getMessage(), e);
            status = Response.Status.BAD_GATEWAY.getStatusCode();
            payload = actionService.map(new WebException(e, -1, emptyMap()));
        }
        response.resume(new WebApplicationException(Response.status(status).entity(payload).build()));
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the <code>Client</code> can be created using <code>ClientFactory.createDefault(System.getProperty("app.components.base", "http://localhost:8080/api/v1"))</code> and the service can be a simple <code>new UiSpecService&lt;&gt;()</code>. The factory uses JAX-RS if the API is available (assuming a JSON-B provider is registered). Otherwise, it tries to use Spring.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The conversion from the component model (REST API) to the uiSpec model is done through  <code>UiSpecService</code>. It is based on the object model which is mapped to a UI model. Having a flat model in the component REST API allows to customize layers easily.</p>
</div>
<div class="paragraph">
<p>You can completely control the available components, tune the rendering by switching the <code>uiSchema</code>, and add or remove parts of the form.
You can also add custom actions and buttons for specific needs of the application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>/migrate</code> endpoint was not shown in the previous snippet but if you need it, add it as well.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_using_the_uispec_model_without_the_tooling"><a class="anchor" href="#_using_the_uispec_model_without_the_tooling"></a>Using the UiSpec model without the tooling</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;component-form-model&lt;/artifactId&gt;
  &lt;version&gt;${talend-component-kit.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This Maven dependency provides the UISpec model classes. You can use the <code>Ui</code> API (with or without the builders) to create UiSpec representations.</p>
</div>
<div class="paragraph">
<p>For Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final Ui form1 = ui()
    .withJsonSchema(JsonSchema.jsonSchemaFrom(Form1.class).build()) <i class="conum" data-value="1"></i><b>(1)</b>
    .withUiSchema(uiSchema() <i class="conum" data-value="2"></i><b>(2)</b>
        .withKey("multiSelectTag")
        .withRestricted(false)
        .withTitle("Simple multiSelectTag")
        .withDescription("This data list accepts values that are not in the list of suggestions")
        .withWidget("multiSelectTag")
        .build())
    .withProperties(myFormInstance) <i class="conum" data-value="3"></i><b>(3)</b>
    .build();

final String json = jsonb.toJson(form1); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>JsonSchema</code> is extracted from reflection on the <code>Form1</code> class. <code>@JsonSchemaIgnore</code> allows to ignore a field and <code>@JsonSchemaProperty</code> allows to rename a property.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A <code>UiSchema</code> is programmatically built using the builder API.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>An instance of the form is passed to let the serializer extract its JSON model.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>Ui</code> model, which can be used by UiSpec compatible front widgets, is serialized.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The model uses the JSON-B API to define the binding. Make sure to have an implementation in your classpath. To do that, add the following dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
  &lt;artifactId&gt;geronimo-jsonb_1.0_spec&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
  &lt;artifactId&gt;geronimo-json_1.1_spec&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.johnzon&lt;/groupId&gt;
  &lt;artifactId&gt;johnzon-jsonb&lt;/artifactId&gt;
  &lt;version&gt;${johnzon.version}&lt;/version&gt; &lt;!-- 1.1.5 for instance --&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_using_the_uispec_for_custom_models"><a class="anchor" href="#_using_the_uispec_for_custom_models"></a>Using the UiSpec for custom models</h5>
<div class="paragraph">
<p>The following module enables you to define through annotations a uispec on your own models:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
  &lt;artifactId&gt;component-uispec-mapper&lt;/artifactId&gt;
  &lt;version&gt;${talend-component-kit.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
this can&#8217;t be used in components and is only intended for web applications.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>org.talend.sdk.component.form.uispec.mapper.api.service.UiSpecMapper</code> enables to create a <code>Ui</code> instance from a custom type annotated with
<code>org.talend.sdk.component.form.uispec.mapper.api.model.View</code> and <code>org.talend.sdk.component.form.uispec.mapper.api.model.View.Schema</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>UiSpecMapper</code> returns a <code>Supplier</code> and not directly an <code>Ui</code> because the ui-schema is re-evaluated when `get()̀  is called.
This enables to update the title maps for example.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
public abstract class BaseModel {
    @View.Skip
    private String id;

    @View.Skip
    private Date created;

    @View.Skip
    private Date updated;

    @View.Schema(type = "hidden", readOnly = true)
    private long version;
}

@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class ComponentModel extends BaseModel {
    @View.Schema(length = 1024, required = true, position = 1, reference = "vendors")
    private String vendor;

    @View.Schema(length = 2048, required = true, position = 2)
    private String name;

    @View.Schema(length = 2048, required = true, position = 3)
    private String license;

    @View.Schema(length = 2048, required = true, position = 4)
    private String sources;

    @View.Schema(length = 2048, required = true, position = 5)
    private String bugtracker;

    @View.Schema(length = 2048, required = true, position = 6)
    private String documentation;

    @View.Schema(widget = "textarea", length = 8192, required = true, position = 7)
    private String description;

    @View.Schema(widget = "textarea", length = 8192, position = 8)
    private String changelog;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This API maps directly the UiSpec model (json schema and ui schema of Talend <code>UIForm</code>).</p>
</div>
<div class="paragraph">
<p>The default implementation of the mapper is available at <code>org.talend.sdk.component.form.uispec.mapper.impl.UiSpecMapperImpl</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private UiSpecMapper mapper = new UiSpecMapperImpl(new Configuration(getTitleMapProviders()));

@GET
public Ui getNewComponentModelForm() {
    return mapper.createFormFor(ComponentModel.class).get();
}

@GET
@Path("{id}")
public Ui editComponentModelForm(final @PathParam("id") final String id) {
    final ComponentModel component = findComponent(id);
    final Ui spec = getNewComponentModelForm();
    spec.setProperties(component);
    return spec;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getTitleMapProviders()</code> method will generally lookup a set of <code>TitleMapProvider</code> instances in your IoC context.
This API is used to fill the <code>titleMap</code> of the form when a reference identifier is set on the <code>@Schema</code> annotation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_javascript_integration"><a class="anchor" href="#_javascript_integration"></a>JavaScript integration</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>component-kit.js</code> is no more available (previous versions stay on NPM) and is replaced by <code>@talend/react-containers</code>.
The previous import can be replaced by <code>import kit from '@talend/react-containers/lib/ComponentForm/kit';</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Default JavaScript integration goes through the <a href="https://github.com/Talend/ui/tree/master/packages/forms">Talend UI Forms</a> library
and its <a href="https://github.com/Talend/ui/tree/master/packages/containers">Containers</a> wrapper.</p>
</div>
<div class="paragraph">
<p>Documentation is now available on the previous link.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logging"><a class="anchor" href="#_logging"></a>Logging</h4>
<div class="paragraph">
<p>The logging uses Log4j2. You can specify a custom configuration by using the <code>-Dlog4j.configurationFile</code> system property or by adding a <code>log4j2.xml</code> file to the classpath.</p>
</div>
<div class="paragraph">
<p>Here are some common configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Console logging:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0"?&gt;
&lt;Configuration status="INFO"&gt;
  &lt;Appenders&gt;
    &lt;Console name="Console" target="SYSTEM_OUT"&gt;
      &lt;PatternLayout pattern="[%d{HH:mm:ss.SSS}][%highlight{%-5level}][%15.15t][%30.30logger] %msg%n"/&gt;
    &lt;/Console&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level="INFO"&gt;
      &lt;AppenderRef ref="Console"/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output messages look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>[16:59:58.198][INFO ][           main][oyote.http11.Http11NioProtocol] Initializing ProtocolHandler ["http-nio-34763"]</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>JSON logging:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0"?&gt;
&lt;Configuration status="INFO"&gt;
  &lt;Properties&gt;
    &lt;!-- DO NOT PUT logSource there, it is useless and slow --&gt;
    &lt;Property name="jsonLayout"&gt;{"severity":"%level","logMessage":"%encode{%message}{JSON}","logTimestamp":"%d{ISO8601}{UTC}","eventUUID":"%uuid{RANDOM}","@version":"1","logger.name":"%encode{%logger}{JSON}","host.name":"${hostName}","threadName":"%encode{%thread}{JSON}","stackTrace":"%encode{%xThrowable{full}}{JSON}"}%n&lt;/Property&gt;
  &lt;/Properties&gt;
  &lt;Appenders&gt;
    &lt;Console name="Console" target="SYSTEM_OUT"&gt;
      &lt;PatternLayout pattern="${jsonLayout}"/&gt;
    &lt;/Console&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level="INFO"&gt;
      &lt;AppenderRef ref="Console"/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output messages look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{"severity":"INFO","logMessage":"Initializing ProtocolHandler [\"http-nio-46421\"]","logTimestamp":"2017-11-20T16:04:01,763","eventUUID":"8b998e17-7045-461c-8acb-c43f21d995ff","@version":"1","logger.name":"org.apache.coyote.http11.Http11NioProtocol","host.name":"TLND-RMANNIBUCAU","threadName":"main","stackTrace":""}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Rolling file appender:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0"?&gt;
&lt;Configuration status="INFO"&gt;
  &lt;Appenders&gt;
    &lt;RollingRandomAccessFile name="File" fileName="${LOG_PATH}/application.log" filePattern="${LOG_PATH}/application-%d{yyyy-MM-dd}.log"&gt;
      &lt;PatternLayout pattern="[%d{HH:mm:ss.SSS}][%highlight{%-5level}][%15.15t][%30.30logger] %msg%n"/&gt;
      &lt;Policies&gt;
        &lt;SizeBasedTriggeringPolicy size="100 MB" /&gt;
        &lt;TimeBasedTriggeringPolicy interval="1" modulate="true"/&gt;
      &lt;/Policies&gt;
    &lt;/RollingRandomAccessFile&gt;
  &lt;/Appenders&gt;
  &lt;Loggers&gt;
    &lt;Root level="INFO"&gt;
      &lt;AppenderRef ref="File"/&gt;
    &lt;/Root&gt;
  &lt;/Loggers&gt;
&lt;/Configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>More details are available in the <a href="https://logging.apache.org/log4j/2.x/manual/appenders.html#RollingFileAppender">RollingFileAppender</a> documentation.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can compose previous layout (message format) and appenders (where logs are written).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_docker"><a class="anchor" href="#_docker"></a>Docker</h4>
<div class="paragraph">
<p>The server image is deployed on Docker. Its version is suffixed with a timestamp to ensure images are not overridden and can break your usage. You can check the available version on Docker hub.</p>
</div>
<div class="sect4">
<h5 id="_run"><a class="anchor" href="#_run"></a>Run</h5>
<div class="paragraph">
<p>You can run the docker image by executing this command :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">$ sudo docker run -p 8080:8080 tacokit/component-starter</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configure"><a class="anchor" href="#_configure"></a>Configure</h5>
<div class="paragraph">
<p>You can set the env variable <code>_JAVA_OPTIONS</code> to customize the server, by default it is installed in <code>/opt/talend/component-kit</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_maven_repository"><a class="anchor" href="#_maven_repository"></a>Maven repository</h5>
<div class="paragraph">
<p>The maven repository is the default one of the machine, you can change it setting the system property <code>talend.component.server.maven.repository=/path/to/your/m2</code>.</p>
</div>
<div class="sect5">
<h6 id="_deploy_components_to_the_server"><a class="anchor" href="#_deploy_components_to_the_server"></a>Deploy components to the server</h6>
<div class="paragraph">
<p>If you want to deploy some components you can configure which ones in _JAVA_OPTIONS (see server doc online) and redirect your local m2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">$ docker run \
       -p 8080:8080 \
       -v ~/.m2:/root/.m2 \
       -e _JAVA_OPTIONS="-Dtalend.component.server.component.coordinates=g:a:v,g2:a2:v2,..." \
       component-server</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_logging_2"><a class="anchor" href="#_logging_2"></a>Logging</h5>
<div class="paragraph">
<p>The component server docker image comes with two log4j2 profiles: <code>TEXT</code> (default) and <code>JSON</code>.
The logging profile can be changed by setting the environment variable <code>LOGGING_LAYOUT</code> to <code>JSON</code>.</p>
</div>
<div class="paragraph">
<p>Note that Component Server adds to these default Talend profiles the <code>KAFKA</code> profile. With this profile, all logs are sent to Kafka.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can check the exact configuration in the <code>component-runtime/images/component-server-image/src/main/resources</code> folder.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_default_or_text_profile"><a class="anchor" href="#_default_or_text_profile"></a>default or TEXT profile</h6>
<div class="paragraph">
<p>The console logging is on at <code>INFO</code> level by default. You can customize it by setting the <code>CONSOLE_LOG_LEVEL</code> environment variable to <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code> or to any other log level supported by log4j2.</p>
</div>
<div class="paragraph">
<p>Run docker image with console logging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">sudo docker run -p 8080:8080 \
	-e CONSOLE_LOG_LEVEL=DEBUG \
	component-server</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_json_profile"><a class="anchor" href="#_json_profile"></a>JSON profile</h6>
<div class="paragraph">
<p>The JSON profile does the following:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Logs on the console using the <code>CONSOLE_LOG_LEVEL</code> configuration as the default profile. It uses the formatting shown below.</p>
</li>
<li>
<p>If the <code>TRACING_KAFKA_URL</code> environment variable is set, it logs the opentracing data on the defined Kafka using the topic <code>TRACING_KAFKA_TOPIC</code>. This level can be customized by setting the <code>KAFKA_LOG_LEVEL</code> environment variable (<code>INFO</code> by default).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Events are logged in the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
   "eventUUID":"%uuid{RANDOM}",
   "correlationId":"%X{traceId}",
   "spanId":"%X{spanId}",
   "traceId":"%X{traceId}",
   "category":"components",
   "eventType":"LOGEvent",
   "severity":"%level",
   "logMessage":"%encode{%message}{JSON}",
   "logSource":{
      "class.name":"%class",
      "file.name":"%file",
      "host.name":"%X{hostname}",
      "line.number":"%line",
      "logger.name":"%logger",
      "method.name":"%method",
      "process.id":"%pid"
   },
   "service":"${env:LOG_SERVICE_NAME:-component-server}",
   "application":"${env:LOG_APP_NAME:-component-server}",
   "exportable":"${env:LOG_EXPORTABLE:-true}",
   "audit":"${env:LOG_AUDIT:-false}",
   "logTimestamp":"%d{ISO8601}{UTC}",
   "serverTimestamp":"%d{ISO8601}{UTC}",
   "customInfo":{
      "threadName":"%encode{%thread}{JSON}",
      "stackTrace":"%encode{%xThrowable{full}}{JSON}"
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_kafka_profile"><a class="anchor" href="#_kafka_profile"></a>KAFKA profile</h6>
<div class="paragraph">
<p>This profile is very close to the JSON profile and also adds the <code>LOG_KAFKA_TOPIC</code> and <code>LOG_KAFKA_URL</code> configuration. The difference is that it logs the default logs on Kafka in addition to the tracing logs.</p>
</div>
</div>
<div class="sect5">
<h6 id="_opentracing"><a class="anchor" href="#_opentracing"></a>OpenTracing</h6>
<div class="paragraph">
<p>The component server uses Geronimo OpenTracing to monitor request.</p>
</div>
<div class="paragraph">
<p>The tracing can be activated by setting the <code>TRACING_ON</code> environment variable to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The tracing rate is configurable by setting the <code>TRACING_SAMPLING_RATE</code> environment variable.
It accepts <code>0</code> (none) and <code>1</code> (all, default) as values to ensure the consistency of the reporting.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can find all the details on the configuration in <code>org.talend.sdk.component.server.configuration.OpenTracingConfigSource</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Run docker image with tracing on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">sudo docker run -p 8080:8080 \
	-e TRACING_ON=true \
	tacokit/component-server</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, Geronimo OpenTracing will log the spans in a Zipking format so you can use the Kafka profile as explained before
to wire it over any OpenTracing backend.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_building_the_docker_image"><a class="anchor" href="#_building_the_docker_image"></a>Building the docker image</h5>
<div class="paragraph">
<p>You can register component server images in Docker using these instructions in the corresponding image directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh"># ex: cd images/component-server-image
mvn clean compile jib:dockerBuild</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_integrating_components_into_the_image"><a class="anchor" href="#_integrating_components_into_the_image"></a>Integrating components into the image</h5>
<div class="sect5">
<h6 id="_docker_compose"><a class="anchor" href="#_docker_compose"></a>Docker Compose</h6>
<div class="paragraph">
<p>Docker Compose allows you to deploy the server with components, by mounting the component volume
into the server image.</p>
</div>
<div class="paragraph">
<p><code>docker-compose.yml</code> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: '3.2'

services:
  component-server:
    healthcheck:
      timeout: 3s
      interval: 3s
      retries: 3
      test: curl --fail http://localhost:1234/api/v1/environment
    image: tacokit/component-server:${COMPONENT_SERVER_IMAGE:-1.1.2_20181108161652}
    command: --http=1234
    environment:
    - CONSOLE_LOG_LEVEL=INFO
    - _JAVA_OPTIONS=
        -Xmx1024m
        -Dtalend.component.server.component.registry=/opt/talend/connectors/component-registry.properties
        -Dtalend.component.server.maven.repository=/opt/talend/connectors
    ports:
    - 1234:1234/tcp
    volumes:
    - type: bind
      read_only: true
      source: ${CONNECTORS_REPOSITORY}
      target: /opt/talend/connectors
      volume:
        nocopy: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to mount it from another image, you can use this compose configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: '3.2'

services:
  component-server:
    healthcheck:
      timeout: 3s
      interval: 3s
      retries: 3
      test: curl --fail http://localhost:1234/api/v1/environment
    image: tacokit/component-server:${COMPONENT_SERVER_IMAGE_VERSION}
    command: --http=1234
    environment:
    - _JAVA_OPTIONS=
        -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005
        -Djava.library.path=/opt/talend/component-kit/work/sigar/sigar:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib
        -Xmx1024m
        -Dtalend.component.server.component.registry=/opt/talend/connectors/component-registry.properties
        -Dtalend.component.server.maven.repository=/opt/talend/connectors
    ports:
    - 1234:1234/tcp
    - 5005:5005/tcp
    volumes:
    - connectors:/opt/talend/connectors:ro

  connectors:
    image: talend/connectors:${CONNECTORS_VERSION}
    environment:
    - CONNECTORS_SETUP_OPTS=setup --wait-for-end --component-jdbc-auto-download-drivers
    volumes:
    - connectors:/opt/talend/connectors:ro


volumes:
  connectors:</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run one of the previous compose examples, you can use <code>docker-compose -f docker-compose.yml up</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Only use the configuration related to port <code>5005</code> (in <code>ports</code> and the <code>-agentlib</code> option in <code>_JAVA_OPTIONS</code>) to debug the server on port <code>5005</code>. <strong>Don&#8217;t</strong> set it in <strong>production</strong>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_adding_extensions_to_the_server"><a class="anchor" href="#_adding_extensions_to_the_server"></a>Adding extensions to the server</h5>
<div class="paragraph">
<p>You can mount a volume in <code>/opt/talend/component-kit/custom/</code> and the jars in that folder which will be deployed with the server.
Since the server relies on CDI (Apache OpenWebBeans) you can use that technology to enrich it, including JAX-RS endpoints, interceptors etc&#8230;&#8203;or just libraries needing to be in the JVM.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_component_server_vault_proxy"><a class="anchor" href="#_component_server_vault_proxy"></a>Component Server Vault Proxy</h3>
<div class="paragraph">
<p>Browse the API description using <a href="rest-openapi-vault.html" class="page">OpenAPI</a>.</p>
</div>
<div class="paragraph">
<p>A Vault proxy dedicated to the component server allows to safely manage credential encryption when operating in a Cloud environment.</p>
</div>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tacokit_vault_proxy.png" target="_blank" rel="noopener"><img src="_images/tacokit_vault_proxy.png" alt="Vault proxy"></a></span></p>
</div>
<div class="paragraph">
<p>The Vault Proxy only concerns data marked as <code>@Credential</code> in the <a href="tutorial-configuration-sensitive-data.html" class="page">component configuration</a>.</p>
</div>
<div class="paragraph">
<p>This Vault proxy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>receives an encrypted payload containing sensitive data from the remote engine, via HTTP.</p>
</li>
<li>
<p>decrypts the data</p>
</li>
<li>
<p>caches in memory the decrypted value of the data for performance reasons.</p>
</li>
<li>
<p>sends unencrypted data to the component server using HTTPS. An SSL certificate can be automatically generated and secures the data.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_vault_proxy_configuration"><a class="anchor" href="#_vault_proxy_configuration"></a>Vault proxy configuration</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
the configuration is read from system properties, environment variables, &#8230;&#8203;.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">talend.vault.cache.client.certificate.acceptAny</dt>
<dd>
<p>Default value: <code>false</code>. Should any certificate be accepted - only for dev purposes.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.executor.server.core</dt>
<dd>
<p>Default value: <code>64</code>. Thread pool core size for Component Server client.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.executor.server.keepAlive</dt>
<dd>
<p>Default value: <code>60000</code>. Thread keep alive (in ms) for Component Server client thread pool.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.executor.server.max</dt>
<dd>
<p>Default value: <code>256</code>. Thread pool max size for Component Server client.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.executor.vault.core</dt>
<dd>
<p>Default value: <code>64</code>. Thread pool core size for Vault client.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.executor.vault.keepAlive</dt>
<dd>
<p>Default value: <code>60000</code>. Thread keep alive (in ms) for Vault client thread pool.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.executor.vault.max</dt>
<dd>
<p>Default value: <code>256</code>. Thread pool max size for Vault client.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.providers</dt>
<dd>
<p>JAX-RS fully qualified name of the provides (message body readers/writers) for vault and component-server clients.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.server.authorization</dt>
<dd>
<p>The token to use to call component-server if any.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.server.certificate.keystore.location</dt>
<dd>
<p>Where the keystore to use to connect to Component Server is located.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.server.certificate.keystore.password</dt>
<dd>
<p>Default value: <code>changeit</code>. The keystore password for <code>talend.vault.cache.client.server.certificate.keystore.location</code>.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.server.certificate.keystore.type</dt>
<dd>
<p>The keystore type for <code>talend.vault.cache.client.server.certificate.keystore.location</code>.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.server.certificate.truststore.type</dt>
<dd>
<p>The truststore type for <code>talend.vault.cache.client.server.certificate.keystore.location</code>.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.server.hostname.accepted</dt>
<dd>
<p>Default value: <code>localhost,127.0.0.1,0:0:0:0:0:0:0:1</code>. Valid hostnames for the Component Server certificates (see <code>java.net.ssl.HostnameVerifier</code>).</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.timeout.connect</dt>
<dd>
<p>Default value: <code>30000</code>. HTTP connection timeout to vault server.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.timeout.read</dt>
<dd>
<p>Default value: <code>30000</code>. HTTP read timeout to vault server.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.vault.certificate.keystore.location</dt>
<dd>
<p>Where the keystore to use to connect to vault is located.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.vault.certificate.keystore.password</dt>
<dd>
<p>Default value: <code>changeit</code>. The keystore password for <code>talend.vault.cache.client.vault.certificate.keystore.location</code>.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.vault.certificate.keystore.type</dt>
<dd>
<p>The keystore type for <code>talend.vault.cache.client.vault.certificate.keystore.location</code>.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.vault.certificate.truststore.type</dt>
<dd>
<p>The truststore type for <code>talend.vault.cache.client.vault.certificate.keystore.location</code>.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.client.vault.hostname.accepted</dt>
<dd>
<p>Default value: <code>localhost,127.0.0.1,0:0:0:0:0:0:0:1</code>. Valid hostnames for the Vault certificates (see <code>java.net.ssl.HostnameVerifier</code>).</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.cache.expiry</dt>
<dd>
<p>Default value: <code>3600</code>. JCache expiry for decrypted values (ms).</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.cache.management</dt>
<dd>
<p>Default value: <code>false</code>. Should JCache MBeans be registered.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.cache.statistics</dt>
<dd>
<p>Default value: <code>false</code>. Should JCache statistics be enabled.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.manager.properties</dt>
<dd>
<p>Default value: <code>`. JCache `CacheManager</code> properties used to initialized the instance.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.manager.uri</dt>
<dd>
<p>Default value: <code>geronimo://simple-jcache.properties</code>. Configuration for JCache setup, default implementation is Geronimo Simple Cache.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.maxCacheSize</dt>
<dd>
<p>Default value: <code>100000</code>. JCache max size per cache.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.jcache.refresh.period</dt>
<dd>
<p>Default value: <code>30000</code>. How often (in ms) the Component Server should be checked to invalidate the caches on the component parameters (to identify credentials).</p>
</dd>
<dt class="hdlist1">talend.vault.cache.security.allowedIps</dt>
<dd>
<p>Default value: <code>localhost,127.0.0.1,0:0:0:0:0:0:0:1</code>. The IP or hosts allowed to call that server on <code>/api/*</code> if no token is passed.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.security.hostname.sanitizer</dt>
<dd>
<p>Default value: <code>none</code>. Enable to sanitize the hostname before testing them. Default to <code>none</code> which is a noop. Supported values are <code>docker</code> (for <code>&lt;folder&gt;_&lt;service&gt;_&lt;number&gt;.&lt;folder&gt;_&lt;network&gt;</code> pattern) and <code>weave</code> (for <code>&lt;prefix&gt;_dataset_&lt;number&gt;.&lt;suffix&gt;</code> pattern).</p>
</dd>
<dt class="hdlist1">talend.vault.cache.security.tokens</dt>
<dd>
<p>Default value: <code>-</code>. The tokens enabling a client to call this server without being in <code>allowedIp</code> whitelist.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.service.auth.cantDecipherStatusCode</dt>
<dd>
<p>Default value: <code>422</code>. Status code sent when vault can&#8217;t decipher some values.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.service.auth.refreshDelayMargin</dt>
<dd>
<p>Default value: <code>600000</code>. How often (in ms) to refresh the vault token.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.service.auth.refreshDelayOnFailure</dt>
<dd>
<p>Default value: <code>10000</code>. How often (in ms) to refresh the vault token in case of an authentication failure.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.service.decipher.skip.regex</dt>
<dd>
<p>Default value: <code>vault\:v[0-9]+\:.*</code>. The regex to whitelist ciphered keys, others will be passthrough in the output without going to vault.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.talendComponentKit.url</dt>
<dd>
<p>Base URL to connect to Component Server</p>
</dd>
<dt class="hdlist1">talend.vault.cache.vault.auth.endpoint</dt>
<dd>
<p>Default value: <code>v1/auth/engines/login</code>. The vault path to retrieve a token.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.vault.auth.roleId</dt>
<dd>
<p>Default value: <code>-</code>. The vault role identifier to use to log in (if token is not set). <code>-</code> means it is ignored.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.vault.auth.secretId</dt>
<dd>
<p>Default value: <code>-</code>. The vault secret identifier to use to log in (if token is not set). <code>-</code> means it is ignored.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.vault.auth.token</dt>
<dd>
<p>Default value: <code>-</code>. The vault token to use to log in (will make roleId and secretId ignored). <code>-</code> means it is ignored.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.vault.decrypt.endpoint</dt>
<dd>
<p>Default value: <code>v1/tenants-keyrings/decrypt/{x-talend-tenant-id}</code>. The vault path to decrypt values. You can use the variable <code>{x-talend-tenant-id}</code> to replace by <code>x-talend-tenant-id</code> header value.</p>
</dd>
<dt class="hdlist1">talend.vault.cache.vault.url</dt>
<dd>
<p>Base URL to connect to Vault.</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="_configuration_mechanism_2"><a class="anchor" href="#_configuration_mechanism_2"></a>Configuration mechanism</h5>
<div class="paragraph">
<p>The configuration uses Microprofile Config for most entries. It means it can be passed through system properties and environment variables (by replacing dots with underscores and making the keys uppercase).</p>
</div>
<div class="paragraph">
<p>To configure a Docker image rather than a standalone instance, Docker Config and secrets integration allows you to read the configuration from files. You can customize the configuration of these integrations through system properties.</p>
</div>
<div class="paragraph">
<p>Docker integration provides a <code>secure:</code> support to encrypt values and  system properties, when required.</p>
</div>
<div class="paragraph">
<p>It is fully implemented using the <a href="http://geronimo.apache.org/microprofile/extensions.html">Apache Geronimo Microprofile Config</a> extensions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_the_vault_proxy_to_your_docker_compose"><a class="anchor" href="#_adding_the_vault_proxy_to_your_docker_compose"></a>Adding the Vault Proxy to your Docker Compose</h4>
<div class="paragraph">
<p>The YAML below is the recommended configuration to enable the Vault Proxy and Component Server to communicate over HTTPS.</p>
</div>
</div>
<div class="sect3">
<h4 id="_docker_compose_2"><a class="anchor" href="#_docker_compose_2"></a>Docker Compose</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: '3.2'

services:
  component-server: <i class="conum" data-value="1"></i><b>(1)</b>
    healthcheck:
      timeout: 3s
      interval: 3s
      retries: 3
      test: curl --fail http://localhost:8080/api/v1/environment
    image: tacokit/component-server:${COMPONENT_SERVER_IMAGE_VERSION:-1.1.6_20190208104207}
    environment:
    - _JAVA_OPTIONS=
        -Dtalend.component.server.filter.secured.tokens=vault-proxy <i class="conum" data-value="2"></i><b>(2)</b>
        -Dtalend.component.server.ssl.active=true <i class="conum" data-value="3"></i><b>(3)</b>
        -Dtalend.component.server.ssl.keystore.location=/opt/talend/configuration/https.p12 <i class="conum" data-value="3"></i><b>(3)</b>
        -Dtalend.component.server.ssl.keystore.type=PKCS12 <i class="conum" data-value="3"></i><b>(3)</b>
        -Dtalend.component.server.component.registry=/opt/talend/connectors/component-registry.properties <i class="conum" data-value="4"></i><b>(4)</b>
        -Dtalend.component.server.maven.repository=/opt/talend/connectors <i class="conum" data-value="4"></i><b>(4)</b>
    volumes:
    - connectors:/opt/talend/connectors:ro  <i class="conum" data-value="4"></i><b>(4)</b>
    - vault-proxy-configuration:/opt/talend/configuration <i class="conum" data-value="3"></i><b>(3)</b>


  component-server-vault-proxy: <i class="conum" data-value="5"></i><b>(5)</b>
    healthcheck:
      timeout: 3s
      interval: 3s
      retries: 3
      test: curl --fail http://localhost:8080/api/v1/proxy/environment
    image: tacokit/component-server-vault-proxy:${COMPONENT_SERVER_VAULT_PROXY_IMAGE_VERSION:-1.1.6_20190208104221}
    environment:
    - _JAVA_OPTIONS=
        -Dtalend.vault.cache.client.server.certificate.keystore.location=/opt/talend/configuration/https.p12 <i class="conum" data-value="6"></i><b>(6)</b>
        -Dtalend.vault.cache.client.server.certificate.keystore.type=PKCS12 <i class="conum" data-value="6"></i><b>(6)</b>
        -Dtalend.vault.cache.client.server.hostname.accepted=component-server <i class="conum" data-value="6"></i><b>(6)</b>
        -Dtalend.vault.cache.client.server.authorization=vault-proxy <i class="conum" data-value="7"></i><b>(7)</b>
        -Dtalend.vault.cache.talendComponentKit.url=https://component-server:8080/api/v1 <i class="conum" data-value="7"></i><b>(7)</b>
        -Dtalend.vault.cache.vault.url=http://vault:8200 <i class="conum" data-value="8"></i><b>(8)</b>
        -Dtalend.vault.cache.vault.auth.roleId=myrole <i class="conum" data-value="8"></i><b>(8)</b>
        -Dtalend.vault.cache.vault.decrypt.endpoint=v1/something/decrypt/00000001 <i class="conum" data-value="8"></i><b>(8)</b>
        -Dtalend.vault.cache.security.allowedIps=${COMPONENT_SERVER_VAULT_PROXY_CLIENT_IP:-127.0.0.1} <i class="conum" data-value="9"></i><b>(9)</b>
    ports:
    - 9090:8080/tcp
    links: <i class="conum" data-value="10"></i><b>(10)</b>
    - "component-server:component-server"
    # - "vault:vault"
    volumes:
    - vault-proxy-configuration:/opt/talend/configuration:ro

  connectors: <i class="conum" data-value="11"></i><b>(11)</b>
    image: registry.datapwn.com/talend/connectors:${CONNECTORS_IMAGE_VERSION:-1.0.0_master_20190208091312}
    environment:
    - CONNECTORS_SETUP_OPTS=setup --wait-for-end
    volumes:
    - connectors:/opt/talend/connectors:ro

volumes: <i class="conum" data-value="12"></i><b>(12)</b>
  connectors:
  vault-proxy-configuration:</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The standard Component Server entry.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Ensures only a client with a particular token can call the server. It is similar to a shared secret and only allows to call the server in "remote" mode, since only the local mode is enabled by default.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Activates and configures the auto generation of a X.509 certificate which is used for the HTTPS connector on the server.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Binds the components to deploy into the server.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Definition of the Vault proxy service which handles the mediation between Vault and the Component Server.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Since both servers are colocalized, the generated certificate is inherited from the Component Server, which allows to create the client that connects to it.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Configuration of the base URL to connect to the server - see &lt;10&gt;.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Configuration of the vault connection and security information.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Ensuring that connecting from <code>$COMPONENT_SERVER_VAULT_PROXY_CLIENT_IP</code> to vault proxy is possible. Any other IP will be rejected.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Linking both services so they can communicate. It allows not to expose the Component Server port outside of its own container (no <code>ports</code> mapping in the Component Server service definition). Note that if your vault is a service, you can link it here as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Common component image service definition.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Volumes used by the services. The <code>connectors</code> has not changed but  <code>vault-proxy-configuration</code> was added for the automatic HTTPS configuration.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This setup enables the Vault Proxy and Component Server to communicate. You can now use the Vault Proxy as if it was the Component Server, by using <code><a href="http://localhost:9090" class="bare">localhost:9090</a></code> (or any other host matching your deployment) instead of the Component Server directly.</p>
</div>
</div>
<div class="sect3">
<h4 id="_linking_the_vault_proxy_to_the_component_server_through_https"><a class="anchor" href="#_linking_the_vault_proxy_to_the_component_server_through_https"></a>Linking the Vault Proxy to the Component Server through HTTPS</h4>
<div class="paragraph">
<p>When the Vault Proxy is enabled, ensure you configure HTTPS on the Component Server using the following parameters:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">talend.component.server.ssl.active</dt>
<dd>
<p><code>true</code> or <code>false</code>. Indicates if the SSL protocol is enabled.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.password</dt>
<dd>
<p>Keystore password.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keystore.location</dt>
<dd>
<p>Path to Keystore.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keystore.alias</dt>
<dd>
<p>Private key/certificate alias.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keystore.type</dt>
<dd>
<p>Keystore type.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keystore.generation.force</dt>
<dd>
<p><code>true</code> or <code>false</code>.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keystore.generation.command</dt>
<dd>
<p>Specifies if a custom command is to be used to generate the certificate.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keypair.algorithm</dt>
<dd>
<p>Encryption algorithm. <code>RSA</code> by default.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.certificate.dname</dt>
<dd>
<p>Distinguished name.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.keypair.size</dt>
<dd>
<p>Size of the key. <code>2048</code> by default.</p>
</dd>
<dt class="hdlist1">talend.component.server.ssl.port</dt>
<dd>
<p>SSL port to use.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_adding_extensions_to_the_instance"><a class="anchor" href="#_adding_extensions_to_the_instance"></a>Adding extensions to the instance</h4>
<div class="paragraph">
<p>You can mount a volume in <code>/opt/talend/component-kit-vault-proxy/custom/</code> and the jars in that folder which will be deployed with the server.
Since the server relies on CDI (Apache OpenWebBeans) you can use that technology to enrich it, including JAX-RS endpoints, interceptors etc&#8230;&#8203;or just libraries needing to be in the JVM.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 relatedlinks">
<h2 id="_tutorials"><a class="anchor" href="#_tutorials"></a>Tutorials</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_creating_your_first_component_2"><a class="anchor" href="#_creating_your_first_component_2"></a>Creating your first component</h3>
<div class="paragraph">
<p>This tutorial walks you through all the required steps to get started with <strong>Talend Component Kit</strong>, from the creation of a simple component to its integration into <strong>Talend Open Studio</strong>.</p>
</div>
<div class="paragraph">
<p>The component created in this tutorial is a simple processor component that receives data from the previous component and displays it in the logs, along with an extra information entered by a user.</p>
</div>
<div class="paragraph">
<p>Once the prerequisites completed, this tutorial should take you about 20 minutes.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The component designed in this tutorial is a processor and does not require nor show any <a href="component-configuration.html#dataset-and-datastore" class="page">datastore and dataset</a> configuration. Datasets and datastores are required only for input and output components.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
<div class="sect3">
<h4 id="_prerequisites_2"><a class="anchor" href="#_prerequisites_2"></a>Prerequisites</h4>
<div class="paragraph">
<p>This tutorial aims at helping you to create your very first component. But before, get your development environment ready:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Download and install a Java JDK 1.8 or greater.</p>
</li>
<li>
<p>Download and install Talend Open Studio. For example, from <a href="https://sourceforge.net/projects/talend-studio">Sourceforge</a>.</p>
</li>
<li>
<p>Download and install <a href="https://www.jetbrains.com/idea/download">IntelliJ</a>.</p>
</li>
<li>
<p>Download the Talend Component Kit plugin for IntelliJ. The detailed installation steps for the plugin are available in <a href="installing-talend-intellij-plugin.html" class="page">this document</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_generating_a_simple_component_project_2"><a class="anchor" href="#_generating_a_simple_component_project_2"></a>Generating a simple component project</h4>
<div class="paragraph">
<p>The first step in this tutorial is to generate a project containing a simple output component using the <strong>Starter</strong> included in the Talend Component Kit plugin for IntelliJ.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start IntelliJ and create a new project. In the available options, you should see <strong>Talend Component</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij_new_component_project.png" target="_blank" rel="noopener"><img src="_images/intellij_new_component_project.png" alt="New project"></a>
</div>
</div>
</li>
<li>
<p>Make sure that a <strong>Project SDK</strong> is selected. Then, select <strong>Talend Component</strong> and click <strong>Next</strong>.<br>
The <strong>Talend Component Kit Starter</strong> opens.</p>
</li>
<li>
<p>Enter the project details. The goal here is to define the component and project metadata. Change the default values as follows:<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/intellij_tutorial_project_metadata.png" target="_blank" rel="noopener"><img src="_images/intellij_tutorial_project_metadata.png" alt="Project metadata"></a>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The <strong>Component Family</strong> and the <strong>Category</strong> will be used later in Talend Open Studio to find the new component.</p>
</li>
<li>
<p>The project metadata are mostly used to identify the project structure. A common practice is to replace 'company' in the default value by a value of your own, like your domain name.<br></p>
</li>
</ul>
</div>
</li>
<li>
<p>Once the metadata is filled, select <strong>Add a component</strong>. A new screen is displayed in the <strong>Talend Component Kit Starter</strong> that lets you define the generic configuration of the component. By default, new components are processors,</p>
</li>
<li>
<p>Enter a valid Java name for the component. For example, <strong>Logger</strong>.</p>
</li>
<li>
<p>Select <strong>Configuration Model</strong> and add a string field named <code>level</code>. This input field will be used in the component configuration to enter additional information to display in the logs.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_component_configuration_model.png" target="_blank" rel="noopener"><img src="_images/tutorial_component_configuration_model.png" alt="Configuration Model"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Input(s) / Output(s)</strong> section, click the default <strong>MAIN</strong> input branch to access its detail, and make sure that the record model is set to <strong>Generic</strong>. Leave the <strong>Name</strong> of the branch with its default <code>MAIN</code> value.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_component_generic_input.png" target="_blank" rel="noopener"><img src="_images/tutorial_component_generic_input.png" alt="Generic Input"></a>
</div>
</div>
</li>
<li>
<p>Repeat the same step for the default <strong>MAIN</strong> output branch.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because the component is a processor, it has an output branch by default. A processor without any output branch is considered an output component. You can create output components when the <strong>Activate IO</strong> option is selected.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Click <strong>Next</strong> and check the name and location of your project, then click <strong>Finish</strong> to generate the project in the IDE.<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point, your component is technically already ready to be compiled and deployed to Talend Open Studio. But first, have a look at the generated project:</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_generated_project_view.png" target="_blank" rel="noopener"><img src="_images/tutorial_generated_project_view.png" alt="Project view"></a>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Two classes based on the name and type of component defined in the <strong>Talend Component Kit Starter</strong> have been generated:</p>
<div class="ulist">
<ul>
<li>
<p><strong>LoggerProcessor</strong> is where the component logic is defined</p>
</li>
<li>
<p><strong>LoggerProcessorConfiguration</strong> is where the component layout and configurable fields are defined, including the <strong>level</strong> string field that was defined earlier in the configuration model of the component.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <strong>package-info.java</strong> file contains the component metadata defined in the <strong>Talend Component Kit Starter</strong>, like the family and category.</p>
</li>
<li>
<p>You can notice as well that the elements in the tree structure are named after the project metadata defined in the <strong>Talend Component Kit Starter</strong>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These files are the starting point if you later need to edit the configuration, logic, and metadata of your component.</p>
</div>
<div class="paragraph">
<p>There is more that you can do and configure with the <strong>Talend Component Kit Starter</strong>. This tutorial covers only the basics. You can find more information in <a href="tutorial-generate-project-using-starter.html" class="page">this document</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_and_deploying_the_component_to_talend_open_studio_2"><a class="anchor" href="#_compiling_and_deploying_the_component_to_talend_open_studio_2"></a>Compiling and deploying the component to Talend Open Studio</h4>
<div class="paragraph">
<p>Without any modification in the component code, you can compile the project and deploy the component to a local instance of Talend Open Studio.</p>
</div>
<div class="paragraph">
<p>This way, it will be easy to check that what is visible in the Studio is what is intended.</p>
</div>
<div class="paragraph">
<p>Before starting to run any command, make sure Talend Open Studio is not running.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>From your component project in IntelliJ, open a terminal and make sure that the selected directory is the root of the project. All commands shown in this tutorial are performed from this location.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_intellij_terminal_blank.png" target="_blank" rel="noopener"><img src="_images/tutorial_intellij_terminal_blank.png" alt="Compile terminal"></a>
</div>
</div>
</li>
<li>
<p>Compile the project by running the following command: <code>mvnw clean install</code>.<br>
The <code>mvnw</code> command refers to the Maven wrapper that is shipped with Talend Component Kit. It allows to use the right version of Maven for your project without having to install it manually beforehand. An equivalent wrapper is available for Gradle.</p>
</li>
<li>
<p>Once the command is executed and you see <strong>BUILD SUCCESS</strong> in the terminal, deploy the component to your local instance of Talend Open Studio using the following command:<br>
<code>mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;path to Talend Open Studio home&gt;"</code><br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Replace the path by your own value. If the path contains spaces (for example, <code>Program Files</code>), enclose it with double quotes.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Make sure the build is successful.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_deploy_in_studio_success.png" target="_blank" rel="noopener"><img src="_images/tutorial_deploy_in_studio_success.png" alt="Build success"></a>
</div>
</div>
</li>
<li>
<p>Open Talend Open Studio and create a new Job:</p>
<div class="ulist">
<ul>
<li>
<p>The new component is present inside the new family and category that were specified in the <strong>Talend Component Kit Starter</strong>. You can add it to your job and open its settings.</p>
</li>
<li>
<p>Notice that the <strong>level</strong> field that was specified in the configuration model of the component in the <strong>Talend Component Kit Starter</strong> is present.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_first_component_in_studio.png" target="_blank" rel="noopener"><img src="_images/tutorial_first_component_in_studio.png" alt="Component in Studio"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point, your new component is available in Talend Open Studio, and its configurable part is already set. But the component logic is still to be defined.<br></p>
</div>
</div>
<div class="sect3">
<h4 id="_editing_the_component_2"><a class="anchor" href="#_editing_the_component_2"></a>Editing the component</h4>
<div class="paragraph">
<p>You can now edit the component to implement a simple logic: reading the data contained in the input branch of the component to display it the execution logs of the job. The value of the <strong>level</strong> field of the component also needs to be displayed and changed to uppercase.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Save the job created earlier and close Talend Open Studio.</p>
</li>
<li>
<p>Back in IntelliJ open the <strong>LoggerProcessor</strong> class. This is the class where the component logic can be defined.</p>
</li>
<li>
<p>Look for the <code>@ElementListener</code> method. It is already present and references the default input branch that was defined in the <strong>Talend Component Kit Starter</strong>, but it is not complete yet.</p>
</li>
<li>
<p>To be able to log the data in input to the console, add the following lines:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//Log to the console
        System.out.println("["+configuration.getLevel().toUpperCase()+"] "+defaultInput);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ElementListener</code> method now looks as follows:<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ElementListener
    public void onNext(
            @Input final Record defaultInput) {
        // this is the method allowing you to handle the input(s) and emit the output(s)
        // after some custom logic you put here, to send a value to next element you can use an
        // output parameter and call emit(value).

        //Log to the console
        System.out.println("["+configuration.getLevel().toUpperCase()+"] "+defaultInput);
    }</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="5">
<li>
<p>Open the Terminal again to compile the project and deploy the component again. To do that, run successively the two following commands:</p>
<div class="ulist">
<ul>
<li>
<p><code>mvnw clean install</code></p>
</li>
<li>
<p><code>`mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome="&lt;path to Talend Open Studio home&gt;"</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The update of the component logic should now be deployed to the Studio. After restarting the Studio, you will be ready to build a job and use your component for the first time.</p>
</div>
<div class="paragraph">
<p>To learn the different possibilities and methods available to develop more complex logics, refer to <a href="component-define-processor-output.html" class="page">this document</a>.</p>
</div>
<div class="paragraph">
<p>If you want to avoid having to close and re-open Talend Open Studio every time you need to make an edit, you can enable the developer mode, as explained in <a href="studio.html#developer-mode" class="page">this document</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_building_a_job_with_the_component_2"><a class="anchor" href="#_building_a_job_with_the_component_2"></a>Building a job with the component</h4>
<div class="paragraph">
<p>As the component is now ready to be used, it is time to create a job and check that it behaves as intended.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open Talend Open Studio again and go to the job created earlier. The new component is still there.</p>
</li>
<li>
<p>Add a <strong>tRowGenerator</strong> component and connect it to the logger.</p>
</li>
<li>
<p>Double-click the <strong>tRowGenerator</strong> to specify the data to generate:</p>
<div class="ulist">
<ul>
<li>
<p>Add a first column named <code>firstName</code> and select the <strong>TalendDataGenerator.getFirstName()</strong> function.</p>
</li>
<li>
<p>Add a second column named 'lastName' and select the <strong>TalendDataGenerator.getLastName()</strong> function.</p>
</li>
<li>
<p>Set the <strong>Number of Rows for RowGenerator</strong> to <code>10</code>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_trowgenerator.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_trowgenerator.png" alt="tRowGenerator"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Validate the <strong>tRowGenerator</strong> configuration.</p>
</li>
<li>
<p>Open the <strong>TutorialFamilyLogger</strong> component and set the <strong>level</strong> field to <code>info</code>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_logger.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_logger.png" alt="Logger"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>Run</strong> tab of the job and run the job.<br>
The job is executed. You can observe in the console that each of the 10 generated rows is logged, and that the <code>info</code> value entered in the logger is also displayed with each record, in uppercase.</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/tutorial_build_job_run.png" target="_blank" rel="noopener"><img src="_images/tutorial_build_job_run.png" alt="Job run"></a>
</div>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_33"><a class="anchor" href="#_related_articles_33"></a>Related articles</h4>
<div class="paragraph">
<p>To go further and start implementing more complex components, you can refer to the following documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology for creating components</a></p>
</li>
<li>
<p><a href="tutorial-generate-project-using-starter.html" class="page">Generating a project using the Talend Component Kit Starter</a></p>
</li>
<li>
<p><a href="component-registering.html" class="page">Registering a component</a></p>
</li>
<li>
<p><a href="component-execution.html" class="page">General component execution logic</a></p>
</li>
<li>
<p><a href="component-configuration.html" class="page">Configuring a component</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component logic</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor/output logic</a></p>
</li>
<li>
<p><a href="component-internationalization.html" class="page">Internationalizing a component</a></p>
</li>
<li>
<p><a href="tutorial-configuration-sensitive-data.html" class="page">Masking sensitive data</a></p>
</li>
<li>
<p><a href="best-practices.html" class="page">Best practices</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_generating_a_project_using_the_component_kit_starter_2"><a class="anchor" href="#_generating_a_project_using_the_component_kit_starter_2"></a>Generating a project using the Component Kit Starter</h3>
<div id="tutorial-generate-project-using-starter" class="paragraph">
<p>The Component Kit starter lets you design your components configuration and generates a ready-to-implement project structure.</p>
</div>
<div class="paragraph">
<p>The starter is available on the web or as an <a href="generate-project-using-intellij-plugin.html" class="page">IntelliJ plugin</a>.</p>
</div>
<div class="paragraph">
<p>This tutorial shows you how to use the Component Kit Starter to generate new components for MySQL databases. Before starting, make sure that you have correctly setup your environment. See <a href="system-prerequisites.html" class="page">this section</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When defining a project using the Starter, do not refresh the page to avoid losing your configuration.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_configuring_the_project_2"><a class="anchor" href="#_configuring_the_project_2"></a>Configuring the project</h4>
<div class="paragraph">
<p>Before being able to create components, you need to define the general settings of the project:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a folder on your local machine to store the resource files of the component you want to create. For example, <code>C:/my_components</code>.</p>
</li>
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Select your build tool. This tutorial uses Maven, but you can select Gradle instead.</p>
</li>
<li>
<p>Add any facet you need. For example, add the <strong>Talend Component Kit Testing</strong> facet to your project to automatically generate unit tests for the components created in the project.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_test_facet.png" target="_blank" rel="noopener"><img src="_images/starter/starter_test_facet.png" alt="Test facet"></a>
</div>
</div>
</li>
<li>
<p>Enter the <strong>Component Family</strong> of the components you want to develop in the project. This name must be a valid java name and is recommended to be capitalized, for example 'MySQL'.<br>
Once you have implemented your components in the Studio, this name is displayed in the Palette to group all of the MySQL-related components you develop, and is also part of your component name.</p>
</li>
<li>
<p>Select the <strong>Category</strong> of the components you want to create in the current project. As MySQL is a kind of database, select <strong>Databases</strong> in this tutorial.<br>
This <strong>Databases</strong> category is used and displayed as the parent family of the MySQL group in the Palette of the Studio.</p>
</li>
<li>
<p>Complete the project metadata by entering the <strong>Group</strong>, <strong>Artifact</strong> and <strong>Package</strong>.</p>
</li>
<li>
<p>By default, you can only create <strong>processors</strong>. If you need to create <strong>Input</strong> or <strong>Output</strong> components, select <strong>Activate IO</strong>. By doing this:</p>
<div class="ulist">
<ul>
<li>
<p>Two new menu entries let you add datasets and datastores to your project, as they are required for input and output components.<br></p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Input and Output components without dataset (itself containing a datastore) will not pass the validation step when building the components. Learn more about datasets and datastores in <a href="component-configuration.html#dataset-and-datastore" class="page">this document</a>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>An Input component and an Output component are automatically added to your project and ready to be configured.</p>
</li>
<li>
<p>Components added to the project using <strong>Add A Component</strong> can now be processors, input or output components.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_activate_io.png" target="_blank" rel="noopener"><img src="_images/starter/starter_activate_io.png" alt="Activate IO"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_datastore_4"><a class="anchor" href="#_defining_a_datastore_4"></a>Defining a Datastore</h4>
<div class="paragraph">
<p>A datastore represents the data needed by an input or output component to connect to a database.</p>
</div>
<div class="paragraph">
<p>When building a component, the <code>validateDataSet</code> validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.</p>
</div>
<div class="paragraph">
<p>You can define one or several datastores if you have selected the <strong>Activate IO</strong> step.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Datastore</strong>. The list of datastores opens. By default, a datastore is already open but not configured. You can configure it or create a new one using <strong>Add new Datastore</strong>.</p>
</li>
<li>
<p>Specify the name of the datastore. Modify the default value to a meaningful name for your project.<br>
This name must be a valid Java name as it will represent the datastore class in your project. It is a good practice to start it with an uppercase letter.</p>
</li>
<li>
<p>Edit the datastore configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes connection details to a database:</p>
<div class="ulist">
<ul>
<li>
<p>url</p>
</li>
<li>
<p>username</p>
</li>
<li>
<p>password.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Save</strong> the datastore configuration.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_dataset_4"><a class="anchor" href="#_defining_a_dataset_4"></a>Defining a Dataset</h4>
<div class="paragraph">
<p>A dataset represents the data coming from or sent to a database and needed by input and output components to operate.</p>
</div>
<div class="paragraph">
<p>The <code>validateDataSet</code> validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.</p>
</div>
<div class="paragraph">
<p>You can define one or several datasets if you have selected the <strong>Activate IO</strong> step.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select <strong>Dataset</strong>. The list of datasets opens. By default, a dataset is already open but not configured. You can configure it or create a new one using the <strong>Add new Dataset</strong> button.</p>
</li>
<li>
<p>Specify the name of the dataset. Modify the default value to a meaningful name for your project.<br>
This name must be a valid Java name as it will represent the dataset class in your project. It is a good practice to start it with an uppercase letter.</p>
</li>
<li>
<p>Edit the dataset configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes details of the data to retrieve:</p>
<div class="ulist">
<ul>
<li>
<p>Datastore to use (that contains the connection details to the database)</p>
</li>
<li>
<p>table name</p>
</li>
<li>
<p>data</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Save</strong> the dataset configuration.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_creating_an_input_component_2"><a class="anchor" href="#_creating_an_input_component_2"></a>Creating an Input component</h4>
<div class="paragraph">
<p>To create an input component, make sure you have selected <strong>Activate IO</strong>.</p>
</div>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.<br>
The intent in this tutorial is to create an input component that connects to a MySQL database, executes a SQL query and gets the result.</p>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_add_component.png" target="_blank" rel="noopener"><img src="_images/starter/starter_add_component.png" alt="Input configuration"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>Input</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLInput</em>.</p>
</li>
<li>
<p>Click <strong>Configuration model</strong>. This button lets you specify the required configuration for the component. By default, a dataset is already specified.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the parameter name and choose its type then click the tick button to save the changes.<br>
In this tutorial, to be able to execute a SQL query on the Input MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a dataset (which contains the datastore with the connection information)</p>
</li>
<li>
<p>a timeout parameter.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration. However, refreshing the page resets the configuration.<br>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_input-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_input-config.png" alt="Input configuration"></a>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Specify whether the component issues a stream or not. In this tutorial, the MySQL input component created is an ordinary (non streaming) component. In this case, leave the <strong>Stream</strong> option disabled.</p>
</li>
<li>
<p>Select the <strong>Record Type</strong> generated by the component. In this tutorial, select <strong>Generic</strong> because the component is designed to generate records in the default <code>Record</code> format.<br>
You can also select <strong>Custom</strong> to define a POJO that represents your records.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your input component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_processor_component_2"><a class="anchor" href="#_creating_a_processor_component_2"></a>Creating a Processor component</h4>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.
The intent in this tutorial is to create a simple processor component that receives a record, logs it and returns it at it is.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you did not select <strong>Activate IO</strong>, all new components you add to the project are processors by default.<br>
If you selected <strong>Activate IO</strong>, you can choose the component type. In this case, to create a Processor component, you have to manually add at least one output.
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If required, choose the component type: <strong>Processor</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>RecordLogger</em>, as the processor created in this tutorial logs the records.</p>
</li>
<li>
<p>Specify the <strong>Configuration Model</strong> of the component. In this tutorial, the component doesn&#8217;t need any specific configuration. Skip this step.</p>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>Add Input</strong>. In this tutorial, only one input is needed to receive the record to log.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option and click <strong>Save</strong>.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_processor-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_processor-config.png" alt="Processor configuration"></a>
</div>
</div>
</li>
<li>
<p>Define the <strong>Output(s)</strong> of the component. For each output that you need to define, click <strong>Add Output</strong>. The first output must be named <code>MAIN</code>. In this tutorial, only one generic output is needed to return the received record.<br>
Outputs can be configured the same way as inputs (see previous steps).<br>
You can define a reject output connection by naming it <code>REJECT</code>. This naming is used by Talend applications to automatically set the connection type to Reject.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Your processor component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_an_output_component_2"><a class="anchor" href="#_creating_an_output_component_2"></a>Creating an Output component</h4>
<div class="paragraph">
<p>To create an output component, make sure you have selected <strong>Activate IO</strong>.</p>
</div>
<div class="paragraph">
<p>When clicking <strong>Add A Component</strong> in the starter, a new step allows you to define a new component in your project.<br>
The intent in this tutorial is to create an output component that receives a record and inserts it into a MySQL database table.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Output</strong> components are <strong>Processors</strong> without any output. In other words, the output is a processor that does not produce any records.
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_output-config.png" target="_blank" rel="noopener"><img src="_images/starter/starter_output-config.png" alt="Output configuration"></a>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose the component type. <strong>Output</strong> in this case.</p>
</li>
<li>
<p>Enter the component name. For example, <em>MySQLOutput</em>.</p>
</li>
<li>
<p>Click <strong>Configuration Model</strong>. This button lets you specify the required configuration for the component. By default, a dataset is already specified.</p>
</li>
<li>
<p>For each parameter that you need to add, click the <strong>(+)</strong> button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes.<br>
In this tutorial, to be able to insert a record in the output MySQL database, the configuration requires the following parameters:+</p>
<div class="ulist">
<ul>
<li>
<p>a dataset (which contains the datastore with the connection information)</p>
</li>
<li>
<p>a timeout parameter.<br></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Closing the configuration panel on the right does <strong>not</strong> delete your configuration. However, refreshing the page resets the configuration.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Define the <strong>Input(s)</strong> of the component. For each input that you need to define, click <strong>Add Input</strong>. In this tutorial, only one input is needed.</p>
</li>
<li>
<p>Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them.<br>
The input in this tutorial is a generic record. Enable the <strong>Generic</strong> option and click <strong>Save</strong>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not create any output because the component does not produce any record. This is the only difference between an output an a processor component.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your output component is now defined. You can add another component or generate and download your project.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generating_and_downloading_the_final_project_2"><a class="anchor" href="#_generating_and_downloading_the_final_project_2"></a>Generating and downloading the final project</h4>
<div class="paragraph">
<p>Once your project is configured and all the components you need are created, you can generate and download the final project.
In this tutorial, the project was configured and three components of different types (input, processor and output) have been defined.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Click <strong>Finish</strong> on the left panel. You are redirected to a page that summarizes the project. On the left panel, you can also see all the components that you added to the project.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter/starter_project-download.png" target="_blank" rel="noopener"><img src="_images/starter/starter_project-download.png" alt="Output configuration"></a>
</div>
</div>
</li>
<li>
<p>Generate the project using one of the two options available:</p>
<div class="ulist">
<ul>
<li>
<p>Download it locally as a ZIP file using the <strong>Download as ZIP</strong> button.</p>
</li>
<li>
<p>Create a GitHub repository and push the project to it using the <strong>Create on Github</strong> button.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this tutorial, the project is downloaded to the local machine as a ZIP file.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compiling_and_exploring_the_generated_project_files_2"><a class="anchor" href="#_compiling_and_exploring_the_generated_project_files_2"></a>Compiling and exploring the generated project files</h4>
<div class="paragraph">
<p>Once the package is available on your machine, you can compile it using the build tool selected when configuring the project.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the tutorial, <strong>Maven</strong> is the build tool selected for the project.<br>
In the project directory, execute the <code>mvn package</code> command.<br>
If you don&#8217;t have Maven installed on your machine, you can use the Maven wrapper provided in the generated project, by executing the <code>./mvnw package</code> command.</p>
</li>
<li>
<p>If you have created a Gradle project, you can compile it using the <code>gradle build</code> command or using the Gradle wrapper: <code>./gradlew build</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The generated project code contains documentation that can guide and help you implementing the component logic.
Import the project to your favorite IDE to start the implementation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generating_a_project_using_an_openapi_json_descriptor_2"><a class="anchor" href="#_generating_a_project_using_an_openapi_json_descriptor_2"></a>Generating a project using an OpenAPI JSON descriptor</h4>
<div class="paragraph">
<p>The Component Kit Starter allows you to generate a component development project from an OpenAPI JSON descriptor.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Open the <a href="https://starter-toolkit.talend.io">Starter</a> in the web browser of your choice.</p>
</li>
<li>
<p>Enable the <strong>OpenAPI</strong> mode using the toggle in the header.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter_openapi_toggle.png" target="_blank" rel="noopener"><img src="_images/starter_openapi_toggle.png" alt="Open API toggle"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>API</strong> menu.</p>
</li>
<li>
<p>Paste the OpenAPI JSON descriptor in the right part of the screen. All the described endpoints are detected.</p>
</li>
<li>
<p>Unselect the endpoints that you do not want to use in the future components. By default, all detected endpoints are selected.<br></p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/starter_openapi_json.png" target="_blank" rel="noopener"><img src="_images/starter_openapi_json.png" alt="Open API menu"></a>
</div>
</div>
</li>
<li>
<p>Go to the <strong>Finish</strong> menu.</p>
</li>
<li>
<p>Download the project.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When exploring the project generated from an OpenAPI descriptor, you can notice the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sources</p>
</li>
<li>
<p>the API dataset</p>
</li>
<li>
<p>an HTTP client for the API</p>
</li>
<li>
<p>a connection folder containing the component configuration. By default, the configuration is only made of a simple datastore with a <code>baseUrl</code> parameter.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 relatedlinks">
<h4 id="_related_articles_34"><a class="anchor" href="#_related_articles_34"></a>Related articles</h4>
<div class="ulist">
<ul>
<li>
<p><a href="methodology-creating-components.html" class="page">Methodology</a></p>
</li>
<li>
<p><a href="tutorial-create-an-input-component.html" class="page">Creating a Hazelcast input component</a></p>
</li>
<li>
<p><a href="tutorial-create-an-output-component.html" class="page">Creating a Hazelcast output component</a></p>
</li>
<li>
<p><a href="tutorial-create-components-rest-api.html" class="page">Creating a Zendesk REST API connector</a></p>
</li>
<li>
<p><a href="component-define-input.html" class="page">Defining an input component</a></p>
</li>
<li>
<p><a href="component-define-processor-output.html" class="page">Defining a processor or output component</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_talend_input_component_for_hazelcast"><a class="anchor" href="#_talend_input_component_for_hazelcast"></a>Talend Input component for Hazelcast</h3>
<div id="tutorial-create-an-input-component2" class="paragraph">
<p>This tutorial walks you through the creation, from scratch, of a complete Talend input component for Hazelcast using the <strong>Talend Component Kit (TCK)</strong> framework.</p>
</div>
<div class="paragraph">
<p>Hazelcast is an in-memory distributed system that can store data, which makes it a good example of input component for distributed systems. This is enough for you to get started with this tutorial, but you can find more information about it here: <a href="https://hazelcast.org/" class="bare">hazelcast.org/</a>.</p>
</div>
<div class="sect3">
<h4 id="_creating_the_project"><a class="anchor" href="#_creating_the_project"></a>Creating the project</h4>
<div class="paragraph">
<p>A <strong>TCK</strong> project is a simple Java project with specific configurations and dependencies. You can choose your preferred build tool from <strong>Maven</strong> or <strong>Gradle</strong> as TCK supports both. <strong>In this tutorial, Maven is used.</strong></p>
</div>
<div class="paragraph">
<p>The first step consists in generating the project structure using <strong>Talend Starter Toolkit</strong> .</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Go to <a href="https://starter-toolkit.talend.io/" class="bare">starter-toolkit.talend.io/</a> and fill in the project information as shown
in the screenshots below, then click <strong>Finish</strong> and <strong>Download as ZIP</strong>.<br></p>
<div class="paragraph">
<p>image::tutorial_hazelcast_generateproject_1.png[]<br>
image::tutorial_hazelcast_generateproject_2.png[]<br></p>
</div>
</li>
<li>
<p>Extract the ZIP file into your workspace and import it to your preferred IDE. This tutorial uses Intellij IDE, but you can use Eclipse or any other IDE that you are comfortable with.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use the <strong>Starter Toolkit</strong> to define the full configuration of the component, but in this tutorial some parts are configured manually to explain key concepts of TCK.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The generated <code>pom.xml</code> file of the project looks as follows:<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="
          http://maven.apache.org/POM/4.0.0
          http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;org.talend.components.hazelcast&lt;/groupId&gt;
  &lt;artifactId&gt;hazelcast-component&lt;/artifactId&gt;
  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Component Hazelcast&lt;/name&gt;
  &lt;description&gt;A generated component project&lt;/description&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;

    &lt;!--
    Set it to true if you want the documentation to be rendered as HTML and PDF

    You can also use it in the command line: -Dtalend.documentation.htmlAndPdf=true
    --&gt;
    &lt;talend.documentation.htmlAndPdf&gt;false&lt;/talend.documentation.htmlAndPdf&gt;

    &lt;!--
    if you want to deploy into the Studio you can use the related goal:

    mvn package talend-component:deploy-in-studio -Dtalend.component.studioHome=/path/to/studio

    TIP: it is recommended to set this property into your settings.xml in an active by default profile.
    --&gt;
    &lt;talend.component.studioHome /&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
      &lt;artifactId&gt;component-api&lt;/artifactId&gt;
      &lt;version&gt;1.1.12&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;extensions&gt;
      &lt;extension&gt;
        &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
        &lt;artifactId&gt;talend-component-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.1.12&lt;/version&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;

    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.8.1&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.8&lt;/source&gt;
          &lt;target&gt;1.8&lt;/target&gt;
          &lt;forceJavacCompilerUse&gt;true&lt;/forceJavacCompilerUse&gt;
          &lt;compilerId&gt;javac&lt;/compilerId&gt;
          &lt;fork&gt;true&lt;/fork&gt;
          &lt;compilerArgs&gt;
            &lt;arg&gt;-parameters&lt;/arg&gt;
          &lt;/compilerArgs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
        &lt;version&gt;3.0.0-M3&lt;/version&gt;
        &lt;configuration&gt;
          &lt;trimStackTrace&gt;false&lt;/trimStackTrace&gt;
          &lt;runOrder&gt;alphabetical&lt;/runOrder&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Change the <code>name</code> tag to a more relevant value, for example: <strong>&lt;name&gt;Component Hazelcast&lt;/name&gt;</strong>.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>component-api</code> dependency provides the necessary API to develop the components.</p>
</li>
<li>
<p><code>talend-component-maven-plugin</code> provides build and validation tools for the component development.<br></p>
<div class="paragraph">
<p>The Java compiler also needs a Talend specific configuration for the components to work correctly.
The most important is the <strong>-parameters</strong> option that preserves the parameter names needed for introspection features that TCK relies on.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Download the mvn dependencies declared in the <code>pom.xml</code> file:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn clean compile</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should get a <code>BUILD SUCCESS</code> at this point:<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>[INFO] Scanning for projects...
[INFO]
[INFO] -----&lt; org.talend.components.hazelcast:talend-component-hazelcast &gt;-----
[INFO] Building Component :: Hazelcast 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]

...

[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.311 s
[INFO] Finished at: 2019-09-03T11:42:41+02:00
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
</li>
<li>
<p>Create the project structure:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mkdir -p src/main/java
$ mkdir -p src/main/resources</code></pre>
</div>
</div>
</li>
<li>
<p>Create the component Java packages.</p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Packages are mandatory in the component model and you cannot use the default one (no package).
It is recommended to create a unique package per component to be able to reuse it as dependency in other components, for example to guarantee isolation while writing unit tests.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mkdir -p src/main/java/org/talend/components/hazelcast
$ mkdir -p src/main/resources/org/talend/components/hazelcast</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The project is now correctly set up. The next steps consist in registering the component family and setting up some properties.</p>
</div>
</div>
<div class="sect3">
<h4 id="_registering_the_hazelcast_components_family"><a class="anchor" href="#_registering_the_hazelcast_components_family"></a>Registering the Hazelcast components family</h4>
<div class="paragraph">
<p>Registering every component family allows the component server to properly load the components and to ensure they are available in Talend Studio.</p>
</div>
<div class="sect4">
<h5 id="_creating_the_package_info_java_file"><a class="anchor" href="#_creating_the_package_info_java_file"></a>Creating the package-info.java file</h5>
<div class="paragraph">
<p>The family registration happens via a <code>package-info.java</code> file that you have to create.</p>
</div>
<div class="paragraph">
<p>Move to the <code>src/main/java/org/talend/components/hazelcast</code> package and create a <code>package-info.java</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Components(family = "Hazelcast", categories = "Databases")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Components;
import org.talend.sdk.component.api.component.Icon;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>@Components</strong>: Declares the family name and the categories to which the component belongs.</p>
</li>
<li>
<p><strong>@Icon</strong>: Defines the component family icon. This icon is visible in the Studio metadata tree.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_creating_the_internationalization_file"><a class="anchor" href="#_creating_the_internationalization_file"></a>Creating the internationalization file</h5>
<div class="paragraph">
<p>Talend Component Kit supports internationalization (i18n) via Java properties files. Using these files, you can customize and translate the display name of properties such as the name of a component family or, as shown later in this tutorial, labels displayed in the component configuration.</p>
</div>
<div class="paragraph">
<p>Go to <code>src/main/resources/org/talend/components/hazelcast</code> and create an i18n <code>Messages.properties</code> file as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># An i18n name for the component family
Hazelcast._displayName=Hazelcast</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_providing_the_family_icon"><a class="anchor" href="#_providing_the_family_icon"></a>Providing the family icon</h5>
<div class="paragraph">
<p>You can define the component family icon in the <code>package-info.java</code> file. The icon image must exist in the <code>resources/icons</code> folder.</p>
</div>
<div class="paragraph">
<p>TCK supports both <code>SVG</code> and <code>PNG</code> formats for the icons.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create the <code>icons</code> folder and add an icon image for the Hazelcast family.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mkdir -p /src/main/resources/icons</code></pre>
</div>
</div>
<div class="paragraph">
<p>This tutorial uses the Hazelcast icon from the official GitHub repository that you can get from: <a href="https://avatars3.githubusercontent.com/u/1453152?s=200&amp;v=4" class="bare">avatars3.githubusercontent.com/u/1453152?s=200&amp;v=4</a></p>
</div>
</li>
<li>
<p>Download the image and rename it to <code>Hazelcast_icon32.png</code>.
The name syntax is important and should match <code>&lt;Icon id from the package-info&gt;_icon.32.png</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The component registration is now complete.
The next step consists in defining the component configuration.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_hazelcast_component_configuration"><a class="anchor" href="#_defining_the_hazelcast_component_configuration"></a>Defining the Hazelcast component configuration</h4>
<div class="paragraph">
<p>All Input and Output (I/O) components follow a predefined model of configuration.
The configuration requires two parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Datastore</strong>: Defines all properties that let the component connect to the targeted system.</p>
</li>
<li>
<p><strong>Dataset</strong>: Defines the data to be read or written from/to the targeted system.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_datastore_3"><a class="anchor" href="#_datastore_3"></a>Datastore</h5>
<div class="paragraph">
<p>Connecting to the Hazelcast cluster requires the IP address, group name and password of the targeted cluster.</p>
</div>
<div class="paragraph">
<p>In the component, the datastore is represented by a simple POJO.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a <code>HazelcastDatastore.java</code> class file in the <code>src/main/java/org/talend/components/hazelcast</code>
folder.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.configuration.constraint.Required;
import org.talend.sdk.component.api.configuration.type.DataStore;
import org.talend.sdk.component.api.configuration.ui.layout.GridLayout;
import org.talend.sdk.component.api.configuration.ui.widget.Credential;
import org.talend.sdk.component.api.meta.Documentation;

import java.io.Serializable;

@GridLayout({ <i class="conum" data-value="1"></i><b>(1)</b>
        @GridLayout.Row("clusterIpAddress"),
        @GridLayout.Row({"groupName", "password"})
})
@DataStore("HazelcastDatastore") <i class="conum" data-value="2"></i><b>(2)</b>
@Documentation("Hazelcast Datastore configuration") <i class="conum" data-value="3"></i><b>(3)</b>
public class HazelcastDatastore implements Serializable {

    @Option <i class="conum" data-value="4"></i><b>(4)</b>
    @Required <i class="conum" data-value="5"></i><b>(5)</b>
    @Documentation("The hazelcast cluster ip address")
    private String clusterIpAddress;

    @Option
    @Documentation("cluster group name")
    private String groupName;

    @Option
    @Credential <i class="conum" data-value="6"></i><b>(6)</b>
    @Documentation("cluster password")
    private String password;

    // Getters &amp; Setters omitted for simplicity
    // You need to generate them
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@GridLayout</code>: define the UI layout of this configuration in a grid manner.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@DataStore</code>: mark this POJO as being a data store with the id <code>HazelcastDatastore</code> that can be used to reference the datastore in the i18n files or some services</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>@Documentation</code>: document classes and properties. then TCK rely on those metadata to generate a documentation for the component.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>@Option</code>: mark class&#8217;s attributes as being a configuration entry.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>@Required</code>: mark a configuration as being required.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>@Credential</code>: mark an Option as being a sensible data that need to be encrypted before it&#8217;s stored.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Define the i18n properties of the datastore.
In the <code>Messages.properties</code> file let add the following lines:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#datastore
Hazelcast.datastore.HazelcastDatastore._displayName=Hazelcast Connection
HazelcastDatastore.clusterIpAddress._displayName=Cluster ip address
HazelcastDatastore.groupName._displayName=Group Name
HazelcastDatastore.password._displayName=Password</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Hazelcast datastore is now defined.</p>
</div>
</div>
<div class="sect4">
<h5 id="_dataset_3"><a class="anchor" href="#_dataset_3"></a>Dataset</h5>
<div class="paragraph">
<p>Hazelcast includes different types of datastores.
You can manipulate maps, lists, sets, caches, locks, queues, topics and so on.</p>
</div>
<div class="paragraph">
<p>This tutorial focuses on maps but still applies to the other data structures.</p>
</div>
<div class="paragraph">
<p>Reading/writing from a map requires the map name.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create the dataset class by creating a <code>HazelcastDataset.java</code>
file in <code>src/main/java/org/talend/components/hazelcast</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.configuration.type.DataSet;
import org.talend.sdk.component.api.configuration.ui.layout.GridLayout;
import org.talend.sdk.component.api.meta.Documentation;

import java.io.Serializable;

@GridLayout({
        @GridLayout.Row("connection"),
        @GridLayout.Row("mapName")
})
@DataSet("HazelcastDataset")
@Documentation("Hazelcast dataset")
public class HazelcastDataset implements Serializable {


    @Option
    @Documentation("Hazelcast connection")
    private HazelcastDatastore connection;

    @Option
    @Documentation("Hazelcast map name")
    private String mapName;

    // Getters &amp; Setters omitted for simplicity
    // You need to generate them

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Dataset</code> annotation marks the class as a dataset.
Note that it also references a datastore, as required by the components model.</p>
</div>
</li>
<li>
<p>Just how it was done for the datastore, define the i18n properties of the dataset.
To do that, add the following lines to the <code>Messages.properties</code> file.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#dataset
Hazelcast.dataset.HazelcastDataset._displayName=Hazelcast Map
HazelcastDataset.connection._displayName=Connection
HazelcastDataset.mapName._displayName=Map Name</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The component configuration is now ready. The next step consists in creating the Source that will read the data from the Hazelcast map.</p>
</div>
</div>
<div class="sect4">
<h5 id="_source"><a class="anchor" href="#_source"></a>Source</h5>
<div class="paragraph">
<p>The Source is the class responsible for reading the data from the configured dataset.</p>
</div>
<div class="paragraph">
<p>A source gets the configuration instance injected by TCK at runtime and uses it to connect to the targeted system and read the data.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new class as follows.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.IOException;
import java.io.Serializable;

@Version
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast") <i class="conum" data-value="1"></i><b>(1)</b>
@Emitter(name = "Input") <i class="conum" data-value="2"></i><b>(2)</b>
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration) {
        this.dataset = configuration;
    }

    @PostConstruct
    public void init() throws IOException {
        //Here we can init connections
    }

    @Producer
    public Record next() {
        // provide a record every time it is called. Returns null if there is no more data
        return null;
    }

    @PreDestroy
    public void release() {
        // clean and release any resources
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Icon</code> annotation defines the icon of the component. Here, it uses the same icon as the family icon but you can use a different one.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The class is annotated with <code>@Emitter</code>. It marks this class as being a source that will produce records.<br>
The constructor of the source class lets TCK inject the required configuration to the source. We can also inject some common services provided by TCK or other services that we can define in the component. We will see the service part later in this tutorial.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method annotated with <code>@PostConstruct</code> prepares resources or opens a connection, for example.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The method annotated with <code>@Producer</code> retrieves the next record if any. The method will return <code>null</code> if no more record can be read.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The method annotated with <code>@PreDestroy</code> cleans any resource that was used or opened in the Source.</td>
</tr>
</table>
</div>
</li>
<li>
<p>The source also needs i18n properties to provide a readable display name. Add the following line to the <code>Messages.properties</code> file.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#Source
Hazelcast.Input._displayName=Input</code></pre>
</div>
</div>
</li>
<li>
<p>At this point, it is already possible to see the result in the Talend Component Web Tester to check how the configuration looks like and validate the layout visually.
To do that, execute the following command in the project folder.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn clean install talend-component:web</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command starts the Component Web Tester and deploys the component there.</p>
</div>
</li>
<li>
<p>Access <a href="http://localhost:8080/" class="bare">localhost:8080/</a>.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>[INFO]
[INFO] --- talend-component-maven-plugin:1.1.12:web (default-cli) @ talend-component-hazelcast ---
[16:46:52.361][INFO ][.WebServer_8080][oyote.http11.Http11NioProtocol] Initializing ProtocolHandler ["http-nio-8080"]
[16:46:52.372][INFO ][.WebServer_8080][.catalina.core.StandardService] Starting service [Tomcat]
[16:46:52.372][INFO ][.WebServer_8080][e.catalina.core.StandardEngine] Starting Servlet engine: [Apache Tomcat/9.0.22]
[16:46:52.378][INFO ][.WebServer_8080][oyote.http11.Http11NioProtocol] Starting ProtocolHandler ["http-nio-8080"]
[16:46:52.390][INFO ][.WebServer_8080][g.apache.meecrowave.Meecrowave] --------------- http://localhost:8080
...
[INFO]

  You can now access the UI at http://localhost:8080


[INFO] Enter 'exit' to quit
[INFO] Initializing class org.talend.sdk.component.server.front.ComponentResourceImpl</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/tutorial_hazelcast_webtester.png" alt="tutorial hazelcast webtester">
</div>
</div>
<div class="paragraph">
<p>The source is set up. It is now time to start creating some Hazelcast specific code to connect to a cluster and read values for a map.</p>
</div>
</div>
<div class="sect4">
<h5 id="_source_implementation_for_hazelcast"><a class="anchor" href="#_source_implementation_for_hazelcast"></a>Source implementation for Hazelcast</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the <code>hazelcast-client</code> Maven dependency to the <code>pom.xml</code> of the project, in the <code>dependencies</code> node.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;dependency&gt;
      &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
      &lt;artifactId&gt;hazelcast-client&lt;/artifactId&gt;
      &lt;version&gt;3.12.2&lt;/version&gt;
    &lt;/dependency&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Add a Hazelcast instance to the <code>@PostConstruct</code> method.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Declare a <code>HazelcastInstance</code> attribute in the source class.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Any non-serializable attribute needs to be marked as transient to avoid serialization issues.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Implement the post construct method.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;

import static java.util.Collections.singletonList;

@Version
@Emitter(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration) {
        this.dataset = configuration;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        // Provides a record every time it is called. Returns null if there is no more data
        return null;
    }

    @PreDestroy
    public void release() {
        // Cleans and releases any resource
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The component configuration is mapped to the Hazelcast client configuration to create a Hazelcast instance. This instance will be used later to get the map from its name and read the map data.
Only the required configuration in the component is exposed to keep the code as simple as possible.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Implement the code responsible for reading the data from the Hazelcast map through the <code>Producer</code> method.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Map;

import static java.util.Collections.singletonList;

@Version
@Emitter(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        // Provides a record every time it is called. Returns null if there is no more data
        if (mapIterator == null) {
            // Gets the Distributed Map from Cluster.
            IMap&lt;String, String&gt; map = hazelcastInstance.getMap(dataset.getMapName());
            mapIterator = map.entrySet().iterator();
        }

        if (!mapIterator.hasNext()) {
            return null;
        }

        final Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();
    }

    @PreDestroy
    public void release() {
        // Cleans and releases any resource
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Producer</code> implements the following logic:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Check if the map iterator is already initialized. If not, get the map from its name and initialize the map iterator. This is done in the <code>@Producer</code> method to ensure the map is initialized only if the <code>next()</code> method is called (lazy initialization). It also avoids the map initialization in the <code>PostConstruct</code> method as the Hazelcast map is not serializable.</p>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
All the objects initialized in the <code>PostConstruct</code> method need to be serializable as the source can be serialized and sent to another worker in a distributed cluster.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>From the map, create an iterator on the map keys that will read from the map.</p>
</li>
<li>
<p>Transform every key/value pair into a Talend Record with a "key, value" object on every call to <code>next()</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>RecordBuilderFactory</code> class used above is a built-in service in TCK injected via the Source constructor. This service is a factory to create Talend Records.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Now, the <code>next()</code> method will produce a Record every time it is called. The method will return "null" if there is no more data in the map.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Implement the <code>@PreDestroy</code> annotated method, responsible for releasing
all resources used by the Source. The method needs to shut the Hazelcast client instance down to release any connection between the component and the Hazelcast cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.Map;

import static java.util.Collections.singletonList;

@Version
@Emitter(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    public HazelcastSource(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        // Provides a record every time it is called. Returns null if there is no more data
        if (mapIterator == null) {
            // Get the Distributed Map from Cluster.
            IMap&lt;String, String&gt; map = hazelcastInstance.getMap(dataset.getMapName());
            mapIterator = map.entrySet().iterator();
        }

        if (!mapIterator.hasNext()) {
            return null;
        }

        final Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();
    }

    @PreDestroy
    public void release() {
        // Clean and release any resource
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Hazelcast Source is completed. The next section shows how to write a simple unit test to check that it works properly.</p>
</div>
</div>
<div class="sect4">
<h5 id="_testing_the_source"><a class="anchor" href="#_testing_the_source"></a>Testing the Source</h5>
<div class="paragraph">
<p>TCK provides a set of APIs and tools that makes the testing straightforward.</p>
</div>
<div class="paragraph">
<p>The test of the Hazelcast Source consists in creating an embedded Hazelcast instance with only one member and initializing it with some data, and then in creating a test Job to read the data from it using the implemented Source.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the required Maven test dependencies to the project.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
            &lt;version&gt;5.5.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.talend.sdk.component&lt;/groupId&gt;
            &lt;artifactId&gt;component-runtime-junit&lt;/artifactId&gt;
            &lt;version&gt;1.1.12&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Initialize a Hazelcast test instance and create a map with some test data.
To do that, create the <code>HazelcastSourceTest.java</code> test class in the <code>src/test/java</code> folder. Create the folder if it does not exist.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(4, map.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example creates a Hazelcast instance for the test and creates the <code>MY-DISTRIBUTED-MAP</code> map. The <code>getMap</code> creates the map if it does not already exist. Some keys and values uses in the test are added.
Then, a simple test checks that the data is correctly initialized. Finally, the Hazelcast test instance is shut down.</p>
</div>
</li>
<li>
<p>Run the test and check in the logs that a Hazelcast cluster of one member has been created and that the test has passed.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn clean test</code></pre>
</div>
</div>
</li>
<li>
<p>To be able to test components, TCK provides the <code>@WithComponents</code> annotation which enables component testing. Add this annotation to the test. The annotation takes the component Java package as a value parameter.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.junit5.WithComponents;

import static org.junit.jupiter.api.Assertions.assertEquals;

@WithComponents("org.talend.components.hazelcast")
class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(4, map.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>Create the test Job that configures the Hazelcast instance and link it to an output that collects the data produced by the Source.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;
import org.talend.sdk.component.runtime.manager.chain.Job;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.talend.sdk.component.junit.SimpleFactory.configurationByExample;

@WithComponents("org.talend.components.hazelcast")
class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @Injected
    protected BaseComponentsHandler componentsHandler; <i class="conum" data-value="1"></i><b>(1)</b>

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        map.put("key1", "value1");
        map.put("key2", "value2");
        map.put("key3", "value3");
        map.put("key4", "value4");
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(4, map.size());
    }

    @Test
    void sourceTest() { <i class="conum" data-value="2"></i><b>(2)</b>
        final HazelcastDatastore connection = new HazelcastDatastore();
        connection.setClusterIpAddress(hazelcastInstance.getCluster().getMembers().iterator().next().getAddress().getHost());
        connection.setGroupName(hazelcastInstance.getConfig().getGroupConfig().getName());
        connection.setPassword(hazelcastInstance.getConfig().getGroupConfig().getPassword());
        final HazelcastDataset dataset = new HazelcastDataset();
        dataset.setConnection(connection);
        dataset.setMapName(MAP_NAME);

        final String configUri = configurationByExample().forInstance(dataset).configured().toQueryString(); <i class="conum" data-value="3"></i><b>(3)</b>

        Job.components()
                .component("Input", "Hazelcast://Input?" + configUri)
                .component("Output", "test://collector")
            .connections()
                .from("Input").to("Output")
            .build()
            .run();

        List&lt;Record&gt; data = componentsHandler.getCollectedData(Record.class);
        assertEquals(4, data.size()); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>componentsHandler</code> attribute is injected to the test by TCK. This component handler gives access to the collected data.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>sourceTest</code> method instantiates the configuration of the Source and fills it with the configuration of the Hazelcast test instance created before to let the Source connect to it.<br>
The Job API provides a simple way to build a DAG (Directed Acyclic Graph) Job using Talend components and then runs it on a specific runner (standalone, Beam or Spark). This test starts using the default runner only, which is the standalone one.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>configurationByExample()</code> method creates the <code>ByExample</code> factory. It provides a simple way to convert the configuration instance to an URI configuration used with the Job API to configure the component.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The job runs and checks that the collected data size is equal to the initialized test data.</td>
</tr>
</table>
</div>
</li>
<li>
<p>Execute the unit test and check that it passes, meaning that the Source is reading the data correctly from Hazelcast.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn clean test</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Source is now completed and tested. The next section shows how to implement the Partition Mapper for the Source. In this case, the Partition Mapper will split the work (data reading) between the available cluster members to distribute the workload.</p>
</div>
</div>
<div class="sect4">
<h5 id="_partition_mapper"><a class="anchor" href="#_partition_mapper"></a>Partition Mapper</h5>
<div class="paragraph">
<p>The Partition Mapper calculates the number of Sources that can be created and executed in parallel on the available workers of a distributed system. For Hazelcast, it corresponds to the cluster member count.</p>
</div>
<div class="paragraph">
<p>To fully illustrate this concept, this section also shows how to enhance the test environment to add more Hazelcast cluster members and initialize it with more data.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instantiate more Hazelcast instances, as every Hazelcast instance corresponds to one member in a cluster. In the test, it is reflected as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;
import org.talend.sdk.component.runtime.manager.chain.Job;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.talend.sdk.component.junit.SimpleFactory.configurationByExample;

@WithComponents("org.talend.components.hazelcast")
class HazelcastSourceTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static final int CLUSTER_MEMBERS_COUNT = 2;

    private static final int MAX_DATA_COUNT_BY_MEMBER = 50;

    private static List&lt;HazelcastInstance&gt; hazelcastInstances;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @BeforeAll
    static void init() {
        hazelcastInstances = IntStream.range(0, CLUSTER_MEMBERS_COUNT)
                .mapToObj(i -&gt; Hazelcast.newHazelcastInstance())
                .collect(Collectors.toList());
        //add some data
        hazelcastInstances.forEach(hz -&gt; {
            final IMap&lt;String, String&gt; map = hz.getMap(MAP_NAME);
            IntStream.range(0, MAX_DATA_COUNT_BY_MEMBER)
                    .forEach(i -&gt; map.put(UUID.randomUUID().toString(), "value " + i));
        });
    }

    @Test
    void initTest() {
        IMap&lt;String, String&gt; map = hazelcastInstances.get(0).getMap(MAP_NAME);
        assertEquals(CLUSTER_MEMBERS_COUNT * MAX_DATA_COUNT_BY_MEMBER, map.size());
    }

    @Test
    void sourceTest() {
        final HazelcastDatastore connection = new HazelcastDatastore();
        HazelcastInstance hazelcastInstance = hazelcastInstances.get(0);
        connection.setClusterIpAddress(
                hazelcastInstance.getCluster().getMembers().iterator().next().getAddress().getHost());
        connection.setGroupName(hazelcastInstance.getConfig().getGroupConfig().getName());
        connection.setPassword(hazelcastInstance.getConfig().getGroupConfig().getPassword());
        final HazelcastDataset dataset = new HazelcastDataset();
        dataset.setConnection(connection);
        dataset.setMapName(MAP_NAME);

        final String configUri = configurationByExample().forInstance(dataset).configured().toQueryString();

        Job.components()
                .component("Input", "Hazelcast://Input?" + configUri)
                .component("Output", "test://collector")
                .connections()
                .from("Input")
                .to("Output")
                .build()
                .run();

        List&lt;Record&gt; data = componentsHandler.getCollectedData(Record.class);
        assertEquals(CLUSTER_MEMBERS_COUNT * MAX_DATA_COUNT_BY_MEMBER, data.size());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstances.forEach(HazelcastInstance::shutdown);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code sample creates two Hazelcast instances, leading to the creation of two Hazelcast members. Having a cluster of two members (nodes) will allow to distribute the data.<br>
The above code also adds more data to the test map and updates the shutdown method and the test.</p>
</div>
</li>
<li>
<p>Run the test on the multi-nodes cluster.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>mvn clean test</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Source is a simple implementation that does not distribute the workload and reads the data in a classic way,
without distributing the read action to different cluster members.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Start implementing the Partition Mapper class by creating a <code>HazelcastPartitionMapper.java</code> class file.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.List;
import java.util.UUID;

import static java.util.Collections.singletonList;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName()+"-"+ UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return 0;
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        return null;
    }

    @Emitter
    public HazelcastSource createSource() {
        return null;
    }

    @PreDestroy
    public void release() {
        if(hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When coupling a Partition Mapper with a Source, the Partition Mapper becomes responsible for injecting parameters and creating source instances. This way, all the attribute initialization part moves from the Source to the Partition Mapper class.</p>
</div>
<div class="paragraph">
<p>The configuration also sets an instance name to make it easy to find the client instance in the logs or while debugging.</p>
</div>
<div class="paragraph">
<p>The Partition Mapper class is composed of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>constructor</code>: Handles configuration and service injections</p>
</li>
<li>
<p><code>Assessor</code>: This annotation indicates that the method is responsible for assessing the dataset size. The underlying runner uses the estimated dataset size to compute the optimal bundle size to distribute the workload efficiently.</p>
</li>
<li>
<p><code>Split</code>: This annotation indicates that the method is responsible for creating Partition Mapper instances based on the bundle size requested by the underlying runner and the size of the dataset. It creates as much partitions as possible to parallelize and distribute the workload efficiently on the available workers (known as members in the Hazelcast case).</p>
</li>
<li>
<p><code>Emitter</code>: This annotation indicates that the method is responsible for creating the Source instance with an adapted configuration allowing to handle the amount of records it will produce and the required services.<br>
I adapts the configuration to let the Source read only the requested bundle of data.<br></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="sect5">
<h6 id="_assessor_2"><a class="anchor" href="#_assessor_2"></a>Assessor</h6>
<div class="paragraph">
<p>The <code>Assessor</code> method computes the memory size of every member of the cluster. Implementing it requires submitting a calculation task to the members through a serializable task that is aware of the Hazelcast instance.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create the serializable task.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.HazelcastInstanceAware;

import java.io.Serializable;
import java.util.concurrent.Callable;

public abstract class SerializableTask&lt;T&gt; implements Callable&lt;T&gt;, Serializable, HazelcastInstanceAware {

    protected transient HazelcastInstance localInstance;

    @Override
    public void setHazelcastInstance(final HazelcastInstance hazelcastInstance) {
        localInstance = hazelcastInstance;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The purpose of this class is to submit any task to the Hazelcast cluster.</p>
</div>
</li>
<li>
<p>Use the created task to estimate the dataset size in the <code>Assessor</code> method.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static java.util.Collections.singletonList;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName()+"-"+ UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

            @Override
            public Long call() {
                return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
            }
        }).values().stream().mapToLong(feature -&gt; {
            try {
                return feature.get();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }).sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
          return null;
    }

    @Emitter
    public HazelcastSource createSource() {
        return null;
    }

    @PreDestroy
    public void release() {
        if(hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = hazelcastInstance.getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Assessor</code> method calculates the memory size that the map occupies for all members.<br>
In Hazelcast, distributing a task to all members can be achieved using an execution service initialized in the <code>getExecutorService()</code>
method. The size of the map is requested on every available member. By summing up the results, the total size of the map in the distributed cluster is computed.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect5">
<h6 id="_split_2"><a class="anchor" href="#_split_2"></a>Split</h6>
<div class="paragraph">
<p>The <code>Split</code> method calculates the heap size of the map on every member of the cluster.
Then, it calculates how many members a source can handle.</p>
</div>
<div class="paragraph">
<p>If a member contains less data than the requested bundle size, the method tries to combine it with another member. That combination can only happen if the combined data size is still less or equal to the requested bundle size.</p>
</div>
<div class="paragraph">
<p>The following code illustrates the logic described above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static java.util.Collections.singletonList;
import static java.util.Collections.synchronizedMap;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    private List&lt;String&gt; members;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    private HazelcastPartitionMapper(final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, List&lt;String&gt; membersUUID) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = membersUUID;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return executorService.submitToAllMembers(
                () -&gt; hazelcastInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost())
                .values()
                .stream()
                .mapToLong(feature -&gt; {
                    try {
                        return feature.get();
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                })
                .sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        final Map&lt;String, Long&gt; heapSizeByMember =
                getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                }).entrySet().stream().map(heapSizeMember -&gt; {
                    try {
                        return new AbstractMap.SimpleEntry&lt;&gt;(heapSizeMember.getKey().getUuid(),
                                heapSizeMember.getValue().get());
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                }).collect(toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));

        final List&lt;HazelcastPartitionMapper&gt; partitions = new ArrayList&lt;&gt;(heapSizeByMember.keySet()).stream()
                .map(e -&gt; combineMembers(e, bundleSize, heapSizeByMember))
                .filter(Objects::nonNull)
                .map(m -&gt; new HazelcastPartitionMapper(dataset, recordBuilderFactory, m))
                .collect(toList());

        if (partitions.isEmpty()) {
            List&lt;String&gt; allMembers =
                    hazelcastInstance.getCluster().getMembers().stream().map(Member::getUuid).collect(toList());
            partitions.add(new HazelcastPartitionMapper(dataset, recordBuilderFactory, allMembers));
        }

        return partitions;
    }

    private List&lt;String&gt; combineMembers(String current, final long bundleSize, final Map&lt;String, Long&gt; sizeByMember) {

        if (sizeByMember.isEmpty() || !sizeByMember.containsKey(current)) {
            return null;
        }

        final List&lt;String&gt; combined = new ArrayList&lt;&gt;();
        long size = sizeByMember.remove(current);
        combined.add(current);
        for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = sizeByMember.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry&lt;String, Long&gt; entry = it.next();
            if (size + entry.getValue() &lt;= bundleSize) {
                combined.add(entry.getKey());
                size += entry.getValue();
                it.remove();
            }
        }
        return combined;
    }

    @Emitter
    public HazelcastSource createSource() {
        return null;
    }

    @PreDestroy
    public void release() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = hazelcastInstance.getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step consists in adapting the source to take the Split into account.</p>
</div>
</div>
<div class="sect5">
<h6 id="_source_2"><a class="anchor" href="#_source_2"></a>Source</h6>
<div class="paragraph">
<p>The following sample shows how to adapt the Source to the Split carried out previously.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toMap;

public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    private transient HazelcastInstance hazelcastInstance;

    private final List&lt;String&gt; members;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient Iterator&lt;Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt;&gt; dataByMember;

    public HazelcastSource(final HazelcastDataset configuration, final RecordBuilderFactory recordBuilderFactory,
            final List&lt;String&gt; members) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = members;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Producer
    public Record next() {
        if (dataByMember == null) {
            dataByMember = hazelcastInstance.getExecutorService("talend-source")
                    .submitToMembers(new SerializableTask&lt;Map&lt;String, String&gt;&gt;() {

                        @Override
                        public Map&lt;String, String&gt; call() {
                            final IMap&lt;String, String&gt; map = localInstance.getMap(dataset.getMapName());
                            final Set&lt;String&gt; localKeySet = map.localKeySet();
                            return localKeySet.stream().collect(toMap(k -&gt; k, map::get));
                        }
                    }, member -&gt; members.contains(member.getUuid()))
                    .entrySet()
                    .iterator();
        }

        if (mapIterator != null &amp;&amp; !mapIterator.hasNext() &amp;&amp; !dataByMember.hasNext()) {
            return null;
        }

        if (mapIterator == null || !mapIterator.hasNext()) {
            Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt; next = dataByMember.next();
            try {
                mapIterator = next.getValue().get().entrySet().iterator();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }

        Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();

    }

    @PreDestroy
    public void release() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>next</code> method reads the data from the members received from the Partition Mapper.</p>
</div>
<div class="paragraph">
<p>A Big Data runner like Spark will get multiple Source instances. Every source instance will be responsible for reading data from a specific set of members already calculated by the Partition Mapper.</p>
</div>
<div class="paragraph">
<p>The data is fetched only when the <code>next</code> method is called. This logic allows to stream the data from members without loading it
all into the memory.</p>
</div>
</div>
<div class="sect5">
<h6 id="_emitter_2"><a class="anchor" href="#_emitter_2"></a>Emitter</h6>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Implement the method annotated with <code>@Emitter</code> in the <code>HazelcastPartitionMapper</code> class.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.ExecutionException;

import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper implements Serializable {

    private final HazelcastDataset dataset;

    /**
     * Hazelcast instance is a client in a Hazelcast cluster
     */
    private transient HazelcastInstance hazelcastInstance;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    private List&lt;String&gt; members;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
    }

    private HazelcastPartitionMapper(final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, List&lt;String&gt; membersUUID) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = membersUUID;
    }

    @PostConstruct
    public void init() {
        //Here we can init connections
        final HazelcastDatastore connection = dataset.getConnection();
        final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
        networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
        final ClientConfig config = new ClientConfig();
        config.setNetworkConfig(networkConfig);
        config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
        config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
        config.setClassLoader(Thread.currentThread().getContextClassLoader());
        hazelcastInstance = HazelcastClient.newHazelcastClient(config);
    }

    @Assessor
    public long estimateSize() {
        return getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

            @Override
            public Long call() {
                return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
            }
        }).values().stream().mapToLong(feature -&gt; {
            try {
                return feature.get();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }).sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        final Map&lt;String, Long&gt; heapSizeByMember =
                getExecutorService().submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                }).entrySet().stream().map(heapSizeMember -&gt; {
                    try {
                        return new AbstractMap.SimpleEntry&lt;&gt;(heapSizeMember.getKey().getUuid(),
                                heapSizeMember.getValue().get());
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                }).collect(toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));

        final List&lt;HazelcastPartitionMapper&gt; partitions = new ArrayList&lt;&gt;(heapSizeByMember.keySet()).stream()
                .map(e -&gt; combineMembers(e, bundleSize, heapSizeByMember))
                .filter(Objects::nonNull)
                .map(m -&gt; new HazelcastPartitionMapper(dataset, recordBuilderFactory, m))
                .collect(toList());

        if (partitions.isEmpty()) {
            List&lt;String&gt; allMembers =
                    hazelcastInstance.getCluster().getMembers().stream().map(Member::getUuid).collect(toList());
            partitions.add(new HazelcastPartitionMapper(dataset, recordBuilderFactory, allMembers));
        }

        return partitions;
    }

    private List&lt;String&gt; combineMembers(String current, final long bundleSize, final Map&lt;String, Long&gt; sizeByMember) {

        if (sizeByMember.isEmpty() || !sizeByMember.containsKey(current)) {
            return null;
        }

        final List&lt;String&gt; combined = new ArrayList&lt;&gt;();
        long size = sizeByMember.remove(current);
        combined.add(current);
        for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = sizeByMember.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry&lt;String, Long&gt; entry = it.next();
            if (size + entry.getValue() &lt;= bundleSize) {
                combined.add(entry.getKey());
                size += entry.getValue();
                it.remove();
            }
        }
        return combined;
    }

    @Emitter
    public HazelcastSource createSource() {
        return new HazelcastSource(dataset, recordBuilderFactory, members);
    }

    @PreDestroy
    public void release() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    private IExecutorService getExecutorService() {
        return executorService == null ?
                executorService = hazelcastInstance.getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>createSource()</code> method creates the source instance and passes the required services and the selected Hazelcast members to the source instance.</p>
</div>
</li>
<li>
<p>Run the test and check that it works as intended.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn clean test</code></pre>
</div>
</div>
<div class="paragraph">
<p>The component implementation is now done. It is able to read data and to distribute the workload to available members in a Big Data
execution environment.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_introducing_tck_services"><a class="anchor" href="#_introducing_tck_services"></a>Introducing TCK services</h4>
<div class="paragraph">
<p>Refactor the component by introducing a service to make some pieces of code reusable and avoid code duplication.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Refactor the Hazelcast instance creation into a service.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.client.config.ClientNetworkConfig;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IExecutorService;
import org.talend.sdk.component.api.service.Service;

import java.io.Serializable;
import java.util.UUID;

import static java.util.Collections.singletonList;

@Service
public class HazelcastService implements Serializable {

    private transient HazelcastInstance hazelcastInstance;

    private transient IExecutorService executorService;

    public HazelcastInstance getOrCreateIntance(final HazelcastDatastore connection) {
        if (hazelcastInstance == null || !hazelcastInstance.getLifecycleService().isRunning()) {
            final ClientNetworkConfig networkConfig = new ClientNetworkConfig();
            networkConfig.setAddresses(singletonList(connection.getClusterIpAddress()));
            final ClientConfig config = new ClientConfig();
            config.setNetworkConfig(networkConfig);
            config.getGroupConfig().setName(connection.getGroupName()).setPassword(connection.getPassword());
            config.setInstanceName(getClass().getName() + "-" + UUID.randomUUID().toString());
            config.setClassLoader(Thread.currentThread().getContextClassLoader());
            hazelcastInstance = HazelcastClient.newHazelcastClient(config);
        }
        return hazelcastInstance;
    }

    public void shutdownInstance() {
        if (hazelcastInstance != null) {
            hazelcastInstance.shutdown();
        }
    }

    public IExecutorService getExecutorService(final HazelcastDatastore connection) {
        return executorService == null ?
                executorService = getOrCreateIntance(connection).getExecutorService("talend-executor-service") :
                executorService;
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Inject this service to the Partition Mapper to reuse it.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.IExecutorService;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.input.Assessor;
import org.talend.sdk.component.api.input.Emitter;
import org.talend.sdk.component.api.input.PartitionMapper;
import org.talend.sdk.component.api.input.PartitionSize;
import org.talend.sdk.component.api.input.Split;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ExecutionException;

import static java.util.stream.Collectors.toList;
import static java.util.stream.Collectors.toMap;

@Version
@PartitionMapper(name = "Input")
@Icon(value = Icon.IconType.CUSTOM, custom = "Hazelcast")
@Documentation("Hazelcast source")
public class HazelcastPartitionMapper implements Serializable {

    private final HazelcastDataset dataset;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient IExecutorService executorService;

    private List&lt;String&gt; members;

    private final HazelcastService hazelcastService;

    public HazelcastPartitionMapper(@Option("configuration") final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, final HazelcastService hazelcastService) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.hazelcastService = hazelcastService;
    }

    private HazelcastPartitionMapper(final HazelcastDataset configuration,
            final RecordBuilderFactory recordBuilderFactory, List&lt;String&gt; membersUUID,
            final HazelcastService hazelcastService) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.hazelcastService = hazelcastService;
        this.members = membersUUID;

    }

    @PostConstruct
    public void init() {
        // We initialize the hazelcast instance only on it first usage now
    }

    @Assessor
    public long estimateSize() {
        return hazelcastService.getExecutorService(dataset.getConnection())
                .submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                })
                .values()
                .stream()
                .mapToLong(feature -&gt; {
                    try {
                        return feature.get();
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                })
                .sum();
    }

    @Split
    public List&lt;HazelcastPartitionMapper&gt; split(@PartitionSize final long bundleSize) {
        final Map&lt;String, Long&gt; heapSizeByMember = hazelcastService.getExecutorService(dataset.getConnection())
                .submitToAllMembers(new SerializableTask&lt;Long&gt;() {

                    @Override
                    public Long call() {
                        return localInstance.getMap(dataset.getMapName()).getLocalMapStats().getHeapCost();
                    }
                })
                .entrySet()
                .stream()
                .map(heapSizeMember -&gt; {
                    try {
                        return new AbstractMap.SimpleEntry&lt;&gt;(heapSizeMember.getKey().getUuid(),
                                heapSizeMember.getValue().get());
                    } catch (InterruptedException | ExecutionException e) {
                        throw new IllegalStateException(e);
                    }
                })
                .collect(toMap(AbstractMap.SimpleEntry::getKey, AbstractMap.SimpleEntry::getValue));

        final List&lt;HazelcastPartitionMapper&gt; partitions = new ArrayList&lt;&gt;(heapSizeByMember.keySet()).stream()
                .map(e -&gt; combineMembers(e, bundleSize, heapSizeByMember))
                .filter(Objects::nonNull)
                .map(m -&gt; new HazelcastPartitionMapper(dataset, recordBuilderFactory, m, hazelcastService))
                .collect(toList());

        if (partitions.isEmpty()) {
            List&lt;String&gt; allMembers = hazelcastService.getOrCreateIntance(dataset.getConnection())
                    .getCluster()
                    .getMembers()
                    .stream()
                    .map(Member::getUuid)
                    .collect(toList());
            partitions.add(new HazelcastPartitionMapper(dataset, recordBuilderFactory, allMembers, hazelcastService));
        }

        return partitions;
    }

    private List&lt;String&gt; combineMembers(String current, final long bundleSize, final Map&lt;String, Long&gt; sizeByMember) {

        if (sizeByMember.isEmpty() || !sizeByMember.containsKey(current)) {
            return null;
        }

        final List&lt;String&gt; combined = new ArrayList&lt;&gt;();
        long size = sizeByMember.remove(current);
        combined.add(current);
        for (Iterator&lt;Map.Entry&lt;String, Long&gt;&gt; it = sizeByMember.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry&lt;String, Long&gt; entry = it.next();
            if (size + entry.getValue() &lt;= bundleSize) {
                combined.add(entry.getKey());
                size += entry.getValue();
                it.remove();
            }
        }
        return combined;
    }

    @Emitter
    public HazelcastSource createSource() {
        return new HazelcastSource(dataset, recordBuilderFactory, members, hazelcastService);
    }

    @PreDestroy
    public void release() {
        hazelcastService.shutdownInstance();
    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>Adapt the Source class to reuse the service.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.IMap;
import com.hazelcast.core.Member;
import org.talend.sdk.component.api.input.Producer;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import static java.util.stream.Collectors.toMap;

public class HazelcastSource implements Serializable {

    private final HazelcastDataset dataset;

    private final List&lt;String&gt; members;

    private transient Iterator&lt;Map.Entry&lt;String, String&gt;&gt; mapIterator;

    private final RecordBuilderFactory recordBuilderFactory;

    private transient Iterator&lt;Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt;&gt; dataByMember;

    private final HazelcastService hazelcastService;

    public HazelcastSource(final HazelcastDataset configuration, final RecordBuilderFactory recordBuilderFactory,
            final List&lt;String&gt; members, final HazelcastService hazelcastService) {
        this.dataset = configuration;
        this.recordBuilderFactory = recordBuilderFactory;
        this.members = members;
        this.hazelcastService = hazelcastService;
    }

    @PostConstruct
    public void init() {
        // We initialize the hazelcast instance only on it first usage now
    }

    @Producer
    public Record next() {
        if (dataByMember == null) {
            dataByMember = hazelcastService.getOrCreateIntance(dataset.getConnection())
                    .getExecutorService("talend-source")
                    .submitToMembers(new SerializableTask&lt;Map&lt;String, String&gt;&gt;() {

                        @Override
                        public Map&lt;String, String&gt; call() {
                            final IMap&lt;String, String&gt; map = localInstance.getMap(dataset.getMapName());
                            final Set&lt;String&gt; localKeySet = map.localKeySet();
                            return localKeySet.stream().collect(toMap(k -&gt; k, map::get));
                        }
                    }, member -&gt; members.contains(member.getUuid()))
                    .entrySet()
                    .iterator();
        }

        if (mapIterator != null &amp;&amp; !mapIterator.hasNext() &amp;&amp; !dataByMember.hasNext()) {
            return null;
        }

        if (mapIterator == null || !mapIterator.hasNext()) {
            Map.Entry&lt;Member, Future&lt;Map&lt;String, String&gt;&gt;&gt; next = dataByMember.next();
            try {
                mapIterator = next.getValue().get().entrySet().iterator();
            } catch (InterruptedException | ExecutionException e) {
                throw new IllegalStateException(e);
            }
        }

        Map.Entry&lt;String, String&gt; entry = mapIterator.next();
        return recordBuilderFactory.newRecordBuilder().withString(entry.getKey(), entry.getValue()).build();

    }

    @PreDestroy
    public void release() {
        hazelcastService.shutdownInstance();
    }
}</code></pre>
</div>
</div>
</li>
<li>
<p>Run the test one last time to ensure everything still works as expected.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Thank you for following this tutorial. Use the logic and approach presented here to create any input component for any system.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_an_output_component_for_hazelcast"><a class="anchor" href="#_implementing_an_output_component_for_hazelcast"></a>Implementing an Output component for Hazelcast</h3>
<div id="tutorial-create-an-output-component" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
This tutorial is the continuation of
<a href="tutorial-create-an-input-component.html" class="page">Talend Input component for Hazelcast</a> tutorial. We will not walk through
the project creation again, So please start from there before taking this one.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This tutorial shows how to create a complete working output component for <a href="https://hazelcast.org">Hazelcast</a></p>
</div>
<div class="sect3">
<h4 id="_defining_the_configurable_part_and_the_layout_of_the_component"><a class="anchor" href="#_defining_the_configurable_part_and_the_layout_of_the_component"></a>Defining the configurable part and the layout of the component</h4>
<div class="paragraph">
<p>As seen before, in Hazelcast there is multiple data source type. You can find queues, topics, cache, maps&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>In this tutorials we will stick with the Map dataset and all what we will see here is applicable to the other types.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that our Hazelcast output component will be responsible of inserting data into a distributed Map.
For that, we will need to know which attribute from the incoming data is to be used as a key in the map. The value will be the hole record
encoded into a json format.</p>
</div>
<div class="paragraph">
<p>Bu that in mind, we can design our output configuration as: the same Datastore and Dataset from the input component
and an additional configuration that will define the key attribute.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create our Output configuration class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.configuration.ui.layout.GridLayout;
import org.talend.sdk.component.api.meta.Documentation;import java.io.Serializable;

@GridLayout({
                @GridLayout.Row("dataset"),
                @GridLayout.Row("key")
})
@Documentation("Hazelcast output configuration")
public class HazelcastOutputConfig implements Serializable {

    @Option
    @Documentation("the hazelcast dataset")
    private HazelcastDataset dataset;

    @Option
    @Documentation("The key attribute")
    private String key;


    // Getters &amp; Setters omitted for simplicity
    // You need to generate them
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s add the i18n properties of our configuration into the <code>Messages.properties file</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Output config
HazelcastOutputConfig.dataset._displayName=Hazelcast dataset
HazelcastOutputConfig.key._displayName=Key attribute</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_output_implementation"><a class="anchor" href="#_output_implementation"></a>Output Implementation</h4>
<div class="paragraph">
<p>The skeleton of the output component looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration) {
    }

    @PostConstruct
    public void init() {
    }

    @PreDestroy
    public void release() {
    }

    @ElementListener
    public void onElement(final Record record) {
    }

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Version</code> annotation indicates the version of the component. It is used to migrate the component configuration if needed.</p>
</li>
<li>
<p><code>@Icon</code> annotation indicates the icon of the component. Here, the icon is a custom icon that needs to be bundled in
the component JAR under <code>resources/icons</code>.</p>
</li>
<li>
<p><code>@Processor</code> annotation indicates that this class is the processor (output) and defines the name of the component.</p>
</li>
<li>
<p><code>constructor</code> of the processor is responsible for injecting the component configuration and services.
Configuration parameters are annotated with <code>@Option</code>. The other parameters are considered as services and are injected
by the component framework. Services can be local (class annotated with <code>@Service</code>) or provided by the component framework.</p>
</li>
<li>
<p>The method annotated with <code>@PostConstruct</code> is executed once by instance and can be used for initialization.</p>
</li>
<li>
<p>The method annotated with <code>@PreDestroy</code> is used to clean resources at the end of the execution of the output.</p>
</li>
<li>
<p>Data is passed to the method annotated with <code>@ElementListener</code>. That method is responsible for handling the data output.
You can define all the related logic in this method.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you need to bulk write the updates accordingly to groups, see <a href="concept-processor-and-batch-processing.html" class="page">Processors and batch processing</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now, we will need to add the display name of the Output to the i18n resources file <code>Messages.properties</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">#Output
Hazelcast.Output._displayName=Output</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Let&#8217;s implement all of those methods</p>
</div>
</blockquote>
</div>
<div class="sect4">
<h5 id="_defining_the_constructor_method"><a class="anchor" href="#_defining_the_constructor_method"></a>Defining the constructor method</h5>
<div class="paragraph">
<p>We will create the outpu contructor to inject the component configuration and some additional local and built in services.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Built in services are services provided by TCK.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.json.bind.Jsonb;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    private final HazelcastOutputConfig configuration;

    private final HazelcastService hazelcastService;

    private final Jsonb jsonb;

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration,
            final HazelcastService hazelcastService, final Jsonb jsonb) {
        this.configuration = configuration;
        this.hazelcastService = hazelcastService;
        this.jsonb = jsonb;
    }

    @PostConstruct
    public void init() {
    }

    @PreDestroy
    public void release() {
    }

    @ElementListener
    public void onElement(final Record record) {
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we find:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>configuration</code> is the component configuration class</p>
</li>
<li>
<p><code>hazelcastService</code> is the service that we have implemented in the input component tutorial. it will be responsible of creating a hazelcast
client instance.</p>
</li>
<li>
<p><code>jsonb</code> is a built in service provided by tck to handle json object serialization and deserialization. We will use it to
convert the incoming record to json format before inseting them into the map.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_defining_the_postconstruct_method"><a class="anchor" href="#_defining_the_postconstruct_method"></a>Defining the PostConstruct method</h5>
<div class="paragraph">
<p>Nothing to do in the post construct method. but we could for example initialize a hazle cast instance there. but we will
do it in a lazy way on the first call in the <code>@ElementListener</code> method</p>
</div>
</div>
<div class="sect4">
<h5 id="_defining_the_predestroy_method"><a class="anchor" href="#_defining_the_predestroy_method"></a>Defining the PreDestroy method</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.json.bind.Jsonb;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    private final HazelcastOutputConfig configuration;

    private final HazelcastService hazelcastService;

    private final Jsonb jsonb;

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration,
            final HazelcastService hazelcastService, final Jsonb jsonb) {
        this.configuration = configuration;
        this.hazelcastService = hazelcastService;
        this.jsonb = jsonb;
    }

    @PostConstruct
    public void init() {
        //no-op
    }

    @PreDestroy
    public void release() {
        this.hazelcastService.shutdownInstance();
    }

    @ElementListener
    public void onElement(final Record record) {
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Shut down the Hazelcast client instance and thus free the Hazelcast map reference.</p>
</div>
</div>
<div class="sect4">
<h5 id="_defining_the_elementlistener_method"><a class="anchor" href="#_defining_the_elementlistener_method"></a>Defining the ElementListener method</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.talend.sdk.component.api.component.Icon;
import org.talend.sdk.component.api.component.Version;
import org.talend.sdk.component.api.configuration.Option;
import org.talend.sdk.component.api.meta.Documentation;
import org.talend.sdk.component.api.processor.ElementListener;
import org.talend.sdk.component.api.processor.Processor;
import org.talend.sdk.component.api.record.Record;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.json.bind.Jsonb;
import java.io.Serializable;

import static org.talend.sdk.component.api.component.Icon.IconType.CUSTOM;

@Version
@Icon(custom = "Hazelcast", value = CUSTOM)
@Processor(name = "Output")
@Documentation("Hazelcast output component")
public class HazelcastOutput implements Serializable {

    private final HazelcastOutputConfig configuration;

    private final HazelcastService hazelcastService;

    private final Jsonb jsonb;

    public HazelcastOutput(@Option("configuration") final HazelcastOutputConfig configuration,
            final HazelcastService hazelcastService, final Jsonb jsonb) {
        this.configuration = configuration;
        this.hazelcastService = hazelcastService;
        this.jsonb = jsonb;
    }

    @PostConstruct
    public void init() {
        //no-op
    }

    @PreDestroy
    public void release() {
        this.hazelcastService.shutdownInstance();
    }

    @ElementListener
    public void onElement(final Record record) {
        final String key = record.getString(configuration.getKey());
        final String value = jsonb.toJson(record);

        final HazelcastInstance hz = hazelcastService.getOrCreateIntance(configuration.getDataset().getConnection());
        final IMap&lt;String, String&gt; map = hz.getMap(configuration.getDataset().getMapName());
        map.put(key, value);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We get the key attribute from the incoming record and then convert the hole record to a json string. Then we insert
the key/value into the hazelcast map.</p>
</div>
</div>
<div class="sect4">
<h5 id="_testing_the_output_component"><a class="anchor" href="#_testing_the_output_component"></a>Testing the output component</h5>
<div class="paragraph">
<p>Let&#8217;s create a unit test for our output component. The idea will be to create a job that will insert the data using
this output implementation.</p>
</div>
<div class="paragraph">
<p>So, let&#8217;s create out test class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;

@WithComponents("org.talend.components.hazelcast")
class HazelcastOuputTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        //init the map
        final IMap&lt;String, String&gt; map = hazelcastInstances.getMap(MAP_NAME);

    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we start by creating a hazelcast test instance, and we initialize the map. we also shutdown the instance after all the
test are executed.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s create our output test.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.talend.components.hazelcast;

import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.talend.sdk.component.api.record.Record;
import org.talend.sdk.component.api.service.Service;
import org.talend.sdk.component.api.service.record.RecordBuilderFactory;
import org.talend.sdk.component.junit.BaseComponentsHandler;
import org.talend.sdk.component.junit5.Injected;
import org.talend.sdk.component.junit5.WithComponents;
import org.talend.sdk.component.runtime.manager.chain.Job;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.talend.sdk.component.junit.SimpleFactory.configurationByExample;

@WithComponents("org.talend.components.hazelcast")
class HazelcastOuputTest {

    private static final String MAP_NAME = "MY-DISTRIBUTED-MAP";

    private static HazelcastInstance hazelcastInstance;

    @Injected
    protected BaseComponentsHandler componentsHandler;

    @Service
    protected RecordBuilderFactory recordBuilderFactory;

    @BeforeAll
    static void init() {
        hazelcastInstance = Hazelcast.newHazelcastInstance();
        //init the map
        final IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);

    }

    @Test
    void outputTest() {
        final HazelcastDatastore connection = new HazelcastDatastore();
        connection.setClusterIpAddress(
                hazelcastInstance.getCluster().getMembers().iterator().next().getAddress().getHost());
        connection.setGroupName(hazelcastInstance.getConfig().getGroupConfig().getName());
        connection.setPassword(hazelcastInstance.getConfig().getGroupConfig().getPassword());
        final HazelcastDataset dataset = new HazelcastDataset();
        dataset.setConnection(connection);
        dataset.setMapName(MAP_NAME);

        HazelcastOutputConfig config = new HazelcastOutputConfig();
        config.setDataset(dataset);
        config.setKey("id");

        final String configUri = configurationByExample().forInstance(config).configured().toQueryString();

        componentsHandler.setInputData(generateTestData(10));
        Job.components()
                .component("Input", "test://emitter")
                .component("Output", "Hazelcast://Output?" + configUri)
                .connections()
                .from("Input")
                .to("Output")
                .build()
                .run();

        final IMap&lt;String, String&gt; map = hazelcastInstance.getMap(MAP_NAME);
        assertEquals(10, map.size());
    }

    private List&lt;Record&gt; generateTestData(int count) {
        return IntStream.range(0, count)
                .mapToObj(i -&gt; recordBuilderFactory.newRecordBuilder()
                        .withString("id", UUID.randomUUID().toString())
                        .withString("val1", UUID.randomUUID().toString())
                        .withString("val2", UUID.randomUUID().toString())
                        .build())
                .collect(Collectors.toList());
    }

    @AfterAll
    static void shutdown() {
        hazelcastInstance.shutdown();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we start preparing the <code>emitter</code> test component provided bt TCK that we use in our test job
to generate random data for our output. Then, we use the output component to fill the hazelcast map.</p>
</div>
<div class="paragraph">
<p>By the end we test that the map contains the exact amount of data inserted by the job.</p>
</div>
<div class="paragraph">
<p>Run the test and check that it&#8217;s working.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>$ mvn clean test</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Congratulation you just finished your output component.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_components_for_a_rest_api"><a class="anchor" href="#_creating_components_for_a_rest_api"></a>Creating components for a REST API</h3>
<div id="tutorial-create-components-rest-api" class="paragraph">
<p>This tutorial shows how to create components that consume a REST API.</p>
</div>
<div class="paragraph">
<p>The component developed as example in this tutorial is an input component that provides a search functionality for Zendesk using its <a href="https://developer.zendesk.com/rest_api/docs/core/search">Search API</a>.<br>
<a href="https://projectlombok.org/">Lombok</a> is used to avoid writing getter, setter and constructor methods.</p>
</div>
<div class="paragraph">
<p>You can generate a project using the Talend Components Kit starter, as described in
<a href="tutorial-generate-project-using-starter.html" class="page">this tutorial</a>.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_the_http_client"><a class="anchor" href="#_setting_up_the_http_client"></a>Setting up the HTTP client</h4>
<div class="paragraph">
<p>The input component relies on Zendesk Search API and requires an HTTP client to consume it.</p>
</div>
<div class="paragraph">
<p>The Zendesk Search API takes the following parameters on the <code>/api/v2/search.json</code> endpoint.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>query</strong>     : The search query.</p>
</li>
<li>
<p><strong>sort_by</strong>   : The sorting type of the query result. Possible values are <code>updated_at</code>, <code>created_at</code>, <code>priority</code>, <code>status</code>, <code>ticket_type</code>, or <code>relevance</code>. It defaults to <code>relevance</code>.</p>
</li>
<li>
<p><strong>sort_order</strong>: The sorting order of the query result. Possible values are <code>asc</code> (for ascending) or <code>desc</code> (for descending). It defaults to <code>desc</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Talend Component Kit provides a built-in service to create an easy-to-use HTTP client in a declarative manner, using Java annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface SearchClient extends HttpClient { <i class="conum" data-value="1"></i><b>(1)</b>

    @Request(path = "api/v2/search.json", method = "GET") <i class="conum" data-value="2"></i><b>(2)</b>
    Response&lt;JsonObject&gt; search(@Header("Authorization") String auth,<i class="conum" data-value="3"></i><b>(3)</b> <i class="conum" data-value="4"></i><b>(4)</b>
            @Header("Content-Type") String contentType, <i class="conum" data-value="5"></i><b>(5)</b>
            @Query("query") String query, <i class="conum" data-value="6"></i><b>(6)</b>
            @Query("sort_by") String sortBy,
            @Query("sort_order") String sortOrder,
            @Query("page") Integer page
    );
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The interface needs to extend <code>org.talend.sdk.component.api.service.http.HttpClient</code> to be recognized as an HTTP client by the component framework.
This interface also provides the <code>void base(String base)</code> method, that allows to set the base URI for the HTTP request. In this tutorial, it is the Zendesk instance URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>@Request</code> annotation allows to define the HTTP request path and method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, and so on).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The method return type and a header parameter are defined.<br>
The method return type is a JSON object: <code>Response&lt;JsonObject&gt;</code>. The <code>Response</code> object allows to access the HTTP response status code, headers, error payload and the response body that are of the <code>JsonObject</code> type in this case.<br>
The response body is decoded according to the content type returned by the API. The component framework provides the codec to decode JSON content.<br>
If you want to consume specific content types, you need to specify your custom codec using the <code>@Codec</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>Authorization</code> HTTP request header allows to provide the authorization token.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Another HTTP request header defined to provide the content type.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Query parameters are defined using the <code>@Query</code> annotation that provides the parameter name.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>No additional implementation is needed for the interface, as it is provided by the component framework, according to what is defined above.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This HTTP client can be injected into a mapper or a processor to perform HTTP requests.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_the_component"><a class="anchor" href="#_configuring_the_component"></a>Configuring the component</h4>
<div class="paragraph">
<p>This example uses the basic authentication that supported by the API.</p>
</div>
<div class="sect4">
<h5 id="_configuring_basic_authentication"><a class="anchor" href="#_configuring_basic_authentication"></a>Configuring basic authentication</h5>
<div class="paragraph">
<p>The first step is to set up the configuration for the basic authentication.
To be able to consume the Search API, the Zendesk instance URL, the username and the password are needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
@DataStore <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
        @GridLayout.Row({ "url" }),
        @GridLayout.Row({ "username", "password" })
})
@Documentation("Basic authentication for Zendesk API")
public class BasicAuth {

    @Option
    @Documentation("Zendesk instance url")
    private final String url;

    @Option
    @Documentation("Zendesk account username (e-mail).")
    private final String username;

    @Option
    @Credential <i class="conum" data-value="3"></i><b>(3)</b>
    @Documentation("Zendesk account password")
    private final String password;

    public String getAuthorizationHeader() { <i class="conum" data-value="4"></i><b>(4)</b>
        try {
            return "Basic " + Base64.getEncoder()
                    .encodeToString((this.getUsername() + ":" + this.getPassword()).getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This configuration class provides the authentication information. Type it as <code>Datastore</code> so that it can be validated using services (similar to connection test) and used by Talend Studio or web application metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@GridLayout</code> defines the UI layout of this configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The password is marked as <code>Credential</code> so that it is handled as sensitive data in Talend Studio and web applications. <a href="tutorial-configuration-sensitive-data.html" class="page">Read more about sensitive data handling</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This method generates a basic authentication token using the username and the password. This token is used to authenticate the HTTP call on the Search API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The data store is now configured. It provides a basic authentication token.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_the_dataset"><a class="anchor" href="#_configuring_the_dataset"></a>Configuring the dataset</h5>
<div class="paragraph">
<p>Once the data store is configured, you can define the dataset by configuring the search query. It is that query that defines the records processed by the input component.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data
@DataSet <i class="conum" data-value="1"></i><b>(1)</b>
@GridLayout({ <i class="conum" data-value="2"></i><b>(2)</b>
        @GridLayout.Row({ "dataStore" }),
        @GridLayout.Row({ "query" }),
        @GridLayout.Row({ "sortBy", "sortOrder" })
})
@Documentation("Data set that defines a search query for Zendesk Search API. See API reference https://developer.zendesk.com/rest_api/docs/core/search")
public class SearchQuery {

    @Option
    @Documentation("Authentication information.")
    private final BasicAuth dataStore;

    @Option
    @TextArea <i class="conum" data-value="3"></i><b>(3)</b>
    @Documentation("Search query.") <i class="conum" data-value="4"></i><b>(4)</b>
    private final String query;

    @Option
    @DefaultValue("relevance") <i class="conum" data-value="5"></i><b>(5)</b>
    @Documentation("One of updated_at, created_at, priority, status, or ticket_type. Defaults to sorting by relevance")
    private final String sortBy;

    @Option
    @DefaultValue("desc")
    @Documentation("One of asc or desc. Defaults to desc")
    private final String sortOrder;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The configuration class is marked as a <code>DataSet</code>. <a href="component-configuration.html#dataset-and-datastore" class="page">Read more about configuration types</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@GridLayout</code> defines the UI layout of this configuration.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A text area widget is bound to the <strong>Search query</strong> field. <a href="gallery.html" class="page">See all the available widgets</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>@Documentation</code> annotation is used to document the component (configuration in this scope).
A Talend Component Kit Maven plugin can be used to generate the component documentation with all the configuration description and the default values.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A default value is defined for sorting the query result.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Your component is configured. You can now create the component logic.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_component_mapper"><a class="anchor" href="#_defining_the_component_mapper"></a>Defining the component mapper</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Mappers defined with this tutorial don&#8217;t implement the split part because HTTP calls are not split on many workers in this case.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version
@Icon(value = Icon.IconType.CUSTOM, custom = "zendesk")
@PartitionMapper(name = "search")
@Documentation("Search component for zendesk query")
public class SearchMapper implements Serializable {

    private final SearchQuery configuration; <i class="conum" data-value="1"></i><b>(1)</b>
    private final SearchClient searchClient; <i class="conum" data-value="2"></i><b>(2)</b>

    public SearchMapper(@Option("configuration") final SearchQuery configuration, final SearchClient searchClient) {
        this.configuration = configuration;
        this.searchClient = searchClient;
    }

    @PostConstruct
    public void init() {
        searchClient.base(configuration.getDataStore().getUrl()); <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Assessor
    public long estimateSize() {
        return 1L;
    }

    @Split
    public List&lt;SearchMapper&gt; split(@PartitionSize final long bundles) {
        return Collections.singletonList(this); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Emitter
    public SearchSource createWorker() {
        return new SearchSource(configuration, searchClient); <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component configuration that is injected by the component framework</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The HTTP client created earlier in this tutorial. It is also injected by the framework via the mapper constructor.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The base URL of the HTTP client is defined using the configuration URL.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The mapper is returned in the split method because HTTP requests are not split.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A source is created to perform the HTTP request and return the search result.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_the_component_source"><a class="anchor" href="#_defining_the_component_source"></a>Defining the component source</h4>
<div class="paragraph">
<p>Once the component logic implemented, you can create the source in charge of performing the HTTP request to the search API and converting the result to <code>JsonObject</code> records.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchSource implements Serializable {

    private final SearchQuery config; <i class="conum" data-value="1"></i><b>(1)</b>
    private final SearchClient searchClient; <i class="conum" data-value="2"></i><b>(2)</b>
    private BufferizedProducerSupport&lt;JsonValue&gt; bufferedReader; <i class="conum" data-value="3"></i><b>(3)</b>

    private transient int page = 0;
    private transient int previousPage = -1;

    public SearchSource(final SearchQuery configuration, final SearchClient searchClient) {
        this.config = configuration;
        this.searchClient = searchClient;
    }

    @PostConstruct
    public void init() { <i class="conum" data-value="4"></i><b>(4)</b>
        bufferedReader = new BufferizedProducerSupport&lt;&gt;(() -&gt; {
            JsonObject result = null;
            if (previousPage == -1) {
                result = search(config.getDataStore().getAuthorizationHeader(),
                        config.getQuery(), config.getSortBy(),
                        config.getSortBy() == null ? null : config.getSortOrder(), null);
            } else if (previousPage != page) {
                result = search(config.getDataStore().getAuthorizationHeader(),
                        config.getQuery(), config.getSortBy(),
                        config.getSortBy() == null ? null : config.getSortOrder(), page);
            }
            if (result == null) {
                return null;
            }
            previousPage = page;
            String nextPage = result.getString("next_page", null);
            if (nextPage != null) {
                page++;
            }

            return result.getJsonArray("results").iterator();
        });
    }

    @Producer
    public JsonObject next() { <i class="conum" data-value="5"></i><b>(5)</b>
        final JsonValue next = bufferedReader.next();
        return next == null ? null : next.asJsonObject();
    }

    <i class="conum" data-value="6"></i><b>(6)</b>
    private JsonObject search(String auth, String query, String sortBy, String sortOrder, Integer page) {
        final Response&lt;JsonObject&gt; response = searchClient.search(auth, "application/json",
                query, sortBy, sortOrder, page);
        if (response.status() == 200 &amp;&amp; response.body().getInt("count") != 0) {
            return response.body();
        }

        final String mediaType = extractMediaType(response.headers());
        if (mediaType != null &amp;&amp; mediaType.contains("application/json")) {
            final JsonObject error = response.error(JsonObject.class);
            throw new RuntimeException(error.getString("error") + "\n" + error.getString("description"));
        }
        throw new RuntimeException(response.error(String.class));
    }

    <i class="conum" data-value="7"></i><b>(7)</b>
    private String extractMediaType(final Map&lt;String, List&lt;String&gt;&gt; headers) {
        final String contentType = headers == null || headers.isEmpty()
                || !headers.containsKey(HEADER_Content_Type) ? null :
                headers.get(HEADER_Content_Type).iterator().next();

        if (contentType == null || contentType.isEmpty()) {
            return null;
        }
        // content-type contains charset and/or boundary
        return ((contentType.contains(";")) ? contentType.split(";")[0] : contentType).toLowerCase(ROOT);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The component configuration injected from the component mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The HTTP client injected from the component mapper.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A utility used to buffer search results and iterate on them one after another.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The record buffer is initialized with the <code>init</code> by providing the logic to iterate on the search result. The logic consists in getting the first result page and converting the result into JSON records. The buffer then retrieves the next result page, if needed, and so on.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>next</code> method returns the next record from the buffer. When there is no record left, the buffer returns <code>null</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>In this method, the HTTP client is used to perform the HTTP request to the search API.<br>
Depending on the HTTP response status code, the results are retrieved or an error is thrown.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The <code>extractMediaType</code> method allows to extract the media type returned by the API.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You now have created a simple Talend component that consumes a REST API.</p>
</div>
<div class="paragraph">
<p>To learn how to test this component, refer to <a href="tutorial-test-rest-api.html" class="page">this tutorial</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing_a_rest_api"><a class="anchor" href="#_testing_a_rest_api"></a>Testing a REST API</h3>
<div id="tutorial-test-rest-api" class="paragraph">
<p>Testing code that consumes REST APIs can sometimes present many constraints: API rate limit, authentication token and password sharing, API availability, sandbox expiration, API costs, and so on.</p>
</div>
<div class="paragraph">
<p>As a developer, it becomes critical to avoid those constraints and to be able to easily mock the API response.</p>
</div>
<div class="paragraph">
<p>The component framework provides an API simulation tool that makes it easy to write unit tests.</p>
</div>
<div class="paragraph">
<p>This tutorial shows how to use this tool in unit tests.
As a starting point, the tutorial uses the component that consumes Zendesk Search API and that was created in <a href="tutorial-create-components-rest-api.html" class="page">a previous tutorial</a>. The goal is to add unit tests for it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For this tutorial, four <strong>tickets</strong> that have the <strong>open</strong> status have been added to the Zendesk test instance used in the tests.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To learn more about the testing methodology used in this tutorial, refer to <a href="testing-junit.html#_junit_4" class="page">Component JUnit testing</a>.</p>
</div>
<div class="sect3">
<h4 id="_creating_the_unit_test"><a class="anchor" href="#_creating_the_unit_test"></a>Creating the unit test</h4>
<div class="paragraph">
<p>Create a unit test that performs a real HTTP request to the Zendesk Search API instance.
You can learn how to create a simple unit test in <a href="tutorial-test-your-components.html" class="page">this tutorial</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    @Test
    public void searchQuery() {
        // Initiating the component test configuration <i class="conum" data-value="1"></i><b>(1)</b>
        BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com", "username", "password");
        final SearchQuery searchQuery = new SearchQuery(basicAuth, "type:ticket status:open", "created_at", "desc");

        // We convert our configuration instance to URI configuration <i class="conum" data-value="2"></i><b>(2)</b>
        final String uriConfig = SimpleFactory.configurationByExample()
                        .forInstance(searchQuery)
                        .configured().toQueryString();

        // We create our job test pipeline <i class="conum" data-value="3"></i><b>(3)</b>
        Job.components()
                .component("search", "zendesk://search?" + uriConfig)
                .component("collector", "test://collector")
                .connections()
                .from("search").to("collector")
                .build()
                .run();

        final List&lt;JsonObject&gt; res = component.getCollectedData(JsonObject.class);
        assertEquals(4, res.size());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Initiating:
<div class="ulist">
<ul>
<li>
<p>the authentication configuration using Zendesk instance URL and credentials.</p>
</li>
<li>
<p>the search query configuration to get all the open ticket, ordered by creation date and sorted in descending order.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Converting the configuration to a URI format that will be used in the job test pipeline,
using the <code>SimpleFactory</code> class provided by the component framework. <a href="services-pipeline.html#_job_builder" class="page">Read more about job pipeline</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating the job test pipeline. The pipeline executes the <code>search</code> component and redirects the result to the test <code>collector</code> component, that collects the search result.
The pipeline is then executed.
Finally, the job result is retrieved to check that the four tickets have been received. You can also check that the tickets have the <code>open</code> status.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The test is now complete and working. It performs a real HTTP request to the Zendesk instance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_transforming_the_unit_test_into_a_mocked_test"><a class="anchor" href="#_transforming_the_unit_test_into_a_mocked_test"></a>Transforming the unit test into a mocked test</h4>
<div class="paragraph">
<p>As an alternative, you can use mock results to avoid performing HTTP requests every time on the development environment. The real HTTP requests would, for example, only be performed on an integration environment.</p>
</div>
<div class="paragraph">
<p>To transform the unit test into a mocked test that uses a mocked response of the Zendesk Search API:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the two following JUnit rules provided by the component framework.</p>
<div class="ulist">
<ul>
<li>
<p><code>JUnit4HttpApi</code>: This rule starts a simulation server that acts as a proxy and catches all the HTTP requests performed in the tests.
This simulation server has two modes :</p>
<div class="ulist">
<ul>
<li>
<p><strong>capture</strong>    : This mode forwards the captured HTTP request to the real server and captures the response.</p>
</li>
<li>
<p><strong>simulation</strong> : this mode returns a mocked response from the responses already captured. This rule needs to be added as a class rule.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>JUnit4HttpApi</code>: This rule has a reference to the first rule. Its role is to configure the simulation server for every unit test. It passes the context of the running test to the simulation server. This rule needs to be added as a simple (method) rule.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Example to run in a simulation mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    private final MavenDecrypter mavenDecrypter = new MavenDecrypter();

    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi() <i class="conum" data-value="1"></i><b>(1)</b>
                                                        .activeSsl(); <i class="conum" data-value="2"></i><b>(2)</b>

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API); <i class="conum" data-value="3"></i><b>(3)</b>

    @Test
    public void searchQuery() {
        // the exact same code as above
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creating and starting a simulation server for this test class.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Activating SSL on the simulation server by calling the <code>activeSsl()</code> method. This step is required because the consumed API uses SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Adding the simulation server configuration provider that provides the test context to the simulation server.</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Make the test run in <strong>capture</strong> mode to catch the real API responses that can be used later in the simulated mode.<br>
To do that, set a new <code>talend.junit.http.capture</code> environment variable to <code>true</code>.
This tells the simulation server to run in a capture mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The captured response is saved in the <code>resources/talend.testing.http</code> package in a JSON format, then reused to perform the API simulation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing_a_component"><a class="anchor" href="#_testing_a_component"></a>Testing a component</h3>
<div id="tutorial-test-your-components" class="paragraph">
<p>This tutorial focuses on writing unit tests for the input component that was created in this <a href="tutorial-create-an-input-component.html" class="page">previous tutorial</a>.</p>
</div>
<div class="paragraph">
<p>This tutorial covers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>How to load components in a unit test.</p>
</li>
<li>
<p>How to create a job pipeline.</p>
</li>
<li>
<p>How to run the test in standalone mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The test class is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HazelcastMapperTest {

    @ClassRule
    public static final SimpleComponentRule COMPONENTS = new SimpleComponentRule(HazelcastMapperTest.class
                                                                                    .getPackage().getName()); <i class="conum" data-value="1"></i><b>(1)</b>

    private static HazelcastInstance instance; <i class="conum" data-value="2"></i><b>(2)</b>

    @BeforeClass
    public static void startInstanceWithData() { <i class="conum" data-value="3"></i><b>(3)</b>
        instance = Hazelcast.newHazelcastInstance();
        final IMap&lt;Object, Object&gt; map = instance.getMap(HazelcastMapperTest.class.getSimpleName());
        IntStream.range(0, 100).forEach(i -&gt; map.put("test_" + i, "value #" + i));
    }

    @AfterClass
    public static void stopInstance() { <i class="conum" data-value="4"></i><b>(4)</b>
        instance.getLifecycleService().shutdown();
    }

    @Test
    public void run() { <i class="conum" data-value="5"></i><b>(5)</b>
        Job.components() <i class="conum" data-value="6"></i><b>(6)</b>
                .component("source", "Hazelcast://Input?configuration.mapName=" + HazelcastMapperTest.class.getSimpleName())
                .component("output", "test://collector")
            .connections()
                .from("source").to("output")
            .build()
            .run();

        final List&lt;JsonObject&gt; outputs = COMPONENTS.getCollectedData(JsonObject.class); <i class="conum" data-value="7"></i><b>(7)</b>
        assertEquals(100, outputs.size());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SimpleComponentRule</code> is a JUnit rule that lets you load your component from a package. This rule also provides some test components like <code>emitter</code> and <code>collector</code>. Learn more about JUnit in <a href="testing-junit.html#_component_runtime_junit" class="page">this section</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using an embedded Hazelcast instance to test the input component.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating an embedded Hazelcast instance and filling it with some test data. A map with the name of the test class is created and data is added to it.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Cleaning up the instance after the end of the tests.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Defining the unit test. It first creates a job pipeline that uses our input component.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <a href="services-pipeline.html" class="page">pipeline builder</a> <code>Job</code> is used to create a job. It contains two components: the input component and the test collector component. The input component is connected to the collector component. Then the job is built and ran locally.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>After the job has finished running. The <code>COMPONENTS</code> rule instance is used to get the collected data from the <code>collector</code> component.
Once this is done, it is possible to do some assertion on the collected data.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_testing_in_a_continuous_integration_environment"><a class="anchor" href="#_testing_in_a_continuous_integration_environment"></a>Testing in a Continuous Integration environment</h3>
<div id="tutorial-dev-vs-ci-setup.adoc" class="paragraph">
<p>This tutorial shows how to adapt the test configuration of the Zendesk search component that was done in <a href="tutorial-test-rest-api.html" class="page">this previous tutorial</a> to make it work in a Continuous Integration environment.</p>
</div>
<div class="paragraph">
<p>In the test, the Zendesk credentials are used directly in the code to perform a first capture of the API response. Then, fake credentials are used in the simulation mode because the real API is not called anymore.</p>
</div>
<div class="paragraph">
<p>However, in some cases, you can require to continue calling the real API on a CI server or on a specific environment.</p>
</div>
<div class="paragraph">
<p>To do that, you can adapt the test to get the credentials depending on the execution mode (simulation/passthrough).</p>
</div>
<div class="sect3">
<h4 id="_setting_up_credentials"><a class="anchor" href="#_setting_up_credentials"></a>Setting up credentials</h4>
<div class="paragraph">
<p>These instructions concern the CI server or on any environment that requires real credentials.</p>
</div>
<div class="paragraph">
<p>This tutorial uses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="https://maven.apache.org/guides/mini/guide-encryption.html">Maven server</a> that supports password encryption as a credential provider. Encryption is optional but recommended.</p>
</li>
<li>
<p>The <code>MavenDecrypterRule</code> test rule provided by the framework. This rule lets you get credentials from Maven settings using a server ID.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To create encrypted server credentials for the Zendesk instance:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a master password using the command: <code>mvn --encrypt-master-password &lt;password&gt;</code>.</p>
</li>
<li>
<p>Store this master password in the <code>settings-security.xml</code> file of the <code>~/.m2</code> folder.</p>
</li>
<li>
<p>Encrypt the Zendesk instance password using the command: <code>mvn --encrypt-password &lt;zendesk-password&gt;</code>.</p>
</li>
<li>
<p>Create a server entry under <strong>servers</strong> in Maven <code>settings.xml</code> file located in the <code>~/.m2</code> folder.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;server&gt;
  &lt;id&gt;zendesk&lt;/id&gt;
  &lt;username&gt;username@email.com&lt;/username&gt;
  &lt;password&gt;The encrypted password {oL37x/xiSvwtlhrMQ=}&lt;/password&gt;
&lt;/server&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can store the <code>settings-security.xml</code> and <code>settings.xml</code> files elsewhere that the default location (<code>~/.m2</code>). To do that, set the path of the directory containing the files
in the <code>talend.maven.decrypter.m2.location</code> environment variable.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_adapting_the_unit_test"><a class="anchor" href="#_adapting_the_unit_test"></a>Adapting the unit test</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add the <code>MavenDecrypterRule</code> rule to the test class. This rule allows to inject server information stored in Maven <code>settings.xml</code> file to the test. The rule also decrypts credentials if they are encrypted.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Inject the Zendesk server to the test. To do that, add a new field to the class with the <code>@DecryptedServer</code> annotation, that holds the server ID to be injected.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);

    @DecryptedServer("zendesk")
    private Server server;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MavenDecrypterRule</code> is able to inject the server instance into this class at runtime. The server instance contains the username and the decrypted password.</p>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Use the <code>server</code> instance in the test to get the real credentials in a secured manner.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com",
                            server.getUsername(),
                            server.getPassword());</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once modified, the complete test class looks as follows:</p>
</div>
<div class="listingblock initial-block-closed">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SearchTest {

    @ClassRule
    public static final SimpleComponentRule component = new SimpleComponentRule("component.package");

    private final MavenDecrypter mavenDecrypter = new MavenDecrypter();

    @ClassRule
    public static final JUnit4HttpApi API = new JUnit4HttpApi()
                                                        .activeSsl();

    @Rule
    public final JUnit4HttpApiPerMethodConfigurator configurator = new JUnit4HttpApiPerMethodConfigurator(API);

    @Rule
    public final MavenDecrypterRule mavenDecrypterRule = new MavenDecrypterRule(this);

    @DecryptedServer("zendesk")
    private Server server;

    @Test
    public void searchQuery() {
        // Initiating the component test configuration
        BasicAuth basicAuth = new BasicAuth("https://instance.zendesk.com", server.getUsername(), server.getPassword());
        final SearchQuery searchQuery = new SearchQuery(basicAuth, "type:ticket status:open", "created_at", "desc");

        // We convert our configuration instance to URI configuration
        final String uriConfig = SimpleFactory.configurationByExample()
                        .forInstance(searchQuery)
                        .configured().toQueryString();

        // We create our job test pipeline
        Job.components()
                .component("search", "zendesk://search?" + uriConfig)
                .component("collector", "test://collector")
                .connections()
                .from("search").to("collector")
                .build()
                .run();

        final List&lt;JsonObject&gt; res = component.getCollectedData(JsonObject.class);
        assertEquals(4, res.size());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>This test will continue to work in simulation mode</strong>, because the API simulation proxy is activated.</p>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_the_ci_server_in_passthrough_mode"><a class="anchor" href="#_setting_up_the_ci_server_in_passthrough_mode"></a>Setting up the CI server in passthrough mode</h4>
<div class="paragraph">
<p>This tutorial shows how to set up a CI server in passthrough mode using <a href="https://jenkins.io/">Jenkins</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Log in to Jenkins.</p>
</li>
<li>
<p>Click <strong>New Item</strong> to create a new build job.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/jenkins/1_jenkins_new_item.png" target="_blank" rel="noopener"><img src="_images/jenkins/1_jenkins_new_item.png" alt="Create a new job"></a>
</div>
</div>
</li>
<li>
<p>Enter an Item name (Job name) and choose the freestyle job. Then click OK.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/jenkins/2_jenkins_new_item.png" target="_blank" rel="noopener"><img src="_images/jenkins/2_jenkins_new_item.png" alt="Create a new job"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Source Code Management</strong> section, enter your project repository URL. A GitHub repository is used in this tutorial.</p>
</li>
<li>
<p>Specify the <code>master</code> branch as <strong>Branches to build</strong>.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/jenkins/4_jenkins_source_code.png" target="_blank" rel="noopener"><img src="_images/jenkins/4_jenkins_source_code.png" alt="Source Code Management"></a>
</div>
</div>
</li>
<li>
<p>In the <strong>Build</strong> section, click <strong>Add build step</strong> and choose <strong>Invoke top-level Maven targets</strong>.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/jenkins/6_jenkins_build_cmd.png" target="_blank" rel="noopener"><img src="_images/jenkins/6_jenkins_build_cmd.png" alt="Build Section"></a>
</div>
</div>
</li>
<li>
<p>Choose your Maven version and enter the Maven build command. In this case: <code>clean install</code>. Then, click <strong>Save</strong>.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/jenkins/6_jenkins_build_cmd_2.png" target="_blank" rel="noopener"><img src="_images/jenkins/6_jenkins_build_cmd_2.png" alt="Build Section"></a>
</div>
</div>
<div class="paragraph">
<p>The <code>-Dtalend.junit.http.passthrough=true</code> option is part of the build command.
This option tells the API simulation proxy to run in <code>passthrough</code> mode. This way, all the HTTP requests made in the test are forwarded to the real API server.</p>
</div>
<div class="paragraph">
<p>The <code>MavenDecrypterRule</code> rule allows to get the real credentials.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can configure the <strong>passthrough</strong> mode globally on your CI server by setting the <code>talend.junit.http.passthrough</code> environment variable to <code>true</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Test the job by selecting <strong>Build now</strong>, and check that the job has built correctly.</p>
<div class="imageblock">
<div class="content">
<a class="image" href="https://talend.github.io/component-runtime/main/1.1.28/_images/jenkins/7_jenkins_build_result.png" target="_blank" rel="noopener"><img src="_images/jenkins/7_jenkins_build_result.png" alt="Test the job"></a>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now your tests run in a simulation mode on your development environment and in a passthrough mode on your CI server.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_component_version_migration"><a class="anchor" href="#_handling_component_version_migration"></a>Handling component version migration</h3>
<div id="tutorial-handle-talend-component-migration" class="paragraph">
<p>Talend Component Kit provides a migration mechanism between two versions of a component to let you ensure backward compatibility.</p>
</div>
<div class="paragraph">
<p>For example, a new version of a component may have some new options that need to be remapped, set with a default value in the older versions, or disabled.</p>
</div>
<div class="paragraph">
<p>This tutorial shows how to create a migration handler for a component that needs to be upgraded from a version 1 to a version 2. The upgrade to the newer version includes adding new options to the component.</p>
</div>
<div class="paragraph">
<p>This tutorial assumes that you know <a href="methodology-creating-components.html" class="page">the basics</a> about component development and are familiar with component project <a href="index-generating-project.html" class="page">generation</a> and <a href="index-creating-components.html" class="page">implementation</a>.</p>
</div>
<div class="sect3">
<h4 id="_requirements"><a class="anchor" href="#_requirements"></a>Requirements</h4>
<div class="paragraph">
<p>To follow this tutorial, you need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 8</p>
</li>
<li>
<p>A Talend component development environment using Talend Component Kit. Refer to <a href="system-prerequisites.html" class="page">this document</a>.</p>
</li>
<li>
<p>Have generated a project containing a simple processor component using the Talend Component Kit Starter.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_creating_the_version_1_of_the_component"><a class="anchor" href="#_creating_the_version_1_of_the_component"></a>Creating the version 1 of the component</h4>
<div class="paragraph">
<p>First, create a simple processor component configured as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a simple configuration class that represents a basic authentication and that can be used in any component requiring this kind of authentication.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
        @GridLayout.Row({ "username", "password" })
})
public class BasicAuth {

    @Option
    @Documentation("username to authenticate")
    private String username;

    @Option
    @Credential
    @Documentation("user password")
    private String password;
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Create a simple output component that uses the configuration defined earlier. The component configuration is injected into the component constructor.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(1)
@Icon(Icon.IconType.DEFAULT)
@Processor(name = "MyOutput")
@Documentation("A simple output component")
public class MyOutput implements Serializable {

    private final BasicAuth configuration;

    public MyOutput(@Option("configuration") final BasicAuth configuration) {
        this.configuration = configuration;
    }

    @ElementListener
    public void onNext(@Input final JsonObject record) {
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The version of the configuration class corresponds to the component version.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>By configuring these two classes, the first version of the component is ready to use a simple authentication mechanism.</p>
</div>
<div class="paragraph">
<p>Now, assuming that the component needs to support a new authentication mode following a new requirement, the next steps are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creating a version 2 of the component that supports the new authentication mode.</p>
</li>
<li>
<p>Handling migration from the first version to the new version.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_creating_the_version_2_of_the_component"><a class="anchor" href="#_creating_the_version_2_of_the_component"></a>Creating the version 2 of the component</h4>
<div class="paragraph">
<p>The second version of the component needs to support a new authentication method and let the user choose the authentication mode he wants to use using a dropdown list.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add an Oauth2 authentication mode to the component in addition to the basic mode. For example:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
        @GridLayout.Row({ "clientId", "clientSecret" })
})
public class Oauth2 {

    @Option
    @Documentation("client id to authenticate")
    private String clientId;

    @Option
    @Credential
    @Documentation("client secret token")
    private String clientSecret;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The options of the new authentication mode are now defined.</p>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Wrap the configuration created above in a global configuration with the basic authentication mode and add an enumeration to let the user choose the mode to use. For example, create an <code>AuthenticationConfiguration</code> class as follows:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GridLayout({
        @GridLayout.Row({ "authenticationMode" }),
        @GridLayout.Row({ "basic" }),
        @GridLayout.Row({ "oauth2" })
})
public class AuthenticationConfiguration {

    @Option
    @Documentation("the authentication mode")
    private AuthMode authenticationMode = AuthMode.Oauth2; // we set the default value to the new mode

    @Option
    @ActiveIf(target = "authenticationMode", value = {"Basic"})
    @Documentation("basic authentication")
    private BasicAuth basic;

    @Option
    @ActiveIf(target = "authenticationMode", value = {"Oauth2"})
    @Documentation("oauth2 authentication")
    private Oauth2 oauth2;


    /**
    * This enum holds the authentication mode supported by this configuration
    */
    public enum AuthMode {
        Basic,
        Oauth2;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Using the <code>@ActiveIf</code> annotation allows to activate the authentication type according to the selected authentication mode.
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Edit the component to use the new configuration that supports an additional authentication mode.
Also upgrade the component version from 1 to 2 as its configuration has changed.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(2) // upgrade the component version
@Icon(Icon.IconType.DEFAULT)
@Processor(name = "MyOutput")
@Documentation("A simple output component")
public class MyOutput implements Serializable {

    private final AuthenticationConfiguration configuration; // use the new configuration

    public MyOutput(@Option("configuration") final AuthenticationConfiguration configuration) {
        this.configuration = configuration;
    }

    @ElementListener
    public void onNext(@Input final JsonObject record) {
    }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The component now supports two authentication modes in its version 2.
Once the new version is ready, you can implement the migration handler that will take care of adapting the old configuration to the new one.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_the_migration_from_the_version_1_to_the_version_2"><a class="anchor" href="#_handling_the_migration_from_the_version_1_to_the_version_2"></a>Handling the migration from the version 1 to the version 2</h4>
<div class="paragraph">
<p><strong>What can happen if an old configuration is passed to the new component version?</strong></p>
</div>
<div class="paragraph">
<p>It simply fails, as the version 2 does not recognize the old version anymore.
For that reason, a migration handler that adapts the old configuration to the new one is required.
It can be achieved by defining a migration handler class in the <code>@Version</code> annotation of the component class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An old configuration may already be persisted by an application that integrates the version 1 of the component (Studio or web application).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_declaring_the_migration_handler"><a class="anchor" href="#_declaring_the_migration_handler"></a>Declaring the migration handler</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add a migration handler class to the component version.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Version(value = 2, migrationHandler = MyOutputMigrationHandler.class)</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="olist arabic">
<ol class="arabic" start="2">
<li>
<p>Create the migration handler class <code>MyOutputMigrationHandler</code>.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyOutputMigrationHandler implements MigrationHandler{ <i class="conum" data-value="1"></i><b>(1)</b>

       @Override
       public Map&lt;String, String&gt; migrate(final int incomingVersion, final Map&lt;String, String&gt; incomingData) { <i class="conum" data-value="2"></i><b>(2)</b>
           // Here we will implement our migration logic to adapt the version 1 of the component to the version 2
           return incomingData;
       }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The migration handler class needs to implement the <code>MigrationHandler</code> interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>MigrationHandler</code> interface specifies the <code>migrate</code> method. This method references:<br>
<div class="ulist">
<ul>
<li>
<p>the incoming version, which is the version of the configuration that we are migrating from</p>
</li>
<li>
<p>a map (key, value) of the configuration, where the key is the configuration path and the value is the value of the configuration.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_implementing_the_migration_handler"><a class="anchor" href="#_implementing_the_migration_handler"></a>Implementing the migration handler</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You need to be familiar with the component configuration path construction to better understand this part.
Refer to <a href="component-configuration.html" class="page">Defining component layout and configuration</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As a reminder, the following changes were made since the version 1 of the component:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The configuration <code>BasicAuth</code> from the version 1 is not the root configuration anymore, as it is under <code>AuthenticationConfiguration</code>.</p>
</li>
<li>
<p><code>AuthenticationConfiguration</code> is the new root configuration.</p>
</li>
<li>
<p>The component supports a new authentication mode (Oauth2) which is the default mode in the version 2 of the component.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To migrate the old component version to the new version and to keep backward compatibility, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remap the old configuration to the new one.</p>
</li>
<li>
<p>Give the adequate default values to some options.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the case of this scenario, it means making all configurations based on the version 1 of the component have the <code>authenticationMode</code> set to basic by default and remapping the old basic authentication configuration to the new one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyOutputMigrationHandler implements MigrationHandler{

       @Override
       public Map&lt;String, String&gt; migrate(final int incomingVersion, final Map&lt;String, String&gt; incomingData) {
           if(incomingVersion == 1){ <i class="conum" data-value="1"></i><b>(1)</b>
               // remapping the old configuration <i class="conum" data-value="2"></i><b>(2)</b>
               String userName = incomingData.get("configuration.username");
               String password = incomingData.get("configuration.password");
               incomingData.put("configuration.basic.username", userName);
               incomingData.put("configuration.basic.password", password);

               // setting default value for authenticationMode to Basic <i class="conum" data-value="3"></i><b>(3)</b>
               incomingData.put("configuration.authenticationMode", "Basic");
           }

           return incomingData; <i class="conum" data-value="4"></i><b>(4)</b>
       }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Safety check of the incoming data version to make sure to only apply the migration logic to the version 1.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Mapping the old configuration to the new version structure. As the <code>BasicAuth</code> is now under the root configuration class, its path changes and becomes <code>configuration.basic.*</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Setting a new default value to the <code>authenticationMode</code> as it needs to be set to <code>Basic</code> for configuration coming from version 1.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Returning the new configuration data.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
if a configuration has been renamed between 2 component versions, you can get the old configuration option from the configuration map by using its old path and set its value using its new path.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can now upgrade your component without losing backward compatibility.</p>
</div>
</div>
</div>
</div>
</div>
</div>
            </div>
          </div>
          <div class="col-sm-3 container article-side-panel">
            <nav class="article-anchors">
              <div class="article-side-actions">

                <ul>
                    <li>
                      <a class="article-side-actions-link" target="_blank" href="https://github.com/Talend/component-runtime/edit/master/documentation/src/main/antora/modules/ROOT/pages/all-in-one.adoc">
                        <i class="fa fa-edit"></i> &nbsp; &nbsp; Suggest an edit
                      </a>
                    </li>

                    <li>
                                <a class="article-side-actions-link" target="_blank"
                                   href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2F1.1.28%2Fall-in-one.html&text=Talend%20Component%20Kit%20%3E%3E%20Talend%20Component%20Kit%20Developer%20Guide%20%3E%3E%20&tw_p=tweetbutton&url=https%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2F1.1.28%2Fall-in-one.html">
                                    <i class="fab fa-twitter"></i> &nbsp; &nbsp; Tweet
                                </a>
                            </li>
                            <li>
                                <a class="article-side-actions-link"
                                   href="mailto:?subject=Talend%20Component%20Kit%3A%20Talend%20Component%20Kit%20Developer%20Guide&body=Talend%20Component%20Kit%3A%20Talend%20Component%20Kit%20Developer%20Guide%0A%0Ahttps%3A%2F%2Ftalend.github.io%2Fcomponent-runtime%2Fmain%2F1.1.28%2Fall-in-one.html">
                                    <i class="far fa-envelope"></i> &nbsp; &nbsp; Mail
                                </a>
                            </li>

                </ul>
              </div>
              <h1 class="article-side-toc">In this article</h1>
            </nav>
          </div>
          <a href="#top" class="top">Scroll to top</a>
        </div>
        <script>(window.talend = (window.talend || {})).article = true;</script>
    </article>
              </div>
            </main>
              <footer class="footer ">
    <div class="footer-with-copyright footer-with-links">
        <ul class="footer-links pull-left">
            <li><a class="gwt-Anchor" href="http://www.talend.com/">Talend</a></li>
            <li><a class="gwt-Anchor" href="http://www.talend.com/contact">Contact</a></li>
            <li><a class="gwt-Anchor" href="http://www.talend.com/legal-terms/us-eula">Talend EULA</a></li>
        </ul>
        <div class="footer-copyright pull-right" style="">&copy; 2019 Talend Inc. All rights reserved.</div>
    </div>
</footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
<script src="../../_/../js/anchorific.js"></script>
<script src="../../_/js/talend.js"></script>
  </body>
</html>
