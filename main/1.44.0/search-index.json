[{"lang":"en","title":"Beam testing","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/testing-beam.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Beam testing"],"description":"Learn how to test components in Beam","keywords":"test, Beam, Big Data, testing","text":["If you want to make sure that your component works in Beam and don’t want to use Spark, you can try with the Direct Runner.","Check beam.apache.org/contribute/testing/ for more details."]},{"lang":"en","title":"Building components with Gradle","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/build-tools-gradle.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Building components with Gradle"],"description":"Use Gradle or the Gradle wrapper as build tool to develop components","keywords":"gradle, tool, build","text":["To develop new components, Talend Component Kit requires a build tool in which you will import the component project generated from the starter. With this build tool, you will also be able to implement the logic of your component and to install and deploy it to Talend applications. A Talend Component Kit plugin is available for each of the supported build tools.","gradle-talend-component helps you write components that match the best practices. It is inspired from the Maven plugin and adds the ability to generate automatically the dependencies.txt file used by the SDK to build the component classpath. For more information on the configuration, refer to the Maven properties matching the attributes.","By default, Gradle does not log information messages. To see messages, use --info in your commands. Refer to Gradle’s documentation to learn about log levels.","You can use it as follows:"]},{"lang":"en","title":"Building components with Maven","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/build-tools-maven.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Building components with Maven"],"lvl1":["Maven lifecycle","Talend Component Kit Maven goals"],"lvl2":["Dependencies","Scan","SVG2PNG","Validating the component programming model","Generating the component documentation","Testing a component web rendering","Generating the component archive","Deploying to the Studio","Help"],"lvl3":["Rendering your documentation","HTML rendering","PDF rendering","Including the documentation into a document","Changing the UI bundle"],"description":"Use Maven or the Maven wrapper as build tool to develop components","keywords":"mvn, mvnw, maven, maven-plugin, tool, build","text":["To develop new components, Talend Component Kit requires a build tool in which you will import the component project generated from the starter.","You will then be able to install and deploy it to Talend applications. A Talend Component Kit plugin is available for each of the supported build tools.","talend-component-maven-plugin helps you write components that match best practices and generate transparently metadata used by Talend Studio.","You can use it as follows:","This plugin is also an extension so you can declare it in your build/extensions block as:","Used as an extension, the goals detailed in this document will be set up.","The Talend Component Kit plugin integrates some specific goals within Maven build lifecycle. For example, to compile the project and prepare for deploying your component, run mvn clean install. Using this command, the following goals are executed:","","The build is split into several phases. The different goals are executed in the order shown above. Talend Component Kit uses default goals from the Maven build lifecycle and adds additional goals to the building and packaging phases.","Goals added to the build by Talend Component Kit are detailed below. The default lifecycle is detailed in Maven documentation.","The Talend Component Kit plugin for Maven integrates several specific goals into Maven build lifecycle.","To run specific goals individually, run the following command from the root of the project, by adapting it with each goal name, parameters and values:","The first goal is a shortcut for the maven-dependency-plugin. It creates the TALEND-INF/dependencies.txt file with the compile and runtime dependencies, allowing the component to use it at runtime:","The scan-descriptor goal scans the current module and optionally other configured folders to precompute the list of interesting classes for the framework (components, services). It allows to save some bootstrap time when launching a job, which can be useful in some execution cases:","Configuration - excluding parameters used by default only:","Name","Description","User property","Default","output","Where to dump the scan result. Note: It is not supported to change that value in the runtime.","talend.scan.output","${project.build.outputDirectory}/TALEND-INF/scanning.properties","scannedDirectories","Explicit list of directories to scan.","talend.scan.scannedDirectories","If not set, defaults to ${project.build.outputDirectory}","scannedDependencies","Explicit list of dependencies to scan - set them in the groupId:artifactId format. The list is appended to the file to scan.","talend.scan.scannedDependencies","-","The svg2png goal scans a directory - default to target/classes/icons - to find .svg files and copy them in a PNG version size at 32x32px and named with the suffix _icon32.png to enable the studio to read it:","Configuration:","Name","Description","User property","Default","icons","Where to scan for the SVG icons to convert in PNG.","talend.icons.source","${project.build.outputDirectory}/icons","workarounds","By default the shape of the icon will be enforce in the RGB channels (in white) using the alpha as reference. This is useful for black/white images using alpha to shape the picture because Eclipse - Talend Studio - caches icons using RGB but not alpha channel, pictures not using alpha channel to draw their shape should disable that workaround.","talend.icons.workaround","true","if you use that plugin, ensure to set it before the validate mojo otherwise validation can miss some png files.","This goal helps you validate the common programming model of the component. To activate it, you can use following execution definition:","It is bound to the process-classes phase by default. When executed, it performs several validations that can be disabled by setting the corresponding flags to false in the <configuration> block of the execution:","Name","Description","User property","Default","validateInternationalization","Validates that resource bundles are presents and contain commonly used keys (for example, _displayName)","talend.validation.internationalization","true","validateModel","Ensures that components pass validations of the ComponentManager and Talend Component runtime","talend.validation.model","true","validateSerializable","Ensures that components are Serializable. This is a sanity check, the component is not actually serialized here. If you have a doubt, make sure to test it. It also checks that any @Internationalized class is valid and has its keys.","talend.validation.serializable","true","validateMetadata","Ensures that components have an @Icon and a @Version defined.","talend.validation.metadata","true","validateDataStore","Ensures that any @DataStore defines a @HealthCheck and has a unique name.","talend.validation.datastore","true","validateDataSet","Ensures that any @DataSet has a unique name. Also ensures that there is a source instantiable just filling the dataset properties (all others not being required). Finally, the validation checks that each input or output component uses a dataset and that this dataset has a datastore.","talend.validation.dataset","true","validateComponent","Ensures that the native programming model is respected. You can disable it when using another programming model like Beam.","talend.validation.component","true","validateActions","Validates action signatures for actions not tolerating dynamic binding (@HealthCheck, @DynamicValues, and so on). It is recommended to keep it set to true.","talend.validation.action","true","validateFamily","Validates the family by verifying that the package containing the @Components has a @Icon property defined.","talend.validation.family","true","validateDocumentation","Ensures that all components and @Option properties have a documentation using the @Documentation property.","talend.validation.documentation","true","validateLayout","Ensures that the layout is referencing existing options and properties.","talend.validation.layout","true","validateOptionNames","Ensures that the option names are compliant with the framework. It is highly recommended and safer to keep it set to true.","talend.validation.options","true","validateLocalConfiguration","Ensures that if any TALEND-INF/local-configuration.properties exists then keys start with the family name.","talend.validation.localConfiguration","true","validateOutputConnection","Ensures that an output has only one input branch.","talend.validation.validateOutputConnection","true","validatePlaceholder","Ensures that string options have a placeholder. It is highly recommended to turn this property on.","talend.validation.placeholder","false","locale","The locale used to validate internationalization.","talend.validation.locale","root","The asciidoc goal generates an Asciidoc file documenting your component from the configuration model (@Option) and the @Documentation property that you can add to options and to the component itself.","Name","Description","User property","Default","level","Level of the root title.","talend.documentation.level","2 (==)","output","Output folder path. It is recommended to keep it to the default value.","talend.documentation.output","${classes}/TALEND-INF/documentation.adoc","formats","Map of the renderings to do. Keys are the format (pdf or html) and values the output paths.","talend.documentation.formats","-","attributes","Asciidoctor attributes to use for the rendering when formats is set.","talend.documentation.attributes","-","templateEngine","Template engine configuration for the rendering.","talend.documentation.templateEngine","-","templateDir","Template directory for the rendering.","talend.documentation.templateDir","-","title","Document title.","talend.documentation.title","${project.name}","version","The component version. It defaults to the pom version","talend.documentation.version","${project.version}","workDir","The template directory for the Asciidoctor rendering - if 'formats' is set.","talend.documentation.workdDir","${project.build.directory}/talend-component/workdir","attachDocumentations","Allows to attach (and deploy) the documentations (.adoc, and formats keys) to the project.","talend.documentation.attach","true","htmlAndPdf","If you use the plugin as an extension, you can add this property and set it to true in your project to automatically get HTML and PDF renderings of the documentation.","talend.documentation.htmlAndPdf","false","To render the generated documentation in HTML or PDF, you can use the Asciidoctor Maven plugin (or Gradle equivalent). You can configure both executions if you want both HTML and PDF renderings.","Make sure to execute the rendering after the documentation generation.","If you prefer a HTML rendering, you can configure the following execution in the asciidoctor plugin. The example below:","Generates the components documentation in target/classes/TALEND-INF/documentation.adoc.","Renders the documentation as an HTML file stored in target/documentation/documentation.html.","If you prefer a PDF rendering, you can configure the following execution in the asciidoctor plugin:","If you want to add some more content or a title, you can include the generated document into another document using Asciidoc include directive.","For example:","To be able to do that, you need to pass the generated_doc attribute to the plugin. For example:","This is optional but allows to reuse Maven placeholders to pass paths, which can be convenient in an automated build.","You can find more customization options on Asciidoctor website.","Testing the rendering of your component configuration into the Studio requires deploying the component in Talend Studio. Refer to the Studio documentation.","In the case where you need to deploy your component into a Cloud (web) environment, you can test its web rendering by using the web goal of the plugin:","Run the mvn talend-component:web command.","Open the following URL in a web browser: localhost:8080.","Select the component form you want to see from the treeview on the left. The selected form is displayed on the right.","Two parameters are available with the plugin:","serverPort, which allows to change the default port (8080) of the embedded server. Its associated user property is talend.web.port.","serverArguments, that you can use to pass Meecrowave options to the server. Learn more about that configuration at openwebbeans.apache.org/meecrowave/meecrowave-core/cli.html.","Make sure to install the artifact before using this command because it reads the component JAR from the local Maven repository.","Finally, you can switch the lang of the component UI (documentation, form) using language query parameter in the webapp. For instance localhost:8080?language=fr.","If you built a custom UI (JS + CSS) bundle and want to test it in the web application, you can configure it in the pom.xml file as follows:","This is an advanced feature designed for expert users. Use it with caution.","Component ARchive (.car) is the way to bundle a component to share it in the Talend ecosystem. It is an executable Java ARchive (.jar) containing a metadata file and a nested Maven repository containing the component and its dependencies.","This command creates a .car file in your build directory. This file can be shared on Talend platforms.","This command has some optional parameters:","Name","Description","User property","Default","attach","Specifies whether the component archive should be attached.","talend.car.attach","true","classifier","The classifier to use if attach is set to true.","talend.car.classifier","component","metadata","Additional custom metadata to bundle in the component archive.","-","-","output","Specifies the output path and name of the archive","talend.car.output","${project.build.directory}/${project.build.finalName}.car","packaging","Specifies the packaging","-","${project.packaging}","This CAR is executable and exposes the studio-deploy command which takes a Talend Studio home path as parameter. When executed, it installs the dependencies into the Studio and registers the component in your instance. For example:","You can also upload the dependencies to your Nexus server using the following command:","In this command, Nexus URL and repository name are mandatory arguments. All other arguments are optional. If arguments contain spaces or special symbols, you need to quote the whole value of the argument. For example:","The deploy-in-studio goal deploys the current component module into a local Talend Studio instance.","Name","Description","User property","Default","studioHome","Path to the Studio home directory","talend.component.studioHome","-","studioM2","Path to the Studio maven repository if not the default one","talend.component.studioM2","-","You can use the following command from the root folder of your project:","The help goal displays help information on talend-component-maven-plugin. Call mvn talend-component:help -Ddetail=true -Dgoal=<goal-name> to display the parameter details of a specific goal.","Name","Description","User property","Default","detail","Displays all settable properties for each goal.","detail","false","goal","The name of the goal for which to show help. If unspecified, all goals are displayed.","goal","-","indentSize","Number of spaces per indentation level. This integer should be positive.","indentSize","2","lineLength","Maximum length of a display line. This integer should be positive.","lineLength","80"]},{"lang":"en","title":"Built-in services","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/services-built-in.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Built-in services"],"lvl1":["Lisf of built-in services","Using HttpClient"],"lvl2":["LocalConfiguration","Customizing HTTP client requests","Big data streams"],"lvl3":["Built-In configurer"],"description":"List of built-in services available with Talend Component Kit","keywords":"service, component-manager, internal, json, record, localconfiguration, provider, resolver, http client, http, record-schema","text":["The framework provides built-in services that you can inject by type in components and actions.","Type","Description","org.talend.sdk.component.api.service.cache.LocalCache","Provides a small abstraction to cache data that does not need to be recomputed very often. Commonly used by actions for UI interactions.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve a dependency from its Maven coordinates. It can either try to resolve a local file or (better) creates for you a preinitialized classloader.","javax.json.bind.Jsonb","A JSON-B instance. If your model is static and you don’t want to handle the serialization manually using JSON-P, you can inject that instance.","javax.json.spi.JsonProvider","A JSON-P instance. Prefer other JSON-P instances if you don’t exactly know why you use this one.","javax.json.JsonBuilderFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.JsonWriterFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.JsonReaderFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.stream.JsonParserFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","javax.json.stream.JsonGeneratorFactory","A JSON-P instance. It is recommended to use this one instead of a custom one to optimize memory usage and speed.","org.talend.sdk.component.api.service.dependency.Resolver","Allows to resolve files from Maven coordinates (like dependencies.txt for component). Note that it assumes that the files are available in the component Maven repository.","org.talend.sdk.component.api.service.injector.Injector","Utility to inject services in fields marked with @Service.","org.talend.sdk.component.api.service.factory.ObjectFactory","Allows to instantiate an object from its class name and properties.","org.talend.sdk.component.api.service.record.RecordBuilderFactory","Allows to instantiate a record.","org.talend.sdk.component.api.service.record.RecordPointerFactory","Allows to instantiate a RecordPointer which enables to extract a data from a Record based on jsonpointer specification.","org.talend.sdk.component.api.service.record.RecordService","Some utilities to create records from another one. It is typically what is used when you want to add an entry in a record and passthrough the other ones. It also provides a nice RecordVisitor API for advanced cases.","org.talend.sdk.component.api.service.configuration.LocalConfiguration","Represents the local configuration that can be used during the design.","It is not recommended to use it for the runtime because the local configuration is usually different and the instances are distinct.","You can also use the local cache as an interceptor with @Cached","Every interface that extends HttpClient and that contains methods annotated with @Request","Lets you define an HTTP client in a declarative manner using an annotated interface.","See the Using HttpClient for more details.","All these injected services are serializable, which is important for big data environments. If you create the instances yourself, you cannot benefit from these features, nor from the memory optimization done by the runtime. Prefer reusing the framework instances over custom ones.","The local configuration uses system properties and the environment (replacing dots per underscores) to look up the values. You can also put a TALEND-INF/local-configuration.properties file with default values. This allows to use the local_configuration:<key> syntax in @Ui annotation. Here is an example to read the default value of a property from the configuration:","Ensure your key is unique across all components to avoid global overrides on the JVM. In practice, it is strongly recommended to always use the family as a prefix. Also note that you can use @Configuration(\"prefix\") to inject a mapping of the LocalConfiguration in a component. It uses the same rules as for any configuration object. If you prefer to inject you configuration in a service, ensure to wrap it in a Supplier to always have an up to date version.","If you want to ignore the local-configuration.properties, you can set the system property: talend.component.configuration.${componentPluginId}.ignoreLocalConfiguration=true.","Here a sample @Configuration model:","Here is how to use it from a service:","And finally, here is how to use it in a component:","it is recommended to convert this configuration in a runtime model in components to avoid to transport more than desired during the job distribution.","You can access the API reference in the Javadocs.","The HttpClient usage is described in this section by using the REST API example below. Assuming that it requires a basic authentication header:","GET /api/records/{id}","-","POST /api/records","JSON payload to be created: {\"id\":\"some id\", \"data\":\"some data\"}","To create an HTTP client that is able to consume the REST API above, you need to define an interface that extends HttpClient.","The HttpClient interface lets you set the base for the HTTP address that the client will hit.","The base is the part of the address that needs to be added to the request path to hit the API. It is now possible, and recommended, to use @Base annotation.","Every method annotated with @Request in the interface defines an HTTP request. Every request can have a @Codec parameter that allows to encode or decode the request/response payloads.","You can ignore the encoding/decoding for String and Void payloads.","The interface should extend HttpClient.","In the codec classes (that implement Encoder/Decoder), you can inject any of your service annotated with @Service or @Internationalized into the constructor. Internationalization services can be useful to have internationalized messages for errors handling.","The interface can be injected into component classes or services to consume the defined API.","By default, /+json are mapped to JSON-P and /+xml to JAX-B if the model has a @XmlRootElement annotation.","For advanced cases, you can customize the Connection by directly using @UseConfigurer on the method. It calls your custom instance of Configurer. Note that you can use @ConfigurerOption in the method signature to pass some Configurer configurations.","For example, if you have the following Configurer:","You can then set it on a method to automatically add the basic header with this kind of API usage:","The framework provides in the component-api an OAuth1.Configurer which can be used as an example of configurer implementation. It expects a single OAuth1.Configuration parameter to be passed to the request as a @ConfigurationOption.","Here is a sample showing how it can be used:","By default, the client loads in memory the payload. In case of big payloads, it can consume too much memory. For these cases, you can get the payload as an InputStream:","You can use the Response wrapper, or not."]},{"lang":"en","title":"Changelog","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/changelog.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Changelog"],"lvl1":["Version 1.44.0","Version 1.43.0","Version 1.42.0","Version 1.41.1","Version 1.41.0","Version 1.40.0","Version 1.39.3","Version 1.39.2","Version 1.39.1","Version 1.39.0","Version 1.38.6","Version 1.38.5","Version 1.38.4","Version 1.38.3","Version 1.38.2","Version 1.38.1","Version 1.38.0","Version 1.37.1","Version 1.37.0","Version 1.36.1","Version 1.36.0","Version 1.35.1","Version 1.35.0","Version 1.34.1","Version 1.34.0","Version 1.33.3","Version 1.33.2","Version 1.33.1","Version 1.33.0","Version 1.32.2","Version 1.32.1","Version 1.32.0","Version 1.31.0","Version 1.30.0","Version 1.29.2","Version 1.29.1","Version 1.29.0","Version 1.28.2","Version 1.28.1","Version 1.28.0","Version 1.1.27","Version 1.1.26","Version 1.1.25","Version 1.1.24","Version 1.1.23","Version 1.1.22","Version 1.1.21","Version 1.1.20","Version 1.1.19","Version 1.1.18","Version 1.1.17","Version 1.1.16","Version 1.1.15","Version 1.1.15.2","Version 1.1.15.1","Version 1.1.14","Version 1.1.13","Version 1.1.12","Version 1.1.11","Version 1.1.10","Version 1.1.9","Version 1.1.8","Version 1.1.7","Version 1.1.6","Version 1.1.5","Version 1.1.4","Version 1.1.3","Version 1.1.2","Version 1.1.1","Version 1.1.0","Version 1.0.4","Version 1.0.3","Version 1.0.2","Version 1.0.1","Version 1.0.0","Version 0.0.12","Version 0.0.11","Version 0.0.10","Version 0.0.9","Version 0.0.8","Version 0.0.7","Version 0.0.6","Version 0.0.5","Version 0.0.4","Version 0.0.3","Version 0.0.2","Version 0.0.1"],"lvl2":["Bug","New Feature","Work Item","Epic","Backlog Task"],"description":"Talend Component Kit Changelog","keywords":"changelog, release note, latest changes, version","text":["TCOMP-2102: Wrong maven resolution with car when using snapshot in prepare-repository goal build maven-plugin","TCOMP-2119: Avro Record : array containing Null. beam schema-record","TCOMP-2112: [JDBC] discover schema API is failing on production. build maven-plugin","TCOMP-2085: Add extras manipulations on Record BuilderImpl beam schema-record","TCOMP-2103: Link affected jira components to issue in changelog as keywords for search documentation","TCOMP-2098: Improve m2 discovery process documentation","TCOMP-2104: Header link should be linked to latest path documentation","TCOMP-2105: Upgrade Tomcat to 9.0.60 component-server maven-plugin starter","TCOMP-2108: Upgrade maven plugins","TCOMP-2109: Upgrade git-commit-id-plugin to 4.0.5","TCOMP-2110: Replace log4j by reload4j stitch","TCOMP-2114: Upgrade TSBI to 2.9.27-20220331162145 component-server component-server-vault-proxy starter tsbi","TCOMP-2115: Upgrade jackson to 2.12.6 due to CVE-2020-36518 bom","TCOMP-2116: Upgrade log4j2 to 2.17.2","TCOMP-2117: Upgrade slf4j to 1.7.33","TCOMP-2118: Upgrade tomcat to 9.0.62 (mitigation for CVE-2022-22965) component-server component-server-vault-proxy starter","TCOMP-2003: Maven dependency classifier considered as version in dependencies.txt by Studio","TCOMP-2096: Support BigDecimal type in DI integration","TCOMP-2087: Upgrade Tomcat to 9.0.59 due to CVE-2022-23181","TCOMP-2088: Upgrade OpenWebBeans to 2.0.26","TCOMP-2089: Upgrade meecrowave to 1.2.13","TCOMP-2090: Upgrade johnzon to 1.2.16","TCOMP-2091: Upgrade Beam to 2.36.0","TCOMP-2092: MvnCoordinateToFileConverter fakes classifiers' support","TCOMP-2093: Improve component-runtime documentation site","TCOMP-2097: Upgrade cxf to 3.5.1","TCOMP-1803: RecordBuilder.withRecord(final String name, final Record value) doesn’t accept null value","TCOMP-2079: Intellij plugin fails on plugin startup","TCOMP-2080: AvroRecord refuses Union[null, RecordSchema]","TCOMP-2082: ComponentManager’s findDefaultM2 method takes comment as granted","TCOMP-2058: Add dependencies on config","TCOMP-2074: Change JSON log format to conform to ECS","TCOMP-2083: Give component-runtime version on ComponentManager startup","TCOMP-2084: Allow use of i18n in connectors' metadata for custom labels","TCOMP-2079: Intellij plugin fails on plugin startup","TCOMP-2080: AvroRecord refuses Union[null, RecordSchema]","TCOMP-2082: ComponentManager’s findDefaultM2 method takes comment as granted","TCOMP-2063: Avro Record Constructor","TCOMP-2064: NPE with lookup missconfiguration in Join processor","TCOMP-2067: Bug on order columns","TCOMP-2071: Define default methods on Schema / Entry / Record interfaces","TCOMP-2045: Pass and read meta information about columns.","TCOMP-2072: Ligthen parameters for component-server docker image","TCOMP-2057: AvroSchema : optimize getType by using type fields","TCOMP-2060: Upgrade log4j2 to 2.17.0 due to CVE-2021-45105","TCOMP-2061: Upgrade netty to 4.1.72.Final due to CVE-2021-43797","TCOMP-2065: Internationalized Services as Serializable","TCOMP-2068: Upgrade log4j2 to 2.17.1 due to CVE-2021-44832","TCOMP-2069: Create a latest tag for component-runtime images","TCOMP-2070: Upgrade TSBI to 2.9.18-20220104141654","TCOMP-2073: Upgrade maven-core to 3.8.4 due to CVE","TCOMP-2047: RecordBuilder in RowstructVisitor keeps values","TCOMP-2048: RowstructVisitor should respect case in member not java convention","TCOMP-2049: Incompatible class change on Entry","TCOMP-2053: Migration failing when using custom java code in configuration","TCOMP-2018: Optimize Avro Record","TCOMP-2054: Upgrade log4j2 to 2.16.0 due to CVE-2021-44228","TCOMP-2053: Migration failing when using custom java code in configuration","TCOMP-2054: Upgrade log4j2 to 2.16.0 due to CVE-2021-44228","TCOMP-2049: Incompatible class change on Entry","TCOMP-2047: RecordBuilder in RowstructVisitor keeps values","TCOMP-2048: RowstructVisitor should respect case in member not java convention","TCOMP-2019: Sanitized columns name collision support","TCOMP-2021: Missing logic when handling null date values in Record","TCOMP-2046: Rowstruct visitor recreates schema at each incoming row","TCOMP-2004: [Runtime convergence] New tck/API to retrieve dataset full content","TCOMP-2008: Add ability to insert a schema entry on Record BuilderImpl","TCOMP-1924: Support Java 17 runtime","TCOMP-2023: Upgrade gradle to 6.9.1","TCOMP-2024: Upgrade maven-bundle-plugin to 4.2.1","TCOMP-2025: Upgrade documentation to latest","TCOMP-2027: Upgrage junit to 5.8.1","TCOMP-2028: Provide nashorn scripting engine when using java15+","TCOMP-2029: Upgrade jaxb to 2.3.5","TCOMP-2030: Upgrade Tomcat to 9.0.54 due to CVE-2021-42340","TCOMP-2031: Upgrade Beam to 2.33.0","TCOMP-2032: Upgrade Spark to 3.2.0","TCOMP-2035: Check build w/ Java 17 on CI","TCOMP-2036: Upgrade cxf to 3.4.5","TCOMP-2037: Upgrade johnzon to 1.2.15","TCOMP-2038: Upgrade bouncycastle to 1.69","TCOMP-2042: Return a key related to version of connector services and its content","TCOMP-2043: Upgrade spotless to 2.17.3 and talend-java-formatter to 0.2.2","TCOMP-2044: Upgrade TSBI to 2.9.2-20211106085418","TCOMP-2105: Upgrade Tomcat to 9.0.60 component-server maven-plugin starter","TCOMP-2030: Upgrade Tomcat to 9.0.54 due to CVE-2021-42340","TCOMP-2053: Migration failing when using custom java code in configuration","TCOMP-2054: Upgrade log4j2 to 2.16.0 due to CVE-2021-44228","TCOMP-2048: RowstructVisitor should respect case in member not java convention","TCOMP-2047: RecordBuilder in RowstructVisitor keeps values","TCOMP-2046: Rowstruct visitor recreates schema at each incoming row","TCOMP-1963: Missing IMetaDataColumn fields in guess schema","TCOMP-1987: Avro record : Array of Array of records issue","TCOMP-1988: Unable to run component-runtime connectors in Studio with JDK 17","TCOMP-2005: Non defined columns appear in schema","TCOMP-2006: Support empty values for Numbers case","TCOMP-2010: Error on Documentation build on \"less\" usage","TCOMP-2020: talend-component-kit-intellij-plugin module build fails using Bintray (decomissioned)","TCOMP-1900: Create jenkins release process for component-runtime","TCOMP-1997: Enable plugins reloading according criteria","TCOMP-2000: Upgrade netty to 4.1.68.Final","TCOMP-2001: Upgrade Beam to 2.32.0","TCOMP-2007: connectors as a json object in Environment","TCOMP-2009: Upgrade dockerfile-maven-plugin to 1.4.13","TCOMP-2016: UiSchema can’t hold advanced titleMap for more advanded datalist widgets","TCOMP-2007: connectors as a json object in Environment","TCOMP-1957: Avro schema builder issue","TCOMP-1994: WebSocketClient$ClientException when executing action in Studio","TCOMP-1923: Record : add metadata","TCOMP-1990: Update jsoup to 1.14.2 due to CVE-2021-37714","TCOMP-1991: Update groovy to 3.0.9 due to CVE-2021-36373 / CVE-2021-36374","TCOMP-1992: Update lombok to 1.18.20","TCOMP-1993: Update TSBI to 2.9.0-20210907155713","TCOMP-1995: Expose the connectors (global) version in the \"Environment\" response","TCOMP-1996: BaseService must not define equals & hashcode","TCOMP-1994: WebSocketClient$ClientException when executing action in Studio","TCOMP-1904: Delegate Avro record in AvroRecord seems to be invalid","TCOMP-1967: goal uispec generation failure","TCOMP-1983: fix module inclusion in dependencies.txt when build is java9+","TCOMP-1981: Allow to filter artifacts in car file generation","TCOMP-1982: Allow to include extra artifacts in car file generation","TCOMP-1876: Make schemaImpl immutable","TCOMP-1885: Service Serializable","TCOMP-1906: Redefine equals on RecordImpl","TCOMP-1955: Upgrade cxf to 3.4.4 due to CVE-2021-30468","TCOMP-1966: Upgrade Tomcat to 9.0.50 due to CVE-2021-33037","TCOMP-1968: Upgrade maven to 3.8.1","TCOMP-1969: Upgrade Beam to 2.31.0","TCOMP-1970: Upgrade jackson to 2.12.1","TCOMP-1971: Upgrade Junit to 5.8.0-M1","TCOMP-1972: Upgrade slf4j to 1.7.32","TCOMP-1973: Upgrade log4j to 2.14.1","TCOMP-1974: Upgrade commons-compress to 1.21 due to CVE-2021-36090","TCOMP-1975: Upgrade TSBI to 2.8.2-20210722144648","TCOMP-1976: Upgrade meecrowave to 1.2.11","TCOMP-1977: Upgrade OpenWebBeans to 2.0.23","TCOMP-1978: Upgrade tomcat to 9.0.44","TCOMP-1979: Upgrade xbean to 4.20","TCOMP-1980: Upgrade meecrowave to 1.2.12","TCOMP-1967: goal uispec generation failure","TCOMP-1935: After Variables doesn’t support custom object types","TCOMP-1941: Maven goal talend-component:web fails on startup","TCOMP-1947: Implement a retry strategy on failure in vault-client","TCOMP-1948: Raised exception in component-server(s) should be serialized in json","TCOMP-1952: IllegalArgumentException when the http response return duplicated header.","TCOMP-1939: Upgrade TSBI to Talend 2.7.2-20210616074048","TCOMP-1940: Upgrade Beam to 2.30.0","TCOMP-1941: Maven goal talend-component:web fails on startup","TCOMP-1939: Upgrade TSBI to Talend 2.7.2-20210616074048","TCOMP-1919: Sanitize must force encoding file","TCOMP-1925: Incorrect mapping of the parameters after arrays","TCOMP-1937: Classpath not fully parsed in TSBI images","TCOMP-1917: Add DatasetDiscovery annotation","TCOMP-1707: Upgrade Geronimo :: Simple JCache to 1.0.5","TCOMP-1850: component-server with vault feature","TCOMP-1907: Service monitor implementation & cleaning of grafana dashboard","TCOMP-1921: Upgrade TSBI to 2.7.0-20210527090437","TCOMP-1930: Remove jsoup 1.7.x transitive dependency due to CVE-2015-6748","TCOMP-1936: Extend properties in Schema to use JsonValue","TCOMP-1938: Add the german locale in the locale mapping","TCOMP-1938: Add the german locale in the locale mapping","TCOMP-1937: Classpath not fully parsed in TSBI images","TCOMP-1919: Sanitize must force encoding file","TCOMP-1886: Errors on Schema.sanitizeConnectionName","TCOMP-1905: component-runtime fails to build with Java 11","TCOMP-1893: Upgrade to Beam 2.29.0 and use Beam’s Spark 3 specific module","TCOMP-705: Support After variables","TCOMP-1898: Add method to Record.Builder","TCOMP-1910: Upgrade commons-io to 2.8.0 due to CVE-2021-29425","TCOMP-1911: Upgrade cxf to 3.4.3 due to CVE-2021-22696","TCOMP-1912: Upgrade TSBI to 2.6.7-20210503202416","TCOMP-1938: Add the german locale in the locale mapping","TCOMP-1937: Classpath not fully parsed in TSBI images","TCOMP-1880: Engine Server returns binary data instead of json (aka does not respect the compressed header)","TCOMP-1886: Errors on Schema.sanitizeConnectionName","TCOMP-1815: Support of ComponentException in migration","TCOMP-1873: Add method getEntry on TCK Record Schema class","TCOMP-1892: Upgrade Spark to 3.0.1","TCOMP-1888: Remove/change validation of ComponentException","TCOMP-1894: Uniformize docker images entrypoints","TCOMP-1895: Enhance coercion in RecordConverters","TCOMP-1896: Upgrade TSBI to 2.6.4-20210331133410","TCOMP-1806: Double values are rounded to 5 decimal places in studio","TCOMP-1851: HttpClient implementation class is a Service with State","TCOMP-1864: JsonSchemaConverter and johnzon-jsonschema 1.2.9+ look incompatible","TCOMP-1866: Invalid number coercion on primitive type","TCOMP-1869: byte[] handling is incorrect in dynamic column","TCOMP-1871: Dynamic metadata name is not sanitized","TCOMP-1861: Add a 'props' property in the Schema","TCOMP-1863: Upgrade batik-codec to 1.14 due to CVE-2020-11988","TCOMP-1865: Upgrade cxf to 3.4.2","TCOMP-1867: Upgrade Apache Beam to 2.28.0","TCOMP-1878: Upgrade TSBI to 2.6.3-20210304090015","TCOMP-1688: Rewrite JsonSchema required rules to reflect component’s validation rules","TCOMP-1857: Pojo conversion don’t support nested Objects","TCOMP-1841: Add a SPI that would allow to add metadata to components","TCOMP-1847: Upgrade Apache Beam to 2.27.0","TCOMP-1848: Upgrade bouncycastle to 1.68 due to CVE 2020-28052","TCOMP-1849: Proxify metrics component-server’s endpoint","TCOMP-1852: Upgrade netty to v4.1.58.Final and ensure default http testing module is java 11 friendly over ssl","TCOMP-1854: Upgrade netty to 4.1.59.Final due to CVE-2021-21290","TCOMP-1855: Upgrade johnzon to 1.2.10","TCOMP-1856: Upgrade tomcat to 9.0.43","TCOMP-1841: Add a SPI that would allow to add metadata to components","TCOMP-1852: Upgrade netty to v4.1.58.Final and ensure default http testing module is java 11 friendly over ssl","TCOMP-1854: Upgrade netty to 4.1.59.Final due to CVE-2021-21290","TCOMP-1848: Upgrade bouncycastle to 1.68 due to CVE 2020-28052","TCOMP-1839: Tomcat websocket server fails to start after tomcat 9.0.40 and meecrowave 1.2.10","TCOMP-1836: Upgrade OpenWebBeans to 2.0.20","TCOMP-1837: Upgrade xbean to 4.18","TCOMP-1838: Upgrade cxf to 3.4.1","TCOMP-1840: Upgrade tomcat to 9.0.41","TCOMP-1842: Upgrade jgit to 5.10.0.202012080955-r","TCOMP-1844: Upgrade johnzon to 1.2.9","TCOMP-1845: Upgrade guava to 30.1-jre due to CVE-2020-8908","TCOMP-1848: Upgrade bouncycastle to 1.68 due to CVE 2020-28052","TCOMP-1839: Tomcat websocket server fails to start after tomcat 9.0.40 and meecrowave 1.2.10","TCOMP-1836: Upgrade OpenWebBeans to 2.0.20","TCOMP-1837: Upgrade xbean to 4.18","TCOMP-1827: Upgrade lombok to 1.18.16","TCOMP-1828: Change project’s versioning scheme","TCOMP-1829: Upgrade TSBI to 2.5.3-20201201131449","TCOMP-1830: Upgrade Apache Beam to 2.26.0","TCOMP-1832: Upgrade httpclient to 4.5.13 due to CVE-2020-13956","TCOMP-1833: Upgrade spark to 2.4.7","TCOMP-1834: Upgrade groovy to 3.0.7 due to CVE-2020-17521","TCOMP-1787: ComponentManager can’t be re-created after it’s been closed","TCOMP-1788: Invalid properties validation","TCOMP-1801: Can’t look for resources in the classpath on Windows","TCOMP-1761: Support of complete schema definition","TCOMP-1725: Upgrade Tomcat to 9.0.40","TCOMP-1792: Uniform error message on component validation","TCOMP-1808: Upgrade log4j2 to 2.14.0","TCOMP-1809: Update CXF to 3.3.8 due to CVE-2020-13954","TCOMP-1812: Upgrade junit to 4.13.1 due to CVE-2020-15250","TCOMP-1813: Upgrade jupiter to 5.7.0","TCOMP-1816: Apache Maven Shared Utils: OS Command Injection in Talend/component-runtime (master) and Talend/cloud-components","TCOMP-1817: Upgrade gmavenplus-plugin to 1.11.0","TCOMP-1722: REST - Last / in endpoint is removed","TCOMP-1757: Studio - context not set when call a @suggestable service","TCOMP-1772: Code widget doesn’t allow multiline text","TCOMP-1726: Update logos and colors","TCOMP-1771: Record builder optimization (with static schema)","TCOMP-1773: Upgrade log4j2 to 2.13.3","TCOMP-1774: Upgrade johnzon to 1.2.8","TCOMP-1775: Upgrade commons-lang3 to 3.11","TCOMP-1776: Upgrade commons-codec to 1.15","TCOMP-1777: Upgrade jgit to 5.9.0.202009080501-r","TCOMP-1778: Upgrade jib-core to 0.15.0","TCOMP-1779: Upgrade batik to 1.13","TCOMP-1780: Upgrade TSBI to 2.4.0-20200925092052","TCOMP-1781: Upgrade asciidoctorj to 2.4.1","TCOMP-1782: Upgrade rrd4j to 3.7","TCOMP-1783: Upgrade netty to 5.0.0.Alpha2","TCOMP-1784: Upgrade ziplock to 8.0.4","TCOMP-1785: Upgrade JRuby to 9.2.13.0","TCOMP-1786: Upgrade to Apache Beam 2.24.0","TCOMP-1804: Upgrade to Apache Beam 2.25.0","TCOMP-1805: Upgrade TSBI to 2.5.0-20201030171201","TCOMP-1770: Performance loss on Ouput components in Studio","TCOMP-1750: Deadlock at TPD job startup using the Component SDK and using the Workday component","TCOMP-1759: Guess schema mixes columns returned by tck service","TCOMP-1752: Make component-runtime class loader find classes in RemoteEngine JobServer","TCOMP-1764: Upgrade to Apache Beam 2.23.0","TCOMP-1719: Header responses for icon not propagated correctly from Component-server-vault-proxy","TCOMP-1733: NPE in Studio metadata connection with activeif on different layouts","TCOMP-1734: Studio froze when installing a patch with azure-dls-gen2-1.10.0-component.car","TCOMP-1736: JobImpl retrieves more than streaming.maxRecords parameter","TCOMP-1739: Use scala version defined on parent for Spark related components","TCOMP-1695: Support List type in Studio","TCOMP-1737: Allow to force installation of an already existing component with the car bundle","TCOMP-1728: Enforce use of the defined error contract in connectors","TCOMP-1731: Make connectors docker image TSBI compliant","TCOMP-1738: Upgrade to Apache Beam 2.22.0","TCOMP-1742: Upgrade johnzon to 1.2.7","TCOMP-1727: WebSocketContainer not present in ServletContext","TCOMP-1696: Definition of an error contract to handle expected errors","TCOMP-1729: Upgrade to Apache Beam 2.21.0","TCOMP-1730: Upgrade johnzon to 1.2.6","TCOMP-1719: Header responses for icon not propagated correctly from Component-server-vault-proxy","TCOMP-1649: Tomcat bump to 9.0.31 broke talend-component:web goal","TCOMP-1676: Starter-toolkit mvn package throws error when running for the first time","TCOMP-1677: Using other types than String in Studio’s context values causes compilation error","TCOMP-1679: Combination of @Required and @Suggestable on a field creates strange behaviour","TCOMP-1682: Remove key attribute in UISchema for containers","TCOMP-1686: antora helper function relativize corrupts documentation","TCOMP-1694: [MAVEN PLUGIN] validateSvg argument is ineffective","TCOMP-1698: UiSpecService injects a wrong property for suggestions and dynamic_values","TCOMP-1718: Duplicated code in RecordConverters","TCOMP-1702: Improve columns name","TCOMP-1655: Upgrade jib-core to 0.13.1","TCOMP-1656: Upgrade log4j2 to 2.13.1","TCOMP-1657: Upgrade maven to 3.6.3","TCOMP-1658: Upgrade groovy to 3.0.2","TCOMP-1659: Upgrade lombok to 1.18.12","TCOMP-1660: Upgrade commons-compress to 1.20","TCOMP-1661: Upgrade commons-codec to 1.14","TCOMP-1662: Upgrade guava to 28.2-jre","TCOMP-1663: Upgrade ziplock to 8.0.1","TCOMP-1664: Upgrade asciidoctorj to 2.2.0 and its dependencies","TCOMP-1665: Upgrade jackson to 2.10.3","TCOMP-1666: Upgrade batik-codec to 1.12","TCOMP-1667: Upgrade jgit to 5.6.1.202002131546-r","TCOMP-1668: Upgrade junit to 4.13","TCOMP-1669: Upgrade bouncycastle to 1.64","TCOMP-1670: Upgrade spark-core_2.11 to 2.4.5","TCOMP-1671: Upgrade maven-shade-plugin to 3.2.2","TCOMP-1672: Upgrade httpclient to 4.5.12","TCOMP-1673: Upgrade component-runtime-testing dependencies","TCOMP-1674: Upgrade tomitribe-crest to 0.14","TCOMP-1678: Upgrade jgit to 5.7.0.202003090808-r","TCOMP-1685: Provide docker images based on TSBI","TCOMP-1687: More explicit exception messsage on reflection for findField","TCOMP-1690: Upgrade netty to 4.1.48.Final","TCOMP-1692: Update CXF to 3.3.6 due to CVE-2020-1954","TCOMP-1697: Update BouncyCastle to 1.65","TCOMP-1703: Upgrade log4j-2 to 2.13.2","TCOMP-1705: Upgrade to Apache Beam 2.20.0","TCOMP-1706: Upgrade OpenWebBeans to 2.0.16","TCOMP-1708: Upgrade groovy to 3.0.3","TCOMP-1710: Upgrade johnzon to 1.2.5","TCOMP-1711: Upgrade guava to 29.0-jre","TCOMP-1712: Upgrade commons-lang3 to 3.10","TCOMP-1713: Upgrade jackson to 2.11.0","TCOMP-1714: Upgrade junit to 5.7.0-M1","TCOMP-1716: Upgrade maven shade plugin to 3.2.3 and misc libs","TCOMP-1639: component-server incorrect response set in request","TCOMP-1640: Ensure Intellij plugin works with Intellij Idea IU-201","TCOMP-1641: Upgrade OpenWebBeans to 2.0.15","TCOMP-1642: Upgrade Groovy to 3.0.1","TCOMP-1643: Add automatic scheduling eviction system on LocalCache","TCOMP-1644: Upgrade log4j to 2.13.0","TCOMP-1645: Ensure correct wording is used in @Documentation","TCOMP-1647: Upgrade netty to 4.1.45.Final","TCOMP-1648: Unsafe Dependancy Resolution on jcommander","TCOMP-1638: Inject services to delegate in proxy","TCOMP-1619: Handle correctly DATETIME field type on AvroRecord","TCOMP-1622: [DOC] @Icon is not supported on datastore/dataset","TCOMP-1623: Change scheme for maven repos","TCOMP-1628: Manage BigDecimal in RecordConverter","TCOMP-1629: Ensure LocalConfiguration environment source replace dot with _","TCOMP-1630: Avoid NPE when configurationByExample() is called in a list of primitive without values","TCOMP-1631: int attribute in pojo is transformed to double in a Record","TCOMP-1632: Add a way to evict cached data from LocalCache","TCOMP-1616: Upgrade OpenWebBeans to 2.0.14 in component-server and component-server-vault-proxy","TCOMP-1617: Move mocked api results to github pages","TCOMP-1618: Upgrade Junit to 5.6.0","TCOMP-1620: Upgrade to Apache Beam 2.18.0","TCOMP-1621: Upgrade to Johnzon 1.2.3","TCOMP-1624: @Service does not support list injections","TCOMP-1625: Upgrade to xbean 4.16","TCOMP-1626: Ensure ContainerListenerExtensions can be sorted","TCOMP-1627: Upgrade to Apache Beam 2.19.0","TCOMP-1633: Upgrade Groovy to 3.0.0","TCOMP-1634: Upgrade tomcat to 9.0.31","TCOMP-1596: Windows URI are broken","TCOMP-1597: Httpclient does not support multi query parameters","TCOMP-1598: validator task uses ENGLISH locale to validate instead of root one","TCOMP-1612: Starter toolkit shouldn’t use the default 'STAR' icon in demo component","TCOMP-1585: Upgrade netty to 4.1.43.Final","TCOMP-1586: Upgrade ziplock to v8.0.0","TCOMP-1587: Upgrade jib to v0.12.0","TCOMP-1588: Upgrade JRuby to v9.2.9.0","TCOMP-1589: Upgrade crest to v0.11.0","TCOMP-1591: Update to Tomcat 9.0.29","TCOMP-1592: Update to Johnzon 1.2.2","TCOMP-1593: Update to OpenWebBeans 2.0.13","TCOMP-1595: Infinite partitionmapper shouldn’t require assesor","TCOMP-1599: More unsafe usage tolerance on JVM versions","TCOMP-1600: Upgrade to Tomcat 9.0.30","TCOMP-1606: Ensure job dsl can stop infinite inputs","TCOMP-1608: Upgrade geronimo openapi to 1.0.12","TCOMP-1609: Ensure Intellij plugin works with Intellij Idea 2019","TCOMP-1611: Upgrade to Apache Beam 2.17.0","TCOMP-1613: Upgrade cxf to 3.3.5","TCOMP-1614: Upgrade groovy to 3.0.0-rc3","TCOMP-1615: Upgrade OpenWebBeans to 2.0.14","TCOMP-1560: Min and Max error message during configuration validation are reversed","TCOMP-1563: Web Tester does not work anymore (maven/gradle goal/task)","TCOMP-1573: Body encoder is called twice for each query","TCOMP-1582: Deploy to Nexus 3.15 caused \"Provided url doesn’t respond neither to Nexus 2 nor to Nexus 3 endpoints\"","TCOMP-1576: Add the possibility to desactivate http client redirection in HTTP Configurer","TCOMP-1559: Support configuration of the maxBatchSize enablement","TCOMP-1561: Custom action type shouldn’t need to be enforced to define a family method","TCOMP-1562: Support JsonObject type in actions","TCOMP-1564: Move to java.nio.Path instead of java.io.File in component-runtime-manager stack where possible","TCOMP-1565: Upgade to Junit Jupiter 5.6.0-M1","TCOMP-1566: Don’t compute jvmMarkers per component module but once for all","TCOMP-1567: Cache Artifact path in case of reuse","TCOMP-1568: Lazily create the container services","TCOMP-1569: Upgrade starter to gradle 6.0-rc1","TCOMP-1570: Ensure starter adds _placeholder entries in Messages.properties","TCOMP-1571: Support [length] syntax to change array configuration","TCOMP-1572: Validate that @Option is not used on final fields","TCOMP-1574: Upgrade to CXF 3.3.4","TCOMP-1575: Upgrade to Spark 2.4.4","TCOMP-1577: Upgrade to xbean 4.15","TCOMP-1578: Upgrade asciidoctor-pdf to v1.5.0-beta.7","TCOMP-1581: Support JUnit5 meta annotations for our extensions","TCOMP-1752: Make component-runtime class loader find classes in RemoteEngine JobServer","TCOMP-1702: Improve columns name","TCOMP-1685: Provide docker images based on TSBI","TCOMP-1558: org.talend.sdk.component.api.service.record.RecordService must be serializable","TCOMP-1548: Basic Remote Engine Customizer","TCOMP-1550: Component configuration instantiation can be slow for complex configurations","TCOMP-1551: ObjectFactory should default to fieldproperties when field injection is activated","TCOMP-1553: Simplify and widden excluded classes for with transformer support","TCOMP-1555: Upgrade to Tomcat 9.0.27","TCOMP-1556: Studio short, byte, BigDecimal and char types are wrong handled","TCOMP-1557: Upgrade to Beam 2.16.0","TCOMP-1509: Intellij plugin does not declare java module preventing the plugin to run under last versions","TCOMP-1526: Upgrade talend UI bundle (js) to 4.6.0","TCOMP-1533: JSON-B API does not enable to combine multiple adapters or (de)serializers in JsonbConfig","TCOMP-1536: @DefaultValue ignored in documentation generation","TCOMP-1541: Studio integration enforces JSON<→Record conversion instead of relying on rowStruct making number precision lost","TCOMP-1542: Validator plugin uses family instead of pluginId (artifactId) to validate local-configuration","TCOMP-1508: Don’t let Talend Starter Toolkit loose state on Enter in intellij","TCOMP-1543: Add a uispec mapper","TCOMP-1544: Update Geronimo JSON-P spec bundle to v1.3","TCOMP-1545: Update OpenWebBeans to version 2.0.12","TCOMP-1546: Update Meecrowave to 1.2.9","TCOMP-1547: Update Johnzon to 1.2.1","TCOMP-1279: Rewrite the pojo <→ record mapping to keep number types","TCOMP-1504: Apache Beam 2.14.0 upgrade","TCOMP-1505: Upgrade jackson-databind to 2.9.9.3","TCOMP-1506: Enable actions in bulk endpoint","TCOMP-1507: Upgrade to johnzon 1.1.13","TCOMP-1511: Upgrade cxf to v3.3.3","TCOMP-1513: Upgrade to Tomcat 9.0.24","TCOMP-1514: Provide a RecordService to simplify record enrichment coding in processors","TCOMP-1515: Record visitor API","TCOMP-1517: Use netty 4.1.39.Final in junit http tools","TCOMP-1518: Upgrade to slf4j 1.7.28","TCOMP-1519: Upgrade to jib-core 0.10.1","TCOMP-1520: Don’t use JsonNode with Avro Fields anymore","TCOMP-1521: Upgrade to Beam 2.15.0","TCOMP-1522: Basic singer/tap/stitch integration with kit components","TCOMP-1523: Upgrade Apache Geronimo OpenAPI to v1.0.11","TCOMP-1524: Upgrade starter to gradle 5.6","TCOMP-1525: Upgrade commons-compress to v1.19","TCOMP-1527: Remove beam Mapper/Processor wrapping support","TCOMP-1528: Upgrade to maven 3.6.2","TCOMP-1529: Asciidoctor 2.1.0 upgrade","TCOMP-1530: geronimo-annotation 1.2 upgrade","TCOMP-1532: Upgrade to Junit 5.5.2","TCOMP-1535: Upgrade to johnzon 1.2.0","TCOMP-1537: Upgrade to Tomcat 9.0.26","TCOMP-1538: Upgrade to jackson 2.9.10","TCOMP-1539: Rework default direct runner/spark classloader rules","TCOMP-1540: Ensure Asciidoctor documentation rendering releases properly JRuby threads (main usage only)","TCOMP-1478: /documentation/component/{id} internationalization does not work when embedded","TCOMP-1479: When generating the documentation, it can happen the lang is wrong due to ResourceBundle usage","TCOMP-1480: Servers docker images don’t have curl or wget available","TCOMP-1497: POJO to Record mapping is not supported in processors","TCOMP-1498: SVG2Mojo wrongly log the source file as being created","TCOMP-1499: component-form does not support array of object of object if 2 levels use the same field name","TCOMP-1500: Ensure component-form button have a key to have an id and propagate errors in the front","TCOMP-1503: EnvironmentSecuredFilter not working on /environment/","TCOMP-1482: Enable web tester to switch the language","TCOMP-1483: Enable to expose the documentation through the web tester","TCOMP-1485: Asciidoctor documentation does not enable titles (component name and configuration ones) to be translated","TCOMP-1486: Ensure locale mapping is configurable in component-server","TCOMP-1484: Junit 5.5.0 upgrade","TCOMP-1487: AsciidocMojo should only use ROOT locale by default","TCOMP-1488: Enable to translate gridlayout names","TCOMP-1489: Upgrade Tomcat to v9.0.22","TCOMP-1491: Upgrade JIB to v1.4.0","TCOMP-1492: Upgrade jackson-databind to 2.9.9.1","TCOMP-1493: Rewrite component exception to ensure they can be loaded after a serialization","TCOMP-1494: Upgrade to junit jupiter 5.5.1","TCOMP-1495: Upgrade to Geronimo OpenAPI 1.0.10","TCOMP-1496: [testing tool] MainInputFactory does not support Record","TCOMP-1501: Remove generate mojo","TCOMP-1502: [maven plugin] upgrade jib-core to 0.10.0","TCOMP-1469: Studio maven repository not found OOTB","TCOMP-1472: Connectors maven goal does not work in 1.1.10","TCOMP-1473: Docker image text log setup should use ISO8601 and not HH:mm:ss.SSS","TCOMP-1470: Upgrade Tomcat to v9.0.21","TCOMP-1471: Upgrade Geronimo OpenAPI to v1.0.9","TCOMP-1474: Ensure proxies definition are java >=11 friendly","TCOMP-1425: Spark classes not excluded anymore in component-runtime-beam leading to classloading issues","TCOMP-1427: dependencies.txt mojo uses timestamped versions for snapshots instead of just -SNAPSHOT","TCOMP-1431: [maven] Asciidoctor files should be attached with adoc extension and not jar one","TCOMP-1433: [form-model] itemwidget ignored from uischema builder","TCOMP-1438: Index cache can lead to invalid index list of component","TCOMP-1440: Bulk components without @ElementListener when used with component-extension (default in the server)","TCOMP-1441: Missing parameter init in the UiSchema Trigger builder","TCOMP-1446: Rework gradle lifecycle","TCOMP-1419: Upgrade build to groovy 2.5.7","TCOMP-1420: Upgrade maven compiler to 3.1.2","TCOMP-1422: Filter allowed beam classes in component-server image","TCOMP-1423: Enable to customize studio maven repository for deploy-studio maven and gradle goal/task","TCOMP-1426: Ensure Spark rule and @WithSpark uses a default version consistent with the runtime","TCOMP-1430: Deprecate built-in icons in favor of vendor specific icons","TCOMP-1432: basic dita generation for the component documentation","TCOMP-1434: [form-model] Add withCondition to UISchema builder","TCOMP-1435: Dont use beam_sdks_java_core shaded libraries","TCOMP-1437: Add infinite metadata to ComponentDetail","TCOMP-1444: Remove KnownJarsFilter since it is no more used to discover components","TCOMP-1445: Icon must support SVG","TCOMP-1448: [starter] provide a basic OpenAPI integration","TCOMP-1449: Upgrade XBean to v4.14","TCOMP-1450: Add a read-only bulk endpoint in component-server","TCOMP-1451: [upgrade] Johnzon 1.1.12","TCOMP-1452: [upgrade] Meecrowave 1.2.8","TCOMP-1453: Upgrade to CXF 3.3.2","TCOMP-1455: Prepare DateTime support in configurations","TCOMP-1457: Upgrade to Apache Beam 2.13.0","TCOMP-1458: Ensure _placeholder presence is encouraged and validated","TCOMP-1459: Experimental way to patch a component dependency","TCOMP-1461: Extension API for the validator plugin","TCOMP-1462: Validate through the corresponding build task provided SVG","TCOMP-1464: Upgrade to OpenWebBeans 2.0.11","TCOMP-1465: Upgrade to JUnit 5.5.0-RC1","TCOMP-1466: Upgrade to ziplock 8.0.0-M2","TCOMP-1467: Upgrade mock server (testing tool) to netty 5.0.0.Alpha2","TCOMP-1468: Support docker-compose >= 1.23 in vault-proxy","TCOMP-1374: ensure Utf8 avro strings don’t leak in AvroRecord API, even using get(Object.class, …)","TCOMP-1375: When two sources use the same dataset and one source has additional required parameter the validation fails","TCOMP-1384: Enhance studio guess schema algorithm to find implicitly the action to call if needed","TCOMP-1388: Can’t change the dataset name in starter","TCOMP-1389: Intellij starter fails to generate a project","TCOMP-1398: Using after option of @updateable can lead to a null pointer exception in component-form","TCOMP-1401: Documentation table is broken","TCOMP-1407: Databricks: interface javax.json.stream.JsonGeneratorFactory is not visible from class loader","TCOMP-1386: Add withRecord(String,Record) in Record.Builder","TCOMP-1387: Use icon bundle version 3.1.0","TCOMP-1412: Add rest and couchbase icon to component api","TCOMP-1376: Upgrade jupiter to 5.4.2","TCOMP-1385: talend.component.server.component.registry must be a list","TCOMP-1390: Move component-api to component-runtime repository","TCOMP-1392: Tomcat 9.0.19 upgrade","TCOMP-1402: Provide a placeholder for classpath extensions in docker images","TCOMP-1403: Upgrade asciidoctor to 2.0.0 and asciidoctor-pdf to alpha17","TCOMP-1404: Upgrade to Apache Beam 2.12.0","TCOMP-1408: Starter does not support types starting with a lowercase","TCOMP-1411: ComponentManager relies on beam jar name. This is unlikely and should move to beam integration module.","TCOMP-1417: Upgrade to Geronimo OpenAPI 1.0.8","TCOMP-1326: Avro Schema is not serializable as JSON so guess schema action does not work when compoennt-runtime-beam is present","TCOMP-1330: Shade extensions don’t inherit from pluginrepositories","TCOMP-1340: Tools webapp (talend-component:web) does not support changing the locale anymore","TCOMP-1343: Use LogicalTypes.timestampMillis() on DATETIME for avro record builder","TCOMP-1360: Renaming an option (@Option(\"custom\")) does not work on fields of type object","TCOMP-1370: ImageM2Mojo does not set timestamp in the docker image leading to component-server having a wrong lastUpdated value","TCOMP-1372: Nested components don’t expose their doc deterministicly until it is overriden","TCOMP-1341: Register deploy in studio task OOTB in gradle extension","TCOMP-1325: Upgrade CXF to 3.3.1","TCOMP-1327: /environment iterates over deployed plugin for each call, this is not needed","TCOMP-1328: Upgrade to Beam 2.11.0","TCOMP-1329: Lazy initialize parameter model to have a quicker cold start in plain main(String[])","TCOMP-1331: Use java 8u191 as base docker image","TCOMP-1332: Provide a simple way to filter configurations and component on /index endpoints","TCOMP-1334: Add a mojo to generate the list of components/services classes","TCOMP-1335: Add in doc mojo table the type of configuration the parameter belongs to","TCOMP-1336: Allow output processors to only have an @AfterGroup taking the list of record of the group in parameter","TCOMP-1346: Upgrade to Tomcat 9.0.17","TCOMP-1347: Upgrade to Slf4j 1.7.26","TCOMP-1348: [form-core] Ensure suggestions trigger is bound to \"change\" event too","TCOMP-1349: [form-core] When a tab is empty, don’t show it","TCOMP-1350: talend.component.server.component.registry should support glob pattern","TCOMP-1351: Upgrade jsoup for Spark Cluster Testing module","TCOMP-1353: component-server must not use TALEND-INF/dependencies.txt but another path","TCOMP-1354: Enforce services to belong to the delcaring service class","TCOMP-1361: Upgrade to asciidoctorj 2.0.0-RC.1","TCOMP-1362: Beam Wrapped Components should throw shared exception types","TCOMP-1366: Upgrade to XBean 4.13 to not track all classes scanned","TCOMP-1371: Upgrade to Apache Geronimo OpenAPI 1.0.7","TCOMP-1307: support char and character types in configuration.","TCOMP-1312: Component-form-core shouldn’t trigger validation of object due to conditional visibility (only individual fields are validable)","TCOMP-1314: category field of the starter is broken","TCOMP-1316: [build] Ensure snapshot use timestamped versions in dependencies.txt","TCOMP-1306: Add RecordPointerFactory to enable to extract data from Record using json pointer spec","TCOMP-1315: Ensure @Internationalized can use shortnames too in Messages.properties","TCOMP-1303: Support docker configs/secrets in docker images","TCOMP-1304: Vault proxy should support token configuration","TCOMP-1305: Upgrade to beam 2.10.0","TCOMP-1308: Upgrade to Talend UI 2.6.0","TCOMP-1309: Upgrade to Component API 1.1.5","TCOMP-1310: Ensure there is a basic secured mecanism to store configuration data","TCOMP-1317: Use Apache Geronimo Microprofile Config extensions (docker and secured string)","TCOMP-1318: Upgrade to Apache Meecrowave 1.2.7","TCOMP-1319: Upgrade Apache Geronimo Metrics to 1.0.3","TCOMP-1320: Upgrade to Apache Geronimo OpenAPI 1.0.6","TCOMP-1321: Upgrade to Apache Geronimo OpenTracing 1.0.2","TCOMP-1322: Upgrade to Apache Geronimo Config 1.2.2","TCOMP-1263: When using @Updateable(after=xxx) the visibility condition (@ActiveIf) of the after field shouldn’t be inherited","TCOMP-1264: AvroSchema does not unwrap null(able types) to map to Schema model","TCOMP-1265: dataset / datastore cloud validation : allow nested configuration types","TCOMP-1267: /documentation does not filter properly component","TCOMP-1281: Add jackson-mapper-asl in docker image of the server","TCOMP-1298: Support restricted lists for @Proposable","TCOMP-1297: make max batch size property configurable for family and components through LocalConfiguration","TCOMP-1266: Enhance starter to support dataset and datastore","TCOMP-1268: Ensure /environment is not callable if not local or secured","TCOMP-1269: Ensure ErrorReportValve does not leak Tomcat version OOTB","TCOMP-1271: Upgrade to talend UI 2.3.0","TCOMP-1272: Move multiSelectTag to multiSelect for web environment","TCOMP-1273: [build/dev plugin] Automatically open the browser for talend-component:web task/goal","TCOMP-1276: Exclude xerces from component loadable resources for XMLReaderFactory","TCOMP-1282: Upgrade meecrowave to 1.2.6","TCOMP-1283: Upgrade cxf to 3.3.0","TCOMP-1284: Upgrade to johnzon 1.1.11","TCOMP-1292: Provide a vault friendly integration for the server","TCOMP-1293: Upgrade to Tomcat 9.0.16","TCOMP-1295: Ensure local-configuration.properties of a container are merged","TCOMP-1296: Ensure user can enrich families with custom jar+configuration","TCOMP-1245: Provided services (SPI) by tacokit not available","TCOMP-1246: Rework docker image setup to use jib","TCOMP-1247: Upgrade geronimo metrics to 1.0.2","TCOMP-1248: Upgrade to geronimo opentracing 1.0.3","TCOMP-1249: Provide segment extractor for doc endpoint","TCOMP-1250: Make component documentation (@Documentation on component) i18n friendly","TCOMP-1251: cache avrocoders used in SchemaRegistryCoder","TCOMP-1252: Remove html support in documentation endpoint","TCOMP-1253: Refine OpenAPI documentation","TCOMP-1256: Add mapDescriptorToClassLoader to create a classloader from a list of gav","TCOMP-1258: Support to build a Record from a provided Schema","TCOMP-1259: Add getOptional to Record","TCOMP-1223: byte[] not supported in AvroRecord (beam)","TCOMP-1222: Ensure @WithComponents and @Environment are compatible","TCOMP-1234: Upgrade to beam 2.9.0","TCOMP-1235: Upgrade to antora 2","TCOMP-1237: Upgrade component-api to 1.1.2","TCOMP-1238: Upgrade metrics and opentracing microprofile libraries in docker image to use Geronimo extensions","TCOMP-1239: OpenWebBeans 2.0.9 upgrade","TCOMP-1240: Johnzon 1.1.11 upgrade","TCOMP-1242: Runtime validation error message wrongly interpolated","TCOMP-1243: Ensure component classloader isolates the system classloader resources except for the JVM ones","TCOMP-1170: [regression] http testing module pom imports netty and jsonb stack","TCOMP-1181: tacokit can’t pass the long type field from ui rightly","TCOMP-1187: Job DSL does not support correctly parameters when they are URI/URL","TCOMP-1189: Ensure primitive are not nullable in Record model (builder)","TCOMP-1191: [beam] BeamIOTransformer does not support serialization of complex objects correctly","TCOMP-1192: Ensure Avro schema union is interpreted as nullable in Record Schema model","TCOMP-1194: [testing] Ensure BeamEnvironment adds component-runtime-beam","TCOMP-1196: Nested maven repository not used for component module","TCOMP-1197: Tacokit beam tests. NPE when creating the schema with RECORD type.","TCOMP-1198: Tacokit beam tests. SchemaParseException ⇒ drop unsupported characters","TCOMP-1200: Packages not defined from nested repository classes","TCOMP-1201: includeTransitiveDependencies option of nested-maven-repository does not work","TCOMP-1202: Refine avro classloading exclusion to accept hadoop and mapred packages","TCOMP-1205: Empty JSon object lead to NPE","TCOMP-1209: Ensure SerializableCoder is replaced with a contextual version to support Talend Component Kit classloading model","TCOMP-1210: BeamComponentExtension should let the exception go back to the caller when the transform fails","TCOMP-1215: Nested maven repository in jars don’t go through transformers","TCOMP-1218: Record entries order shouldn’t be sorted by the runtime","TCOMP-1185: Support maxBatchSize in Job test runner for standalone mode","TCOMP-1171: Remove component proxy server from the project","TCOMP-1182: Ensure the property editor for the configuration registers the default converters","TCOMP-1183: Upgrade JRuby to 9.2.4.0","TCOMP-1184: Avoid to do a group by key in BeamExecutor (job DSL) when not needed","TCOMP-1188: Tolerate null for dates in Records","TCOMP-1190: Enable secure processing for DocumentBuilderFactory instances","TCOMP-1193: Add injectable ContainerInfo with the containerId (plugin) in services","TCOMP-1195: Enable user to extend BeamEnvironment test tempalte more easily","TCOMP-1199: Nested repository not used when the classpath is not composed of a single jar","TCOMP-1204: [dependency upgrade] XBean 4.12","TCOMP-1207: [beam] add ContextualSerializableCoder","TCOMP-1213: Upgrade guava to v27 for testing modules","TCOMP-1216: Take into account the visibility for the parameter validation","TCOMP-1217: Add JVM system property talend.component.runtime.serialization.java.inputstream.whitelist for our custom object input stream","TCOMP-1219: Upgrade starter to gradle 5","TCOMP-1220: Upgrade Maven to 3.6.0 in starter","TCOMP-1121: [tacokit proxy] suggestion trigger creation issue","TCOMP-1122: [tacokit proxy] slefRefrence filter configuration type by name, type and family","TCOMP-1123: Processor component onNext duplicate columns in record for rowStructs","TCOMP-1126: UiSpecService shouldn’t show the documentation by default","TCOMP-1129: form core - $selfReference breaks triggers","TCOMP-1130: component form - default value of maxBatchSize prop loose it type.","TCOMP-1131: [beam integration] Ensure Coder is contextual (classloader)","TCOMP-1132: Ensure beam custom Coders implement equals.hashCode for beam contract","TCOMP-1148: Asciidoctor documentation fails for collection of objects","TCOMP-1149: [testing] BeamEnvironment does not reset PipelineOptionsFactory properly for beam > 2.4","TCOMP-1155: [proxy server] arrays not supporting null values in ConfigurationFormatter","TCOMP-1159: AvroSchema does not support DATETTIME type (beam module)","TCOMP-1168: Avro record implementation ignores nullable/union","TCOMP-1143: Ensure icons are validated and fail the build if a custom one is missing (validate mojo)","TCOMP-1112: Let beam PTransform define an @ElementListener method to set the component design (inputs/outputs)","TCOMP-1113: Simplify the scanning by assuming there is a TALEND-INF/dependencies.txt in components","TCOMP-1120: BeamMapperImpl.isStream not accurate for UnboundedSource","TCOMP-1124: Add /metrics endpoint","TCOMP-1125: Extend CustomPropertyConverter to pass the convertion context","TCOMP-1127: Record doesn’t support null values","TCOMP-1133: CXF 3.2.7 upgrade","TCOMP-1134: Ensure any input/output have a dataset","TCOMP-1135: Ensure any dataset has a datastore","TCOMP-1136: deprecate \"generate\" mojo","TCOMP-1145: [dependency upgrade] Beam 2.8.0","TCOMP-1146: implement infinite=true in PartitionMapper/Input","TCOMP-1150: Upgrade rat plugin to 0.13","TCOMP-1154: Required validation at runtime ignores lists and nested objects","TCOMP-1157: [dependency upgrade] Tomcat 9.0.13","TCOMP-1158: Enable JUnit test collector to use a static storage instead of thread related one","TCOMP-1160: Upgrade spark to 2.4.0","TCOMP-1161: Upgrade shade plugin to 3.2.1","TCOMP-1162: Upgrade nested-maven-repository shade transformers to support last maven versions","TCOMP-1163: Upgrade openwebbeans to 2.0.8","TCOMP-1164: Validate mojo does not log any success information","TCOMP-1165: Dependency mojo does not log any success information","TCOMP-1166: Documentation mojo does not log generated files properly","TCOMP-1167: Beam-Avro record name generation should use avro fingerprint to be more unique than current logic","TCOMP-1086: Fix documentation about DiscoverSchema","TCOMP-1064: Update action can’t receive List<MyClass> parameter","TCOMP-1110: When a configuration has no layout and uses @AfterGroup the configuration is lost","TCOMP-1111: Move to PropertyEditorRegistry from xbean instead of using the deprecated static class","TCOMP-1000: @Option name value is not respected on fields","TCOMP-1008: Enum order is lost","TCOMP-1009: (web) OptionsOrder ignored for tables (List<MyClass>), fields located in random order","TCOMP-1028: [tools-webapp] submit button no more functional","TCOMP-1031: DiscoverSchema parameters are not correctly mapped in Studio GuessSchema runtime","TCOMP-1044: Fix java.lang.ClassCastException in TableActionParameter","TCOMP-1046: String option can’t set default value from a file","TCOMP-1056: ActiveIf doesn’t work in advanced settings","TCOMP-1072: Metadata migration issues","TCOMP-1074: talend-component mvn plugin : deploy-in-studio need to rise an error when component is already installed","TCOMP-1075: component reload file on windows after deploying a modified jar","TCOMP-1076: component starter - fix mapper generation (Record integration)","TCOMP-1077: component starter - ensure kit version are updated atomically.","TCOMP-1078: Guess Schema button is not shown on Basic Settings view","TCOMP-1082: Fix Exception during HealthCheck parameter deserialization","TCOMP-1085: [classloader] com.sun is too wide as exclusion","TCOMP-1104: Fix drag and drop issue for dataset/datastore metadata","TCOMP-779: Drop down list Java type in configuration class","TCOMP-819: Processor doesn’t produce more than 1 row on each iteration","TCOMP-917: Migration handler need only to receive component configuration","TCOMP-941: Default and init values are ignored in connection wizzard (datastore/dataset)","TCOMP-968: Trigger AsyncValidation call only when option annotated with Validable is changed","TCOMP-970: Add support for complex parameter types for AsyncValidation methods","TCOMP-973: component migration - the configuration version need to be serialized in addition to the version of the component","TCOMP-984: Integrate ParameterizedTest with component-runtime-http-junit capture mode","TCOMP-988: component migration - fix nested configuration migration","TCOMP-989: .car studio install command breaks config.ini of the studio","TCOMP-991: metadat : ignore activations from config not being part of the form while creating metadata","TCOMP-996: metadata : migration issues","TCOMP-1001: [proxy] ConfigurationClient should expose a migrate method","TCOMP-1011: Ensure datastore/dataset i18n names are validated by the maven/gradle plugins","TCOMP-1013: Add an operator support in @ActiveIfs (OR/AND switch)","TCOMP-1014: Ensure a dataset has a source which has no other required parameters in the validator","TCOMP-1029: Extend ActiveIf EvaluationStrategy with CONTAINS strategy","TCOMP-1063: Integrate Record API to the studio","TCOMP-1069: restrict input branches for output components to only one.","TCOMP-1071: support actions i18n display name","TCOMP-1092: Ensure @Configuration POJO are injectable as Supplier in services","TCOMP-1094: Add FullSerializationRecordCoder coder for Record in beam module","TCOMP-1095: Ensure all configuration type models root entries are named \"configuration\"","TCOMP-993: [proxy] Propagate UiSpecContext in referenceservice#findByTypeAndName","TCOMP-994: [dependency upgrade] CXF 3.2.6","TCOMP-1003: [dependency upgrade] Tomcat 9.0.12","TCOMP-1004: [dependency upgrade] Log4j2 2.11.1","TCOMP-1015: Upgrade icons to 1.0.0","TCOMP-1019: (form) enum should lead to restricted datalist","TCOMP-1037: [dependency upgrade] Johnzon 1.1.9","TCOMP-1038: Drop spring client from component-form-core","TCOMP-1041: HttpClient should enable to process InputStream directly","TCOMP-1042: Upgrade to JUnit 5.3.1","TCOMP-1045: Add documentation in metadata and enable to use it in the UI on configuration","TCOMP-1047: Make Suggestable text field editable (align with web)","TCOMP-1048: Add update API for configuration","TCOMP-1049: Add completion support for actions displayname in intellij plugin","TCOMP-1050: Provide simple OAuth1 integration","TCOMP-1051: Remove brave and move to geronimo-opentracing","TCOMP-1054: Introduce @Configuration API","TCOMP-1055: remove the ExecutionResource","TCOMP-1057: Add ActiveIf on @Proposable test-case","TCOMP-1058: Add DefaultValue on proposable/dynamicValue testcase","TCOMP-1059: Rework generic record format","TCOMP-1073: [maven/gradle plugin] Add configuration support in web goal","TCOMP-1079: Document new Record structure","TCOMP-1080: [dependency upgrade] Meecrowave 1.2.4","TCOMP-1081: ComponentManager should ignore engine classes in its filtering","TCOMP-1087: Jsonb service should serialize byte[] as BASE64","TCOMP-1089: [starter] Upgrade gradle to 4.10.2","TCOMP-1090: [form] Main/Advanced order not respected when some remote action are involved","TCOMP-1091: Ensure main component is preferred over test ones in a maven project","TCOMP-1093: [dependency upgrade] netty 4.1.30.Final for junit http testing module","TCOMP-1096: [dependency upgrade] xbean 4.10","TCOMP-1097: [dependency upgrade] Beam 2.7.0","TCOMP-1099: Upgrade web ui bundle to 1.0.2","TCOMP-1101: Add conditional rendering in the generated documentation","TCOMP-1102: Reflect in documentation that Validable/AsyncValidation doesn’t support Object types","TCOMP-1106: Enable to generate the component documentation in multiple languages","TCOMP-1107: ConfigurableClassLoader does not priviledges container classloader for getResourceAsStream","TCOMP-877: [documentation] Sample implementation of bulk/batch/commit-interval using groups","TCOMP-980: Provide a ValidationService in server-proxy","TCOMP-985: Align docker git metada on out Standard","TCOMP-998: [dependency upgrade] Apache Commons Compress 1.18","TCOMP-911: Suggestions callback doesn’t support Configuration parameters","TCOMP-921: String cannot be cast to Boolean when adding table with checkboxes","TCOMP-922: component manager : support loading dependencies from job lib folder.","TCOMP-924: component-kit.js errors are not sent to the error handler","TCOMP-927: talend-component:web errors are not always unwrapped and understandable","TCOMP-934: Ensure Studio rely on category and doesn’t append family name","TCOMP-960: Suggestions parameters are not correctly resolved in Studio","TCOMP-961: Default value of Suggestions method parameter is ignored","TCOMP-964: ClassCastException is thrown when non-string values are used as Suggestions method parameter","TCOMP-825: Provide component server proxy","TCOMP-928: Add negate and evaluation strategy to @ActiveIf","TCOMP-929: Ensure category contains the family","TCOMP-816: Check migration feature and implement missing use-cases","TCOMP-918: create a mvn bom with tacokit stack to keep some dependencies aligned between component-runtime and it’s studio integration","TCOMP-932: Avoid Kafka recursive logging for component server","TCOMP-933: Drop component-kit.js module","TCOMP-935: Component server should log application and service in kafka mode","TCOMP-938: Add a builtin::http trigger in the server proxy","TCOMP-939: Ensure the proxy server can lookup references with a SPI","TCOMP-943: (web) Grand parent references for triggers not well resolved","TCOMP-944: (proxy server) Ensure the trigger are well resolved for references","TCOMP-947: (maven/gradle) ensure web task logs there is a UI","TCOMP-953: Upgrade to ziplock 7.0.5","TCOMP-954: Upgrade netty to 4.1.28.Final for the test stack","TCOMP-958: Componentvalidator error message in case of an unsupported type is misleading","TCOMP-959: [dependency upgrade] Upgrade to icon bundle 0.202.0","TCOMP-962: .car deploy-in-studio command (CarMain) should support to override an existing version","TCOMP-965: [dependency upgrade] Apache Beam 2.6.0","TCOMP-966: Ensure Studio integration renames HTTP threads to identify them more explicitly","TCOMP-967: Ensure parameter index is in metadata for services and constructors","TCOMP-919: Starter doesn’t synchronize correctly with central versions","TCOMP-920: Use Meecrowave 1.2.3","TCOMP-888: Designer pipeline records counter are wrong for tacokit components with multiples outputs","TCOMP-899: Update Beam 2.5.0 compatibility","TCOMP-903: [tacokit studio integration] - Guess schema - better handling of number types recognition","TCOMP-904: [tacokit studio integration] - fix job classpath generation","TCOMP-913: Fix absolute path resolution for child of child use-case","TCOMP-900: [tacokit studio integration] - Handle conditional outputs","TCOMP-898: Ensure starter will be able to auto update its versions to avoid redeployments","TCOMP-905: Enrich scanning exclusion set","TCOMP-906: Minimalist JsonObject to IndexeredRecord utilities for beam","TCOMP-907: Support maxBatchSize as in the studio in Beam","TCOMP-910: Add maxbatchsize as built in parameter to Processor meta model","TCOMP-915: Upgrade Apache Meecrowave to 1.2.2","TCOMP-822: [Windows] deploy-in-studio & car copy jar command in mvn plugin - don’t work if the studio is running","TCOMP-844: Service default method forwarded to interface method instead of implementation one if exists","TCOMP-848: [junit5] implicit mock collector and emitter are not resetted per method","TCOMP-851: [form] UiSchema shouldn’t have a JsonSchema","TCOMP-858: @OptionsOrder not respected by form-core","TCOMP-862: [form-core] \"..\" path is not correctly resolved","TCOMP-863: Job DSL doesn’t support multiple outputs","TCOMP-873: Fix shade junit-http module : remove shaded dependencies from generated artifact","TCOMP-889: [form] arrays are lost in trigger paths","TCOMP-890: Merge the component outputs (by name) from @AfterGroup and @ElementListener","TCOMP-893: Don’t log a warning for services when parameters don’t have i18n support","TCOMP-834: Ensure that component has only one configuration argument.","TCOMP-845: [junit] ComponentsHandler misses findService","TCOMP-846: [junit] allow to inject current plugin services in test class","TCOMP-847: Support gzip in JUnit HTTP tooling","TCOMP-849: [junit http] support to match the request payload","TCOMP-850: MavenDecrypter should tolerate ${env.xxx} syntax","TCOMP-861: Ensure Car Mojo can be skipped","TCOMP-887: [studio] add chunk size advanced common param for processors & output","TCOMP-892: Validate runtime configuration before executing the runtime","TCOMP-829: Configuration Type tree is not correctly computed","TCOMP-830: Move all configuration to Microprofile Config instead of DeltaSpike","TCOMP-832: Provide a way to access lastUpdatedTimestamp in rest api","TCOMP-833: Upgrade gradle+maven for the starter","TCOMP-839: Add an API to load lazily the potential values of a list","TCOMP-840: Upgrade icon bundle to 0.190.2","TCOMP-841: Add validation of option names in the validator","TCOMP-852: [dependency upgrade] Upgrade shrinkwrap-resolver-impl-maven to 3.1.3","TCOMP-855: Support service injections in services","TCOMP-856: [dependency upgrade] OpenWebBeans 2.0.6","TCOMP-857: SimpleCollector must not depend on junit 4","TCOMP-864: Mojo should be thread safe for car/dependencies.txt generation","TCOMP-867: Expose Injector service","TCOMP-868: Create an ObjectFactory service","TCOMP-869: Ensure actions can get injected the requested lang","TCOMP-870: Provide Beam DoFn to simplify the migration from IndexedRecord to JsonObject","TCOMP-876: Allow custom converters in form-core","TCOMP-878: Add beam in the docker image OOTB","TCOMP-879: CarMojo doesn’t use car extension to attach the artifact","TCOMP-880: [dependency upgrade] Maven 3.5.4","TCOMP-881: [dependency upgrade] CXF 3.2.5","TCOMP-882: [dependency upgrade] Tomcat 9.0.10","TCOMP-883: [dependency upgrade] Beam 2.5.0","TCOMP-884: [dependency upgrade] Upgrade to icon bundle 0.197.0","TCOMP-894: [dependency upgrade] Johnzon 1.1.8","TCOMP-895: [dependency upgrade] xbean 4.9","TCOMP-827: Fix Automatic-Module-Name","TCOMP-811: Upgrade to tomcat 9.0.8","TCOMP-826: Extract component model from component server to a new artifact","TCOMP-763: Add a dev mode in the studio for tacokit","TCOMP-802: Add method to upload dependencies from .car to nexus","TCOMP-808: Upgrade to JUnit 5.2.0","TCOMP-809: compress js and css for the starter","TCOMP-810: ui spec service uses a multiselecttag for a proposable on a string field","TCOMP-804: Idea plugin doesn’t render properly configuration inputs","TCOMP-798: intellij plugin - add official starter url","TCOMP-799: @Checkable expects the datastore name to match the validation name","TCOMP-806: Ensure server and starter support gzip","TCOMP-643: Deployment","TCOMP-770: Removing component from web UI causes wrong number of components in summary","TCOMP-775: Starter - Fix properties keys generation","TCOMP-776: component-kit.js ignore credentials","TCOMP-783: ActiveIfs doesn’t make option visible","TCOMP-796: Datastore check (@Checkable) should default meta parameters to \"datastore\" if none is found","TCOMP-773: Extend the http client api to handle more generic use cases","TCOMP-771: ConfigurableClassLoader should skip scala.* classes","TCOMP-772: Upgrade icon set to ui/icons 0.179.0","TCOMP-774: Upgrade xbean to 4.8","TCOMP-768: More tolerance of configuration prefix for implicit migration of configuration node in form core library","TCOMP-756: Setup maven clirr plugin for component-api +testing","TCOMP-762: Starter should only propose a single category level in the ui","TCOMP-767: Ensure the configurationtype endpoints have matching name/path values","TCOMP-761: Merge component-runtime-manager and component-runtime-standalone","TCOMP-764: Clean up component-form-core dependencies","TCOMP-765: Upgrade to batik 1.9.1","TCOMP-752: Fix Advanced settings and Test connection button appearance in repository wizard","TCOMP-757: Duplicate method name \"writeReplace\" with signature \"()Ljava.lang.Object;\" in class file","TCOMP-751: Support gzip compression on component-server","TCOMP-753: Make classpath scanning to find component configurable","TCOMP-758: Support component-server server configuration from system properties","TCOMP-759: Enum must be i18n","TCOMP-738: Component Server should respect ~/.m2/settings.xml local repository if it exists","TCOMP-739: SerializationTransformer shouldn’t use ComponentManager to avoid ClassNotFoundException","TCOMP-740: UISpecService should be reactive and use a CompletionStage based API","TCOMP-741: UISpecService configuration support","TCOMP-742: Configuration Type properties should be rooted","TCOMP-744: Ensure wrapped BeamIO uses the right TCCL","TCOMP-745: [Dependency Upgrade] CXF 3.2.4","TCOMP-746: [Dependency Upgrade] Tomcat 9.0.6","TCOMP-747: [Dependency Upgrade] Log4j2 2.11.0","TCOMP-748: Make configurationtype index endpoint lighter OOTB","TCOMP-749: Intellij Idea plugin","TCOMP-750: Unify @Pattern using javascript regex instead of a mixed mode","TCOMP-734: Add support for context and globalMap values in Tacokit component settings","TCOMP-733: support to use a beam pipeline under the hood for beam components in di","TCOMP-693: Integrate Migration API","TCOMP-737: upgrade to beam 2.4.0","TCOMP-731: Configuration Type migration handler skipped","TCOMP-725: MavenDecrypter doesn’t support comments in settings.xml","TCOMP-726: When a component is not found the error message can be misleading","TCOMP-728: Http client doesn’t ignore empty query parameters","TCOMP-722: WebSocket connection fails with a NPE when the endpoint doesn’t exists","TCOMP-723: Adding configurationByExample utility to create query string for Job DSL","TCOMP-724: Documentation endpoint doesn’t support HTML","TCOMP-446: Support Embedded Documentation","TCOMP-650: Ensure component can be executed in beam pipelines","TCOMP-651: Ensure beam components can be wrapped and used through the Talend Component Kit Framework","TCOMP-653: Web Form metamodel service","TCOMP-655: Catalog service","TCOMP-656: UISpec compatibility","TCOMP-658: Add test Source/Sink collectors in JUnit integration","TCOMP-659: Basic job builder API to simplify JUnit tests","TCOMP-662: Validation Mojo","TCOMP-664: Local testing server for dev","TCOMP-675: Select a communication solution for Talend Component Kit server","TCOMP-680: Register components into the Studio Palette","TCOMP-681: Studio parameters form integration","TCOMP-682: Studio Metadata integration","TCOMP-683: Studio Runtime integration","TCOMP-691: Create context menu for Tacokit node in repository panel","TCOMP-719: Support Input Definition","TCOMP-720: Support Output Definition","TCOMP-721: Initial Widget Definitions"]},{"lang":"en","title":"Component Loading","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-loading.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Component Loading"],"lvl1":["Packaging a plugin","Packaging an application","Component scanning rules and default exclusions"],"lvl2":["Dependencies","Listing needed plugins","maven-shade-plugin extensions","Package Scanning"],"lvl3":["Creating a nested Maven repository with maven-shade-plugin","ContainerDependenciesTransformer","PluginTransformer"],"description":"How plugins and dependencies are loaded.","keywords":"plugin, scanning","text":["Talend Component scanning is based on plugins. To make sure that plugins can be developed in parallel and avoid conflicts, they need to be isolated (component or group of components in a single jar/plugin).","Multiple options are available:","Graph classloading: this option allows you to link the plugins and dependencies together dynamically in any direction. For example, the graph classloading can be illustrated by OSGi containers.","Tree classloading: a shared classloader inherited by plugin classloaders. However, plugin classloader classes are not seen by the shared classloader, nor by other plugins. For example, the tree classloading is commonly used by Servlet containers where plugins are web applications.","Flat classpath: listed for completeness but rejected by design because it doesn’t comply with this requirement.","In order to avoid much complexity added by this layer, Talend Component Kit relies on a tree classloading. The advantage is that you don’t need to define the relationship with other plugins/dependencies, because it is built-in.","Here is a representation of this solution:","","The shared area contains Talend Component Kit API, which only contains by default the classes shared by the plugins.","Then, each plugin is loaded with its own classloader and dependencies.","This section explains the overall way to handle dependencies but the Talend Maven plugin provides a shortcut for that.","A plugin is a JAR file that was enriched with the list of its dependencies. By default, Talend Component Kit runtime is able to read the output of maven-dependency-plugin in TALEND-INF/dependencies.txt. You just need to make sure that your component defines the following plugin:","Once build, check the JAR file and look for the following lines:","What is important to see is the scope related to the artifacts:","The APIs (component-api and geronimo-annotation_1.3_spec) are provided because you can consider them to be there when executing (they come with the framework).","Your specific dependencies (awesome-project in the example above) are marked as compile: they are included as needed dependencies by the framework (note that using runtime works too).","the other dependencies are ignored. For example, test dependencies.","Even if a flat classpath deployment is possible, it is not recommended because it would then reduce the capabilities of the components.","The way the framework resolves dependencies is based on a local Maven repository layout. As a quick reminder, it looks like:","This is all the layout the framework uses. The logic converts t-uple {groupId, artifactId, version, type (jar)} to the path in the repository.","Talend Component Kit runtime has two ways to find an artifact:","From the file system based on a configured Maven 2 repository.","From a fat JAR (uber JAR) with a nested Maven repository under MAVEN-INF/repository.","The first option uses either ${user.home}/.m2/repository (default) or a specific path configured when creating a ComponentManager. The nested repository option needs some configuration during the packaging to ensure the repository is correctly created.","To create the nested MAVEN-INF/repository repository, you can use the nested-maven-repository extension:","Plugins are usually programmatically registered. If you want to make some of them automatically available, you need to generate a TALEND-INF/plugins.properties file that maps a plugin name to coordinates found with the Maven mechanism described above.","You can enrich maven-shade-plugin to do it:","Here is a final job/application bundle based on maven-shade-plugin:","The configuration unrelated to transformers depends on your application.","ContainerDependenciesTransformer embeds a Maven repository and PluginTransformer to create a file that lists (one per line) artifacts (representing plugins).","Both transformers share most of their configuration:","session: must be set to ${session}. This is used to retrieve dependencies.","scope: a comma-separated list of scopes to include in the artifact filtering (note that the default will rely on provided but you can replace it by compile, runtime, runtime+compile, runtime+system or test).","include: a comma-separated list of artifacts to include in the artifact filtering.","exclude: a comma-separated list of artifacts to exclude in the artifact filtering.","userArtifacts: set of artifacts to include (groupId, artifactId, version, type - optional, file - optional for plugin transformer, scope - optional) which can be forced inline. This parameter is mainly useful for PluginTransformer.","includeTransitiveDependencies: should transitive dependencies of the components be included. Set to true by default. It is active for userArtifacts.","includeProjectComponentDependencies: should component project dependencies be included. Set to false by default. It is not needed when a job project uses isolation for components.","With the component tooling, it is recommended to keep default locations. Also if you need to use project dependencies, you can need to refactor your project structure to ensure component isolation. Talend Component Kit lets you handle that part but the recommended practice is to use userArtifacts for the components instead of project <dependencies>.","ContainerDependenciesTransformer specific configuration is as follows:","repositoryBase: base repository location (MAVEN-INF/repository by default).","ignoredPaths: a comma-separated list of folders not to create in the output JAR. This is common for folders already created by other transformers/build parts.","ContainerDependenciesTransformer specific configuration is the following one:","pluginListResource: base repository location (default to TALEND-INF/plugins.properties).","For example, if you want to list only the plugins you use, you can configure this transformer as follows:","The framework uses two kind of filterings when scanning your component. One based on the JAR content - the presence of TALEND-INF/dependencies.txt and one based on the package name. Make sure that your component definitions (including services) are in a scanned module if they are not registered manually using ComponentManager.instance().addPlugin(), and that the component package is not excluded.","Since the framework can be used in the case of fatjars or shades, and because it still uses scanning, it is important to ensure we don’t scan the whole classes for performances reason.","Therefore, the following packages are ignored:","avro.shaded","com.codehale.metrics","com.ctc.wstx","com.datastax.driver","com.fasterxml.jackson","com.google.common","com.google.thirdparty","com.ibm.wsdl","com.jcraft.jsch","com.kenai","com.sun.istack","com.sun.xml","com.talend.shaded","com.thoughtworks","io.jsonwebtoken","io.netty","io.swagger","javax","jnr","junit","net.sf.ehcache","net.shibboleth","org.aeonbits.owner","org.apache","org.bouncycastle","org.codehaus","org.cryptacular","org.eclipse","org.fusesource","org.h2","org.hamcrest","org.hsqldb","org.jasypt","org.jboss","org.joda","org.jose4j","org.junit","org.jvnet","org.metatype","org.objectweb","org.openejb","org.opensaml","org.slf4j","org.swizzle","org.terracotta","org.tukaani","org.yaml","serp","it is not recommanded but possible to add in your plugin module a TALEND-INF/scanning.properties file with classloader.includes and classloader.excludes entries to refine the scanning with custom rules. In such a case, exclusions win over inclusions."]},{"lang":"en","title":"Component Server Vault Proxy","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/vault-proxy.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Component Server Vault Proxy"],"lvl1":["Vault proxy configuration","Adding the Vault Proxy to your Docker Compose","Docker Compose","Linking the Vault Proxy to the Component Server through HTTPS","Adding extensions to the instance"],"lvl2":["Configuration mechanism"],"description":"A Vault Proxy manages credential encryption before the data reaches the component server.","keywords":"component server, component-server, vault, proxy, credentials, cloud","text":["Component server vault proxy is deprecated since component-runtime-1.34.0 release","Browse the API description using OpenAPI.","A Vault proxy dedicated to the component server allows to safely manage credential encryption when operating in a Cloud environment.","","The Vault Proxy only concerns data marked as @Credential in the component configuration.","This Vault proxy:","receives an encrypted payload containing sensitive data from the remote engine, via HTTP.","decrypts the data","caches in memory the decrypted value of the data for performance reasons.","sends unencrypted data to the component server using HTTPS. An SSL certificate can be automatically generated and secures the data.","the configuration is read from system properties, environment variables, ….","Default value: false. Should any certificate be accepted - only for dev purposes.","Default value: 64. Thread pool core size for Component Server client.","Default value: 60000. Thread keep alive (in ms) for Component Server client thread pool.","Default value: 256. Thread pool max size for Component Server client.","Default value: 64. Thread pool core size for Vault client.","Default value: 60000. Thread keep alive (in ms) for Vault client thread pool.","Default value: 256. Thread pool max size for Vault client.","JAX-RS fully qualified name of the provides (message body readers/writers) for vault and component-server clients.","The token to use to call component-server if any.","Where the keystore to use to connect to Component Server is located.","Default value: changeit. The keystore password for talend.vault.cache.client.server.certificate.keystore.location.","The keystore type for talend.vault.cache.client.server.certificate.keystore.location.","The truststore type for talend.vault.cache.client.server.certificate.keystore.location.","Default value: localhost,127.0.0.1,0:0:0:0:0:0:0:1. Valid hostnames for the Component Server certificates (see java.net.ssl.HostnameVerifier).","Default value: 30000. HTTP connection timeout to vault server.","Default value: 30000. HTTP read timeout to vault server.","Where the keystore to use to connect to vault is located.","Default value: changeit. The keystore password for talend.vault.cache.client.vault.certificate.keystore.location.","The keystore type for talend.vault.cache.client.vault.certificate.keystore.location.","The truststore type for talend.vault.cache.client.vault.certificate.keystore.location.","Default value: localhost,127.0.0.1,0:0:0:0:0:0:0:1. Valid hostnames for the Vault certificates (see java.net.ssl.HostnameVerifier).","Default value: 3600. JCache expiry for decrypted values (ms).","Default value: false. Should JCache MBeans be registered.","Default value: false. Should JCache statistics be enabled.","Default value: `. JCache `CacheManager properties used to initialized the instance.","Default value: geronimo://simple-jcache.properties. Configuration for JCache setup, default implementation is Geronimo Simple Cache.","Default value: 100000. JCache max size per cache.","Default value: 30000. How often (in ms) the Component Server should be checked to invalidate the caches on the component parameters (to identify credentials).","Default value: localhost,127.0.0.1,0:0:0:0:0:0:0:1. The IP or hosts allowed to call that server on /api/* if no token is passed.","Default value: none. Enable to sanitize the hostname before testing them. Default to none which is a noop. Supported values are docker (for <folder>_<service>_<number>.<folder>_<network> pattern) and weave (for <prefix>_dataset_<number>.<suffix> pattern).","Default value: -. The tokens enabling a client to call this server without being in allowedIp whitelist.","Default value: 422. Status code sent when vault can’t decipher some values.","Default value: 600000. How often (in ms) to refresh the vault token.","Default value: 10000. How often (in ms) to refresh the vault token in case of an authentication failure.","Default value: vault\\:v[0-9]+\\:.*. The regex to whitelist ciphered keys, others will be passthrough in the output without going to vault.","Base URL to connect to Component Server","Default value: v1/auth/engines/login. The vault path to retrieve a token.","Default value: -. The vault role identifier to use to log in (if token is not set). - means it is ignored.","Default value: -. The vault secret identifier to use to log in (if token is not set). - means it is ignored.","Default value: -. The vault token to use to log in (will make roleId and secretId ignored). - means it is ignored.","Default value: v1/tenants-keyrings/decrypt/{x-talend-tenant-id}. The vault path to decrypt values. You can use the variable {x-talend-tenant-id} to replace by x-talend-tenant-id header value.","Base URL to connect to Vault.","The configuration uses Microprofile Config for most entries. It means it can be passed through system properties and environment variables (by replacing dots with underscores and making the keys uppercase).","To configure a Docker image rather than a standalone instance, Docker Config and secrets integration allows you to read the configuration from files. You can customize the configuration of these integrations through system properties.","Docker integration provides a secure: support to encrypt values and system properties, when required.","It is fully implemented using the Apache Geronimo Microprofile Config extensions.","The YAML below is the recommended configuration to enable the Vault Proxy and Component Server to communicate over HTTPS.","This setup enables the Vault Proxy and Component Server to communicate. You can now use the Vault Proxy as if it was the Component Server, by using localhost:9090 (or any other host matching your deployment) instead of the Component Server directly.","When the Vault Proxy is enabled, ensure you configure HTTPS on the Component Server using the following parameters:","true or false. Indicates if the SSL protocol is enabled.","Keystore password.","Path to Keystore.","Private key/certificate alias.","Keystore type.","true or false.","Specifies if a custom command is to be used to generate the certificate.","Encryption algorithm. RSA by default.","Distinguished name.","Size of the key. 2048 by default.","SSL port to use.","You can mount a volume in /opt/talend/component-kit-vault-proxy/custom/ and the jars in that folder which will be deployed with the server. Since the server relies on CDI (Apache OpenWebBeans) you can use that technology to enrich it, including JAX-RS endpoints, interceptors etc…or just libraries needing to be in the JVM."]},{"lang":"en","title":"Component execution logic","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-execution.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Component execution logic"],"description":"Learn how components are executed","keywords":"PostConstruct, PreDestroy, BeforeGroup, AfterGroup","text":["Each type of component has its own execution logic. The same basic logic is applied to all components of the same type, and is then extended to implement each component specificities. The project generated from the starter already contains the basic logic for each component.","Talend Component Kit framework relies on several primitive components.","All components can use @PostConstruct and @PreDestroy annotations to initialize or release some underlying resource at the beginning and the end of a processing.","In distributed environments, class constructor are called on cluster manager nodes. Methods annotated with @PostConstruct and @PreDestroy are called on worker nodes. Thus, partition plan computation and pipeline tasks are performed on different nodes.","","All the methods managed by the framework must be public. Private methods are ignored.","","","The framework is designed to be as declarative as possible but also to stay extensible by not using fixed interfaces or method signatures. This allows to incrementally add new features of the underlying implementations."]},{"lang":"en","title":"Component server and HTTP API","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/documentation-rest.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Component server and HTTP API"],"lvl1":["HTTP API","Server configuration","HTTPS activation","Defining queries","Web forms and REST API","Logging","Docker"],"lvl2":["Deprecated endpoints","WebSocket transport","Configuration mechanism","Using the UiSpec model without the tooling","Using the UiSpec for custom models","JavaScript integration","Run","Configure","Maven repository","Logging","Building the docker image","Integrating components into the image","Adding extensions to the server"],"lvl3":["Deploy components to the server","default or TEXT profile","JSON profile","KAFKA profile","OpenTracing","Docker Compose"],"description":"Learn about Talend Component Kit HTTP API and the component server","keywords":"REST API, component-server","text":["The HTTP API intends to expose most Talend Component Kit features over HTTP. It is a standalone Java HTTP server.","The WebSocket protocol is activated for the endpoints. Endpoints then use /websocket/v1 as base instead of /api/v1. See WebSocket for more details.","Browse the API description using interface.","To make sure that the migration can be enabled, you need to set the version the component was created with in the execution configuration that you send to the server (component version is in component the detail endpoint). To do that, use tcomp::component::version key.","Endpoints that are intended to disappear will be deprecated. A X-Talend-Warning header will be returned with a message as value.","You can connect yo any endpoint by:","Replacing /api with /websocket","Appending /<http method> to the URL","Formatting the request as:","For example:","The response is formatted as follows:","All endpoints are logged at startup. You can then find them in the logs if you have a doubt about which one to use.","If you don’t want to create a pool of connections per endpoint/verb, you can use the bus endpoint: /websocket/v1/bus. This endpoint requires that you add the destinationMethod header to each request with the verb value (GET by default):","the configuration is read from system properties, environment variables, ….","Default value: 1000. Maximum items a cache can store, used for index endpoints.","A comma separated list of gav to locate the components","Default value: ${home}/documentations. A component translation repository. This is where you put your documentation translations. Their name must follow the pattern documentation_${container-id}_language.adoc where ${container-id} is the component jar name (without the extension and version, generally the artifactId).","Default value: true. Should the component extensions add required dependencies.","If you deploy some extension, where they can create their dependencies if needed.","Default value: 180000. Timeout for extension initialization at startup, since it ensures the startup wait extensions are ready and loaded it allows to control the latency it implies.","A property file (or multiple comma separated) where the value is a gav of a component to register(complementary with coordinates). Note that the path can end up with or .properties to take into account all properties in a folder.","Default value: true. Should the /documentation endpoint be activated. Note that when called on localhost the doc is always available.","Default value: true. Should the /api/v1/environment endpoint be activated. It shows some internal versions and git commit which are not always desirable over the wire.","Default value: false. Should the components using a @GridLayout support tab translation. Studio does not suppot that feature yet so this is not enabled by default.","Default value: icons/%s.svg,icons/svg/%s.svg,icons/%s_icon32.png,icons/png/%s_icon32.png. These patterns are used to find the icons in the classpath(s).","Default value: false. If set it will replace any message for exceptions. Set to false to use the actual exception message.","Default value: false. Should the lastUpdated timestamp value of /environment endpoint be updated with server start time.","Default value: en*=en fr*=fr zh*=zh_CN ja*=ja de*=de. For caching reasons the goal is to reduce the locales to the minimum required numbers. For instance we avoid fr and fr_FR which would lead to the same entries but x2 in terms of memory. This mapping enables that by whitelisting allowed locales, default being en. If the key ends with it means all string starting with the prefix will match. For instance fr will match fr_FR but also fr_CA.","The local maven repository used to locate components and their dependencies","Default value: false. Should the plugins be un-deployed and re-deployed.","Default value: 600. Interval in seconds between each check if plugins re-loading is enabled.","Specify a file to check its timestamp on the filesystem. This file will take precedence of the default ones provided by the talend.component.server.component.registry property (used for timestamp method).","Default value: timestamp. Re-deploy method on a timestamp or connectors version change. By default, the timestamp is checked on the file pointed by talend.component.server.component.registry or talend.component.server.plugins.reloading.marker variable, otherwise we inspect the content of the CONNECTORS_VERSION file. Accepted values: timestamp, anything else defaults to connectors.","Default value: false. Should the all requests/responses be logged (debug purposes - only work when running with CXF).","Default value: securityNoopHandler. How to validate a command/request. Accepted values: securityNoopHandler.","Default value: securityNoopHandler. How to validate a connection. Accepted values: securityNoopHandler.","A folder available for the server - don’t forget to mount it in docker if you are using the image - which accepts subfolders named as component plugin id (generally the artifactId or jar name without the version, ex: jdbc). Each family folder can contain:","a user-configuration.properties file which will be merged with component configuration system (see services). This properties file enables the function userJar(xxxx) to replace the jar named xxxx by its virtual gav (groupId:artifactId:version),","a list of jars which will be merged with component family classpath","Default value: auto. Should the implicit artifacts be provisionned to a m2. If set to auto it tries to detect if there is a m2 to provision - recommended, if set to skip it is ignored, else it uses the value as a m2 path.","The configuration uses Microprofile Config for most entries. It means it can be passed through system properties and environment variables (by replacing dots with underscores and making the keys uppercase).","To configure a Docker image rather than a standalone instance, Docker Config and secrets integration allows you to read the configuration from files. You can customize the configuration of these integrations through system properties.","Docker integration provides a secure: support to encrypt values and system properties, when required.","It is fully implemented using the Apache Geronimo Microprofile Config extensions.","Using the server ZIP (or Docker image), you can configure HTTPS by adding properties to _JAVA_OPTIONS. Assuming that you have a certificate in /opt/certificates/component.p12 (don’t forget to add/mount it in the Docker image if you use it), you can activate it as follows:","You can define simple queries on the configuration types and components endpoints. These two endpoints support different parameters.","Queries on the configurationtype/index endpoint supports the following parameters:","type","id","name","metadata of the first configuration property as parameters.","Queries on the component/index endpoint supports the following parameters:","plugin","name","id","familyId","metadata of the first configuration property as parameters.","In both cases, you can combine several conditions using OR and AND operators. If you combine more than two conditions, note that they are evaluated in the order they are written.","Each supported parameter in a condition can be \"equal to\" (=) or \"not equal to\" (!=) a defined value (case-sensitive).","For example:","In this example, the query gets components that have a dataset and belong to the jdbc-component plugin, or components that are named input.","The component-form library provides a way to build a component REST API facade that is compatible with React form library.","for example:","the Client can be created using ClientFactory.createDefault(System.getProperty(\"app.components.base\", \"http://localhost:8080/api/v1\")) and the service can be a simple new UiSpecService<>(). The factory uses JAX-RS if the API is available (assuming a JSON-B provider is registered). Otherwise, it tries to use Spring.","The conversion from the component model (REST API) to the uiSpec model is done through UiSpecService. It is based on the object model which is mapped to a UI model. Having a flat model in the component REST API allows to customize layers easily.","You can completely control the available components, tune the rendering by switching the uiSchema, and add or remove parts of the form. You can also add custom actions and buttons for specific needs of the application.","The /migrate endpoint was not shown in the previous snippet but if you need it, add it as well.","This Maven dependency provides the UISpec model classes. You can use the Ui API (with or without the builders) to create UiSpec representations.","For Example:","The model uses the JSON-B API to define the binding. Make sure to have an implementation in your classpath. To do that, add the following dependencies:","The following module enables you to define through annotations a uispec on your own models:","this can’t be used in components and is only intended for web applications.","org.talend.sdk.component.form.uispec.mapper.api.service.UiSpecMapper enables to create a Ui instance from a custom type annotated with org.talend.sdk.component.form.uispec.mapper.api.model.View and org.talend.sdk.component.form.uispec.mapper.api.model.View.Schema.","UiSpecMapper returns a Supplier and not directly an Ui because the ui-schema is re-evaluated when `get()̀ is called. This enables to update the title maps for example.","Here is an example:","This API maps directly the UiSpec model (json schema and ui schema of Talend UIForm).","The default implementation of the mapper is available at org.talend.sdk.component.form.uispec.mapper.impl.UiSpecMapperImpl.","Here is an example:","The getTitleMapProviders() method will generally lookup a set of TitleMapProvider instances in your IoC context. This API is used to fill the titleMap of the form when a reference identifier is set on the @Schema annotation.","component-kit.js is no more available (previous versions stay on NPM) and is replaced by @talend/react-containers. The previous import can be replaced by import kit from '@talend/react-containers/lib/ComponentForm/kit';.","Default JavaScript integration goes through the Talend UI Forms library and its Containers wrapper.","Documentation is now available on the previous link.","The logging uses Log4j2. You can specify a custom configuration by using the -Dlog4j.configurationFile system property or by adding a log4j2.xml file to the classpath.","Here are some common configurations:","Console logging:","Output messages look like:","JSON logging:","Output messages look like:","Rolling file appender:","More details are available in the RollingFileAppender documentation.","You can compose previous layout (message format) and appenders (where logs are written).","The server image is deployed on Docker. Its version is suffixed with a timestamp to ensure images are not overridden and can break your usage. You can check the available version on Docker hub.","You can run the docker image by executing this command :","You can set the env variable _JAVA_OPTIONS to customize the server, by default it is installed in /opt/talend/component-kit.","The maven repository is the default one of the machine, you can change it setting the system property talend.component.server.maven.repository=/path/to/your/m2.","If you want to deploy some components you can configure which ones in _JAVA_OPTIONS (see server doc online) and redirect your local m2:","The component server docker image comes with two log4j2 profiles: TEXT (default) and JSON. The logging profile can be changed by setting the environment variable LOGGING_LAYOUT to JSON.","Note that Component Server adds to these default Talend profiles the KAFKA profile. With this profile, all logs are sent to Kafka.","You can check the exact configuration in the component-runtime/images/component-server-image/src/main/resources folder.","The console logging is on at INFO level by default. You can customize it by setting the CONSOLE_LOG_LEVEL environment variable to DEBUG, INFO, WARN or to any other log level supported by log4j2.","Run docker image with console logging:","The JSON profile does the following:","Logs on the console using the CONSOLE_LOG_LEVEL configuration as the default profile. It uses the formatting shown below.","If the TRACING_KAFKA_URL environment variable is set, it logs the opentracing data on the defined Kafka using the topic TRACING_KAFKA_TOPIC. This level can be customized by setting the KAFKA_LOG_LEVEL environment variable (INFO by default).","Events are logged in the following format:","This profile is very close to the JSON profile and also adds the LOG_KAFKA_TOPIC and LOG_KAFKA_URL configuration. The difference is that it logs the default logs on Kafka in addition to the tracing logs.","The component server uses Geronimo OpenTracing to monitor request.","The tracing can be activated by setting the TRACING_ON environment variable to true.","The tracing rate is configurable by setting the TRACING_SAMPLING_RATE environment variable. It accepts 0 (none) and 1 (all, default) as values to ensure the consistency of the reporting.","You can find all the details on the configuration in org.talend.sdk.component.server.configuration.OpenTracingConfigSource.","Run docker image with tracing on:","By default, Geronimo OpenTracing will log the spans in a Zipking format so you can use the Kafka profile as explained before to wire it over any OpenTracing backend.","You can register component server images in Docker using these instructions in the corresponding image directory:","Docker Compose allows you to deploy the server with components, by mounting the component volume into the server image.","docker-compose.yml example:","If you want to mount it from another image, you can use this compose configuration:","To run one of the previous compose examples, you can use docker-compose -f docker-compose.yml up.","Only use the configuration related to port 5005 (in ports and the -agentlib option in _JAVA_OPTIONS) to debug the server on port 5005. Don’t set it in production.","You can mount a volume in /opt/talend/component-kit/custom/ and the jars in that folder which will be deployed with the server. Since the server relies on CDI (Apache OpenWebBeans) you can use that technology to enrich it, including JAX-RS endpoints, interceptors etc…or just libraries needing to be in the JVM."]},{"lang":"en","title":"Contributing to Talend Component Kit documentation","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/how-to-contribute.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Contributing to Talend Component Kit documentation"],"lvl1":["How to contribute","General organization guidelines","List of metadata attributes","Conditionality regarding output formats","Content","Sample page"],"lvl2":["Page and section levels","Reusing content with includes","Adding images","Tables","Admonition blocks"],"description":"Lear how to contribute to component-runtime documentation","keywords":"documentation, asciidoc, asciidoctor, contributor","text":["This document explains how Asciidoctor is used in the context of Talend Component Kit as well as the specific processes in place.","For general guidelines about Asciidoctor, refer to the Asciidoc Syntax quick reference page.","There are two ways to suggest modifications or new content. Both of the options below require you to have a GitHub account created.","On every page of the Talend Component Kit Developer Guide, a Suggest and edit button is available. It allows you to access the corresponding source file on GitHub and to create a pull request with the suggested edits. The pull request is then assessed by the team in charge of the project.","Fork the Runtime repository of the Talend Component Kit project and edit .adoc files located under documentation\\src\\main\\antora\\modules\\ROOT\\pages. Make sure to follow the guidelines outlined in the current document, especially for large modifications or new content, to make sure it can properly be rendered. When done, create a pull request that will be assessed by the team in charge of the project.","The documentation is made of:","Documentation files manually written under documentation\\src\\main\\antora\\modules\\ROOT\\pages.","Documentation files automatically generated from the source code under documentation\\src\\main\\antora\\modules\\ROOT\\pages\\_partials. These files are individually called in manually written files through includes.","Assets, especially images, stored in the documentation\\src\\main\\antora\\modules\\ROOT\\assets folder. Some subfolders exist to categorize the assets.","Each file has a unique name and is rendered as a unique HTML page. Some of the files are prefixed to help identifying the type of content it contains. Most common examples are:","index- for pages referenced from the main index page. These pages also contain specific attributes to be correctly rendered on the main index page (see 'List of metadata attributes' below).","tutorial- for tutorials/guided examples.","generated_ for pages generated from the source code. These pages are generally stored in the _partials folder.","For all pages:",":page-partial indicates that the current .adoc file can be included in another document using an include::. This attribute has no value.",":page-talend_skipindexation: indicates that the current .adoc file must not be indexed. This attribute has no value. Add it to files that should not be returned in the search, like index files that only contain includes.",":description: is the meta description of the file. Each .adoc file is rendered as an HTML file.",":keywords: is the list of meta keywords relevant for the current .adoc file. Separate keywords using simple commas.",":page-talend_stage: draft indicates that the current document is a draft and is not final even if published. It triggers the display of a small banner indicating the status of the page. Remove this attribute once the page is final.","For pages that should appear as a tile on the index page:",":page-documentationindex-index: is the weight of the page. A low weight indicates that the page should be one of the first tiles to appear. A high weight will push the tile towards the end of the list in the index page.",":page-documentationindex-label: is the title of the tile in the index page.",":page-documentationindex-icon: is the icon of the tile in the index page. The value of this attribute should be the name of a free icon on fontawesome.",":page-documentationindex-description: is a short description of the page that will be displayed in the tile under its title.","For pages containing API descriptions:",":page-talend_swaggerui: true indicates that the page contains some API reference that should be displayed using Swagger UI","The Talend Component Kit documentation is published as HTML and PDF. Some parts can differ between these two versions, such as lists of links, that are not functional in the PDF version.","To avoid this, it is possible to define some conditionality to have some content only displaying in one of the output formats only. For example:","Every .adoc file can only contain one 'level 1' title (=). It is the title of the page and is located at the top of the document. It is a best practices that all sublevels added to the document are kept consistent. For example, don’t use a 'level 3' (===) section directly inside a 'level 1'.","When possible, avoid going lower than section 2 (===) to keep the page readable. In the HTML output, the document title is renderedh1, section 1 titles as h2, etc. The \"in-page\" navigation available on the right side of the HTML rendering only considers h2 and h3 elements. Other levels are ignored to keep the navigation readable and simple.","It is possible to reuse content through \"includes\". Includes can be used to reuse entire files in other files, allowing to avoid copy pasting.","When using an 'include' (calling an .adoc file from another .adoc file), you can specify a level offset to keep the hierarchy consistent in the current document. Avoid using includes if not absolutely necessary. An include can be done as follows:","In this case, both doc1.adoc and doc2.adoc are rendered in the same page and their content is offset by one level, meaning that the document title of doc1 becomes a section 1 title (h2) instead of an h1 in the final rendering, and so on.","Note that both doc1.adoc and doc2.adoc will in addition be rendered as standalone pages (doc1.html and doc2.html).","All images are stored under documentation > src > main > antora > modules > ROOT > assets > images. Relatively to .adoc files, it can be ../assets/images/ or ../../assets/images for _partials (automatically generated from code) pages. To avoid handling different relative paths, the backend already resolves directly image: to the image folder. Hence, paths to images should start with the following:","image:(<subfolder>/)<image_name>.png[<image_name>(,parameters)]","If there is no subfolder, type the image name right away. Adding an image title is mandatory to avoid empty broken spaces in the content. If necessary, you can add more parameters separated by a comma between the same brackets as the image title, such as the desired width, height, etc.","Use values in % for image size. For example; image:landscape.png[Landscape,70%,window=\"_blank\",link=\"https://talend.github.io/component-runtime/main/1.44.0/_images/landscape.png\"]","In a general manner, avoid using tables if there are other solutions available. This is especially the case for complex tables that include assets or big code samples, as these can lead to display issues.","Table example: value","API","Type","Description","@o.t.s.c.api.service.completion.DynamicValues","dynamic_values","Mark a method as being useful to fill potential values of a string option for a property denoted by its value.","@o.t.s.c.api.service.healthcheck.HealthCheck","healthcheck","This class marks an action doing a connection test","The following elements can be used to create admonition blocks. However, avoid using them one after another as it can make reading more difficult:","NOTE: for a simple information note","IMPORTANT: for a warning. Warnings should include information that lead to important errors if not taken into account","TIP: for alternative ways or shortcuts to ease a process or procedure","Admonition blocks should be kept as simple and short as possible. In some niche cases, it may be required to insert more complex content in an admonition block, such as a bullet list. In these cases, they should be formatted as follows:"]},{"lang":"en","title":"Creating a job pipeline","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/services-pipeline.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Creating a job pipeline"],"lvl1":["Job Builder","Beam case"],"lvl2":["Environment/Runner","Key Provider","Inputs and Outputs","Processors","Converting a Beam.io into a component I/O"],"description":"How to create a job pipeline using Talend Component Kit","keywords":"job builder, service, component-manager, pipeline, dsl, environment, Beam","text":["The Job builder lets you create a job pipeline programmatically using Talend components (Producers and Processors). The job pipeline is an acyclic graph, allowing you to build complex pipelines.","Let’s take a simple use case where two data sources (employee and salary) are formatted to CSV and the result is written to a file.","A job is defined based on components (nodes) and links (edges) to connect their branches together.","Every component is defined by a unique id and an URI that identify the component.","The URI follows the form [family]://[component][?version][&configuration], where:","family is the name of the component family.","component is the name of the component.","version is the version of the component. It is represented in a key=value format. The key is __version and the value is a number.","configuration is component configuration. It is represented in a key=value format. The key is the path of the configuration and the value is a `string' corresponding to the configuration value.","URI example:","configuration parameters must be URI/URL encoded.","Job example:","It has some starting components (components that don’t have a from connection and that need to be of the producer type).","There are no cyclic connections. The job pipeline needs to be an acyclic graph.","All components used in the connections are already declared.","Each connection is used only once. You cannot connect a component input/output branch twice.","In this version, the execution of the job is linear. Components are not executed in parallel even if some steps may be independents.","Depending on the configuration, you can select the environment which you execute your job in.","To select the environment, the logic is the following one:","If an org.talend.sdk.component.runtime.manager.chain.Job.ExecutorBuilder class is passed through the job properties, then use it. The supported types are an ExecutionBuilder instance, a Class or a String.","If an ExecutionBuilder SPI is present, use it. It is the case if component-runtime-beam is present in your classpath.","Else, use a local/standalone execution.","In the case of a Beam execution, you can customize the pipeline options using system properties. They have to be prefixed with talend.beam.job.. For example, to set the appName option, you need to use -Dtalend.beam.job.appName=mytest.","The job builder lets you set a key provider to join your data when a component has multiple inputs. The key provider can be set contextually to a component or globally to the job.","If the incoming data has different IDs, you can provide a complex global key provider that relies on the context given by the component id and the branch name.","For Beam case, you need to rely on Beam pipeline definition and use the component-runtime-beam dependency, which provides Beam bridges.","org.talend.sdk.component.runtime.beam.TalendIO provides a way to convert a partition mapper or a processor to an input or processor using the read or write methods.","org.talend.sdk.component.runtime.beam.TalendFn provides the way to wrap a processor in a Beam PTransform and to integrate it into the pipeline.","The multiple inputs and outputs are represented by a Map element in Beam case to avoid using multiple inputs and outputs.","You can use ViewsMappingTransform or CoGroupByKeyResultMappingTransform to adapt the input/output format to the record format representing the multiple inputs/output, like Map<String, List<?>>, but materialized as a Record. Input data must be of the Record type in this case.","For simple inputs and outputs, you can get an automatic and transparent conversion of the Beam.io into an I/O component, if you decorated your PTransform with @PartitionMapper or @Processor.","However, there are limitations:","Inputs must implement PTransform<PBegin, PCollection<?>> and must be a BoundedSource.","Outputs must implement PTransform<PCollection<?>, PDone> and register a DoFn on the input PCollection.","For more information, see the How to wrap a Beam I/O page."]},{"lang":"en","title":"Creating components for a REST API","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-create-components-rest-api.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Creating components for a REST API"],"lvl1":["Setting up the HTTP client","Configuring the component","Defining the component mapper","Defining the component source"],"lvl2":["Configuring basic authentication","Configuring the dataset"],"description":"Example of REST API component implementation with Talend Component Kit","keywords":"tutorial, example, zendesk","text":["This tutorial shows how to create components that consume a REST API.","The component developed as example in this tutorial is an input component that provides a search functionality for Zendesk using its Search API. Lombok is used to avoid writing getter, setter and constructor methods.","You can generate a project using the Talend Components Kit starter, as described in this tutorial.","The input component relies on Zendesk Search API and requires an HTTP client to consume it.","The Zendesk Search API takes the following parameters on the /api/v2/search.json endpoint.","query : The search query.","sort_by : The sorting type of the query result. Possible values are updated_at, created_at, priority, status, ticket_type, or relevance. It defaults to relevance.","sort_order: The sorting order of the query result. Possible values are asc (for ascending) or desc (for descending). It defaults to desc.","Talend Component Kit provides a built-in service to create an easy-to-use HTTP client in a declarative manner, using Java annotations.","No additional implementation is needed for the interface, as it is provided by the component framework, according to what is defined above.","This HTTP client can be injected into a mapper or a processor to perform HTTP requests.","This example uses the basic authentication that supported by the API.","The first step is to set up the configuration for the basic authentication. To be able to consume the Search API, the Zendesk instance URL, the username and the password are needed.","The data store is now configured. It provides a basic authentication token.","Once the data store is configured, you can define the dataset by configuring the search query. It is that query that defines the records processed by the input component.","Your component is configured. You can now create the component logic.","Mappers defined with this tutorial don’t implement the split part because HTTP calls are not split on many workers in this case.","Once the component logic implemented, you can create the source in charge of performing the HTTP request to the search API and converting the result to JsonObject records.","You now have created a simple Talend component that consumes a REST API.","To learn how to test this component, refer to this tutorial."]},{"lang":"en","title":"Creating plugins","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/creating-plugins.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Creating plugins"],"lvl1":["Defining the ContainerManager or the classloader manager","Creating plugins","Defining a listener for the plugin registration"],"description":"Learn how to create plugins for your components","keywords":"ContainerManager, ContainerListener, plugin, listener, registration, extension","text":["The entry point of the API is the ContainerManager. It allows you to define what is the Shared classloader and to create children:","how to resolve dependencies for plugins from the plugin file/location","how to configure the classloaders (what is the parent classloader, how to handle the parent first/last delegation, and so on).","It is recommended to keep the manager running if you can reuse plugins in order to avoid recreating classloaders and to mutualize them.","What the shared classloader is","Which classes are loaded from the shared loader first (intended to be used for API which should not be loaded from the plugin loader)","Which classes are loaded from the parent classloader. This can be useful to prevent loading a \"common\" library from the parent classloader. For instance, it can be neat for guava, commons-lang3, an so on).","Once you have defined a manager, you can create plugins:","To create the plugin container, the Resolver resolves the dependencies needed for the plugin, then the manager creates the plugin classloader and registers the plugin Container.","Some actions are needed when a plugin is registered or unregistered. For that purpose, you can use ContainerListener:","Plugins are directly registered on the manager:"]},{"lang":"en","title":"Creating your first component","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-create-my-first-component.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Creating your first component"],"lvl1":["Prerequisites","Generate a component project","Compile and deploy the component to Talend Open Studio","Edit the component","Build a job with the component"],"description":"Create your first component using Talend Component Kit and integrate it to Talend Open Studio to build a job","keywords":"first, start, Studio, studio-integration, integration, palette","text":["This tutorial walks you through the most common iteration steps to create a component with Talend Component Kit and to deploy it to Talend Open Studio.","The component created in this tutorial is a simple processor that reads data coming from the previous component in a job or pipeline and displays it in the console logs of the application, along with an additional information entered by the final user.","The component designed in this tutorial is a processor and does not require nor show any datastore and dataset configuration. Datasets and datastores are required only for input and output components.","To get your development environment ready and be able to follow this tutorial:","Download and install a Java JDK 1.8 or greater.","Download and install Talend Open Studio. For example, from Sourceforge.","Download and install IntelliJ.","Download the Talend Component Kit plugin for IntelliJ. The detailed installation steps for the plugin are available in this document.","The first step in this tutorial is to generate a component skeleton using the Starter embedded in the Talend Component Kit plugin for IntelliJ.","Start IntelliJ and create a new project. In the available options, you should see Talend Component.","Make sure that a Project SDK is selected. Then, select Talend Component and click Next. The Talend Component Kit Starter opens.","Enter the component and project metadata. Change the default values, for example as presented in the screenshot below:","The Component Family and the Category will be used later in Talend Open Studio to find the new component.","Project metadata is mostly used to identify the project structure. A common practice is to replace 'company' in the default value by a value of your own, like your domain name.","Once the metadata is filled, select Add a component. A new screen is displayed in the Talend Component Kit Starter that lets you define the generic configuration of the component. By default, new components are processors.","Enter a valid Java name for the component. For example, Logger.","Select Configuration Model and add a string type field named level. This input field will be used in the component configuration for final users to enter additional information to display in the logs.","In the Input(s) / Output(s) section, click the default MAIN input branch to access its detail, and make sure that the record model is set to Generic. Leave the Name of the branch with its default MAIN value.","Repeat the same step for the default MAIN output branch.","Because the component is a processor, it has an output branch by default. A processor without any output branch is considered an output component. You can create output components when the Activate IO option is selected.","Click Next and check the name and location of the project, then click Finish to generate the project in the IDE.","At this point, your component is technically already ready to be compiled and deployed to Talend Open Studio. But first, take a look at the generated project:","Two classes based on the name and type of component defined in the Talend Component Kit Starter have been generated:","LoggerProcessor is where the component logic is defined","LoggerProcessorConfiguration is where the component layout and configurable fields are defined, including the level string field that was defined earlier in the configuration model of the component.","The package-info.java file contains the component metadata defined in the Talend Component Kit Starter, such as family and category.","You can notice as well that the elements in the tree structure are named after the project metadata defined in the Talend Component Kit Starter.","These files are the starting point if you later need to edit the configuration, logic, and metadata of the component.","There is more that you can do and configure with the Talend Component Kit Starter. This tutorial covers only the basics. You can find more information in this document.","Without modifying the component code generated from the Starter, you can compile the project and deploy the component to a local instance of Talend Open Studio.","The logic of the component is not yet implemented at that stage. Only the configurable part specified in the Starter will be visible. This step is useful to confirm that the basic configuration of the component renders correctly.","Before starting to run any command, make sure that Talend Open Studio is not running.","From the component project in IntelliJ, open a Terminal and make sure that the selected directory is the root of the project. All commands shown in this tutorial are performed from this location.","Compile the project by running the following command: mvnw clean install. The mvnw command refers to the Maven wrapper that is embedded in Talend Component Kit. It allows to use the right version of Maven for your project without having to install it manually beforehand. An equivalent wrapper is available for Gradle.","Once the command is executed and you see BUILD SUCCESS in the terminal, deploy the component to your local instance of Talend Open Studio using the following command: mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome=\"<path to Talend Open Studio home>\".","Replace the path with your own value. If the path contains spaces (for example, Program Files), enclose it with double quotes.","Make sure the build is successful.","Open Talend Open Studio and create a new Job:","Find the new component by looking for the family and category specified in the Talend Component Kit Starter. You can add it to your job and open its settings.","Notice that the level field specified in the configuration model of the component in the Talend Component Kit Starter is present.","At this point, the new component is available in Talend Open Studio, and its configurable part is already set. But the component logic is still to be defined.","You can now edit the component to implement its logic: reading the data coming through the input branch to display that data in the execution logs of the job. The value of the level field that final users can fill also needs to be changed to uppercase and displayed in the logs.","Save the job created earlier and close Talend Open Studio.","Go back to the component development project in IntelliJ and open the LoggerProcessor class. This is the class where the component logic can be defined.","Look for the @ElementListener method. It is already present and references the default input branch that was defined in the Talend Component Kit Starter, but it is not complete yet.","To be able to log the data in input to the console, add the following lines:","The @ElementListener method now looks as follows:","Open a Terminal again to compile the project and deploy the component again. To do that, run successively the two following commands:","mvnw clean install","`mvnw talend-component:deploy-in-studio -Dtalend.component.studioHome=\"<path to Talend Open Studio home>\"","The update of the component logic should now be deployed. After restarting Talend Open Studio, you will be ready to build a job and use the component for the first time.","To learn the different possibilities and methods available to develop more complex logics, refer to this document.","If you want to avoid having to close and re-open Talend Open Studio every time you need to make an edit, you can enable the developer mode, as explained in this document.","As the component is now ready to be used, it is time to create a job and check that it behaves as intended.","Open Talend Open Studio again and go to the job created earlier. The new component is still there.","Add a tRowGenerator component and connect it to the logger.","Double-click the tRowGenerator to specify the data to generate:","Add a first column named firstName and select the TalendDataGenerator.getFirstName() function.","Add a second column named 'lastName' and select the TalendDataGenerator.getLastName() function.","Set the Number of Rows for RowGenerator to 10.","Validate the tRowGenerator configuration.","Open the TutorialFamilyLogger component and set the level field to info.","Go to the Run tab of the job and run the job. The job is executed. You can observe in the console that each of the 10 generated rows is logged, and that the info value entered in the logger is also displayed with each record, in uppercase."]},{"lang":"en","title":"Defining a combiner","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-combiner.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a combiner"],"lvl1":["What is a combiner"],"description":"How to develop a combiner component with Talend Component Kit","keywords":"component type, combiner, output","text":["Currently, Talend Component Kit does not allow you to define a Combiner. A combiner is the symmetric part of a partition mapper. It allows to aggregate results in a single partition."]},{"lang":"en","title":"Defining a custom API","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/services-custom-api.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a custom API"],"lvl1":["Extending the UI"],"description":"Extend the Talend Component Kit API with custom features","keywords":"component API, service, extension, custom, ui, api","text":["It is possible to extend the Component API for custom front features.","What is important here is to keep in mind that you should do it only if it targets not portable components (only used by the Studio or Beam).","It is recommended to create a custom xxxx-component-api module with the new set of annotations.","To extend the UI, add an annotation that can be put on @Option fields, and that is decorated with @Ui. All its members are then put in the metadata of the parameter. For example:"]},{"lang":"en","title":"Defining a custom icon for a component or component family","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-defining-custom-icon.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a custom icon for a component or component family"],"description":"How to replace the default icon with a custom icon using Talend Component Kit","keywords":"component icon, icon","text":["Every component family and component needs to have a representative icon. You have to define a custom icon as follows:","For the component family the icon is defined in the package-info.java file.","For the component itself, you need to declare the icon in the component class.","Custom icons must comply with the following requirements:","Icons must be stored in the src/main/resources/icons folder of the project.","Icon file names need to match one of the following patterns: IconName.svg or IconName_icon32.png. The latter will run in degraded mode in Talend Cloud. Replace IconName by the name of your choice.","Icons must be squared, even for the SVG format.","Note that SVG icons are not supported by Talend Studio and can cause the deployment of the component to fail. If you aim at deploying a custom component to Talend Studio, specify PNG icons or use the Maven (or Gradle) svg2png plugin to convert SVG icons to PNG. If you want a finer control over both images, you can provide both in your component. Ultimately, you can also remove SVG parameters from the talend.component.server.icon.paths property in the HTTP server configuration.","Note that SVG icons are not supported by Talend Studio and can cause the deployment of the component to fail.","If you aim at deploying a custom component to Talend Studio, specify PNG icons or use the Maven (or Gradle) svg2png plugin to convert SVG icons to PNG. If you want a finer control over both images, you can provide both in your component.","Ultimately, you can also remove SVG parameters from the talend.component.server.icon.paths property in the HTTP server configuration."]},{"lang":"en","title":"Defining a driver runner","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-driver-runner.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a driver runner"],"lvl1":["What is a driver runner"],"description":"How to develop a driver runner with Talend Component Kit","keywords":"component type, driver runner, standalone","text":["A Driver Runner (DriverRunner) is a standalone component which doesn’t process or return any data.","A Driver runner must have a @RunAtDriver method without any parameter."]},{"lang":"en","title":"Defining a partition mapper","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-partition-mapper.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a partition mapper"],"lvl1":["What is a partition mapper","Implementing a partition mapper"],"lvl2":["@Assessor","@Split","@Emitter"],"description":"How to develop a partition mapper with Talend Component Kit","keywords":"component type, partition mapper, input","text":["A Partition Mapper (PartitionMapper) is a component able to split itself to make the execution more efficient.","This concept is borrowed from big data and useful in this context only (BEAM executions). The idea is to divide the work before executing it in order to reduce the overall execution time.","The process is the following:","The size of the data you work on is estimated. This part can be heuristic and not very precise.","From that size, the execution engine (runner for Beam) requests the mapper to split itself in N mappers with a subset of the overall work.","The leaf (final) mapper is used as a Producer (actual reader) factory.","This kind of component must be Serializable to be distributable.","A partition mapper requires three methods marked with specific annotations:","@Assessor for the evaluating method","@Split for the dividing method","@Emitter for the Producer factory","The Assessor method returns the estimated size of the data related to the component (depending its configuration). It must return a Number and must not take any parameter.","For example:","The Split method returns a collection of partition mappers and can take optionally a @PartitionSize long value as parameter, which is the requested size of the dataset per sub partition mapper.","For example:","The Emitter method must not have any parameter and must return a producer. It uses the partition mapper configuration to instantiate and configure the producer.","For example:"]},{"lang":"en","title":"Defining a processor","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-processor.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a processor"],"lvl1":["What is a processor","Defining output connections","Defining multiple inputs","Implementing batch processing","Shortcut syntax for bulk output processors"],"lvl2":["What is batch processing","Batch processing implementation logic"],"description":"How to develop a processor component with Talend Component Kit","keywords":"component type, processor, output","text":["A Processor is a component that converts incoming data to a different model.","A processor must have a method decorated with @ElementListener taking an incoming data and returning the processed data:","Processors must be Serializable because they are distributed components.","If you just need to access data on a map-based ruleset, you can use Record or JsonObject as parameter type. From there, Talend Component Kit wraps the data to allow you to access it as a map. The parameter type is not enforced. This means that if you know you will get a SuperCustomDto, then you can use it as parameter type. But for generic components that are reusable in any chain, it is highly encouraged to use Record until you have an evaluation language-based processor that has its own way to access components.","For example:","A processor also supports @BeforeGroup and @AfterGroup methods, which must not have any parameter and return void values. Any other result would be ignored. These methods are used by the runtime to mark a chunk of the data in a way which is estimated good for the execution flow size.","Because the size is estimated, the size of a group can vary. It is even possible to have groups of size 1.","It is recommended to batch records, for performance reasons:","You can optimize the data batch processing by using the maxBatchSize parameter. This parameter is automatically implemented on the component when it is deployed to a Talend application. Only the logic needs to be implemented. You can however customize its value setting in your LocalConfiguration the property _maxBatchSize.value - for the family - or ${component simple class name}._maxBatchSize.value - for a particular component, otherwise its default will be 1000. If you replace value by active, you can also configure if this feature is enabled or not. This is useful when you don’t want to use it at all. Learn how to implement chunking/bulking in this document.","In some cases, you may need to split the output of a processor in two or more connections. A common example is to have \"main\" and \"reject\" output connections where part of the incoming data are passed to a specific bucket and processed later.","Talend Component Kit supports two types of output connections: Flow and Reject.","Flow is the main and standard output connection.","The Reject connection handles records rejected during the processing. A component can only have one reject connection, if any. Its name must be REJECT to be processed correctly in Talend applications.","You can also define the different output connections of your component in the Starter.","To define an output connection, you can use @Output as replacement of the returned value in the @ElementListener:","Alternatively, you can pass a string that represents the new branch:","Having multiple inputs is similar to having multiple outputs, except that an OutputEmitter wrapper is not needed:","@Input takes the input name as parameter. If no name is set, it defaults to the \"main (default)\" input branch. It is recommended to use the default branch when possible and to avoid naming branches according to the component semantic.","Batch processing refers to the way execution environments process batches of data handled by a component using a grouping mechanism.","By default, the execution environment of a component automatically decides how to process groups of records and estimates an optimal group size depending on the system capacity. With this default behavior, the size of each group could sometimes be optimized for the system to handle the load more effectively or to match business requirements.","For example, real-time or near real-time processing needs often imply processing smaller batches of data, but more often. On the other hand, a one-time processing without business contraints is more effectively handled with a batch size based on the system capacity.","Final users of a component developed with the Talend Component Kit that integrates the batch processing logic described in this document can override this automatic size. To do that, a maxBatchSize option is available in the component settings and allows to set the maximum size of each group of data to process.","A component processes batch data as follows:","Case 1 - No maxBatchSize is specified in the component configuration. The execution environment estimates a group size of 4. Records are processed by groups of 4.","Case 2 - The runtime estimates a group size of 4 but a maxBatchSize of 3 is specified in the component configuration. The system adapts the group size to 3. Records are processed by groups of 3.","","Batch processing relies on the sequence of three methods: @BeforeGroup, @ElementListener, @AfterGroup, that you can customize to your needs as a component Developer.","The group size automatic estimation logic is automatically implemented when a component is deployed to a Talend application.","Each group is processed as follows until there is no record left:","The @BeforeGroup method resets a record buffer at the beginning of each group.","The records of the group are assessed one by one and placed in the buffer as follows: The @ElementListener method tests if the buffer size is greater or equal to the defined maxBatchSize. If it is, the records are processed. If not, then the current record is buffered.","The previous step happens for all records of the group. Then the @AfterGroup method tests if the buffer is empty.","","You can define the following logic in the processor configuration:","You can also use the condensed syntax for this kind of processor:","When writing tests for components, you can force the maxBatchSize parameter value by setting it with the following syntax: <configuration prefix>.$maxBatchSize=10.","You can learn more about processors in this document.","Defining a processor/output logic","General component execution logic","Implementing bulk processing","Best practices","For the case of output components (not emitting any data) using bulking you can pass the list of records to the after group method:"]},{"lang":"en","title":"Defining a processor or an output component logic","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-define-processor-output.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a processor or an output component logic"],"lvl1":["Defining a processor","Defining an output","Defining a combiner"],"lvl2":["What is a processor","Defining output connections","Defining multiple inputs","Implementing batch processing","Shortcut syntax for bulk output processors","What is an output","What is a combiner"],"lvl3":["What is batch processing","Batch processing implementation logic"],"description":"How to develop an output component with Talend Component Kit","keywords":"output, processor","text":["Processors and output components are the components in charge of reading, processing and transforming data in a Talend job, as well as passing it to its required destination.","Before implementing the component logic and defining its layout and configurable fields, make sure you have specified its basic metadata, as detailed in this document.","A Processor is a component that converts incoming data to a different model.","A processor must have a method decorated with @ElementListener taking an incoming data and returning the processed data:","Processors must be Serializable because they are distributed components.","If you just need to access data on a map-based ruleset, you can use Record or JsonObject as parameter type. From there, Talend Component Kit wraps the data to allow you to access it as a map. The parameter type is not enforced. This means that if you know you will get a SuperCustomDto, then you can use it as parameter type. But for generic components that are reusable in any chain, it is highly encouraged to use Record until you have an evaluation language-based processor that has its own way to access components.","For example:","A processor also supports @BeforeGroup and @AfterGroup methods, which must not have any parameter and return void values. Any other result would be ignored. These methods are used by the runtime to mark a chunk of the data in a way which is estimated good for the execution flow size.","Because the size is estimated, the size of a group can vary. It is even possible to have groups of size 1.","It is recommended to batch records, for performance reasons:","You can optimize the data batch processing by using the maxBatchSize parameter. This parameter is automatically implemented on the component when it is deployed to a Talend application. Only the logic needs to be implemented. You can however customize its value setting in your LocalConfiguration the property _maxBatchSize.value - for the family - or ${component simple class name}._maxBatchSize.value - for a particular component, otherwise its default will be 1000. If you replace value by active, you can also configure if this feature is enabled or not. This is useful when you don’t want to use it at all. Learn how to implement chunking/bulking in this document.","In some cases, you may need to split the output of a processor in two or more connections. A common example is to have \"main\" and \"reject\" output connections where part of the incoming data are passed to a specific bucket and processed later.","Talend Component Kit supports two types of output connections: Flow and Reject.","Flow is the main and standard output connection.","The Reject connection handles records rejected during the processing. A component can only have one reject connection, if any. Its name must be REJECT to be processed correctly in Talend applications.","You can also define the different output connections of your component in the Starter.","To define an output connection, you can use @Output as replacement of the returned value in the @ElementListener:","Alternatively, you can pass a string that represents the new branch:","Having multiple inputs is similar to having multiple outputs, except that an OutputEmitter wrapper is not needed:","@Input takes the input name as parameter. If no name is set, it defaults to the \"main (default)\" input branch. It is recommended to use the default branch when possible and to avoid naming branches according to the component semantic.","Batch processing refers to the way execution environments process batches of data handled by a component using a grouping mechanism.","By default, the execution environment of a component automatically decides how to process groups of records and estimates an optimal group size depending on the system capacity. With this default behavior, the size of each group could sometimes be optimized for the system to handle the load more effectively or to match business requirements.","For example, real-time or near real-time processing needs often imply processing smaller batches of data, but more often. On the other hand, a one-time processing without business contraints is more effectively handled with a batch size based on the system capacity.","Final users of a component developed with the Talend Component Kit that integrates the batch processing logic described in this document can override this automatic size. To do that, a maxBatchSize option is available in the component settings and allows to set the maximum size of each group of data to process.","A component processes batch data as follows:","Case 1 - No maxBatchSize is specified in the component configuration. The execution environment estimates a group size of 4. Records are processed by groups of 4.","Case 2 - The runtime estimates a group size of 4 but a maxBatchSize of 3 is specified in the component configuration. The system adapts the group size to 3. Records are processed by groups of 3.","","Batch processing relies on the sequence of three methods: @BeforeGroup, @ElementListener, @AfterGroup, that you can customize to your needs as a component Developer.","The group size automatic estimation logic is automatically implemented when a component is deployed to a Talend application.","Each group is processed as follows until there is no record left:","The @BeforeGroup method resets a record buffer at the beginning of each group.","The records of the group are assessed one by one and placed in the buffer as follows: The @ElementListener method tests if the buffer size is greater or equal to the defined maxBatchSize. If it is, the records are processed. If not, then the current record is buffered.","The previous step happens for all records of the group. Then the @AfterGroup method tests if the buffer is empty.","","You can define the following logic in the processor configuration:","You can also use the condensed syntax for this kind of processor:","When writing tests for components, you can force the maxBatchSize parameter value by setting it with the following syntax: <configuration prefix>.$maxBatchSize=10.","You can learn more about processors in this document.","Defining a processor/output logic","General component execution logic","Implementing bulk processing","Best practices","For the case of output components (not emitting any data) using bulking you can pass the list of records to the after group method:","An Output is a Processor that does not return any data.","Conceptually, an output is a data listener. It matches the concept of processor. Being the last component of the execution chain or returning no data makes your processor an output component:","Currently, Talend Component Kit does not allow you to define a Combiner. A combiner is the symmetric part of a partition mapper. It allows to aggregate results in a single partition."]},{"lang":"en","title":"Defining a standalone component logic","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-define-standalone.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining a standalone component logic"],"lvl1":["Defining a driver runner"],"lvl2":["What is a driver runner"],"description":"How to develop a standalone component with Talend Component Kit","keywords":"standalone, driver runner, driverrunner, run at driver","text":["Standalone components are the components without input or output flows. They are designed to do actions without reading or processing any data. For example standalone components can be used to create indexes in databases.","Before implementing the component logic and defining its layout and configurable fields, make sure you have specified its basic metadata, as detailed in this document.","A Driver Runner (DriverRunner) is a standalone component which doesn’t process or return any data.","A Driver runner must have a @RunAtDriver method without any parameter."]},{"lang":"en","title":"Defining an input component logic","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-define-input.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining an input component logic"],"lvl1":["Defining a partition mapper","Defining the producer method"],"lvl2":["What is a partition mapper","Implementing a partition mapper"],"lvl3":["@Assessor","@Split","@Emitter"],"description":"How to develop an input component with Talend Component Kit","keywords":"input, partition mapper, producer, emitter","text":["Input components are the components generally placed at the beginning of a Talend job. They are in charge of retrieving the data that will later be processed in the job.","An input component is primarily made of three distinct logics:","The execution logic of the component itself, defined through a partition mapper.","The configurable part of the component, defined through the mapper configuration.","The source logic defined through a producer.","Before implementing the component logic and defining its layout and configurable fields, make sure you have specified its basic metadata, as detailed in this document.","A Partition Mapper (PartitionMapper) is a component able to split itself to make the execution more efficient.","This concept is borrowed from big data and useful in this context only (BEAM executions). The idea is to divide the work before executing it in order to reduce the overall execution time.","The process is the following:","The size of the data you work on is estimated. This part can be heuristic and not very precise.","From that size, the execution engine (runner for Beam) requests the mapper to split itself in N mappers with a subset of the overall work.","The leaf (final) mapper is used as a Producer (actual reader) factory.","This kind of component must be Serializable to be distributable.","A partition mapper requires three methods marked with specific annotations:","@Assessor for the evaluating method","@Split for the dividing method","@Emitter for the Producer factory","The Assessor method returns the estimated size of the data related to the component (depending its configuration). It must return a Number and must not take any parameter.","For example:","The Split method returns a collection of partition mappers and can take optionally a @PartitionSize long value as parameter, which is the requested size of the dataset per sub partition mapper.","For example:","The Emitter method must not have any parameter and must return a producer. It uses the partition mapper configuration to instantiate and configure the producer.","For example:","The Producer defines the source logic of an input component. It handles the interaction with a physical source and produces input data for the processing flow.","A producer must have a @Producer method without any parameter. It is triggered by the @Emitter method of the partition mapper and can return any data. It is defined in the <component_name>Source.java file:"]},{"lang":"en","title":"Defining an output","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-output.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining an output"],"lvl1":["What is an output"],"description":"How to develop an output component with Talend Component Kit","keywords":"component type, output, processor","text":["An Output is a Processor that does not return any data.","Conceptually, an output is a data listener. It matches the concept of processor. Being the last component of the execution chain or returning no data makes your processor an output component:"]},{"lang":"en","title":"Defining component layout and configuration","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-configuration.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining component layout and configuration"],"lvl1":["Parameter name","Parameter types","Mapping complex objects","Defining Constraints and validations on the configuration","Defining datasets and datastores","Defining links between properties","Adding hints about the rendering","Implementation samples"],"lvl2":["Primitives","List case","Map case","MaxLength","MinLength","Pattern","Max","Min","Required","MaxItems","MinItems","UniqueItems","Defining a datastore","Defining a dataset","Internationalizing datasets and datastores","Reusing datasets and datastores in Talend Studio","How to create a reusable connection in Studio","How does the component server interact with datasets and datastores","ActiveIf","ActiveIfs","ActiveIf examples","@DefaultValue","@OptionsOrder","@AutoLayout","@GridLayout","@GridLayouts","@HorizontalLayout","@VerticalLayout","@Code","@Credential","@DateTime","@Structure","@TextArea"],"lvl3":["Dataset","Datastore","DatasetDiscovery","Example 1","Example 2","Snippets"],"description":"How to define the layout and configurable options of a component","keywords":"layout, option, field","text":["The component configuration is defined in the <component_name>Configuration.java file of the package. It consists in defining the configurable part of the component that will be displayed in the UI.","To do that, you can specify parameters. When you import the project in your IDE, the parameters that you have specified in the starter are already present.","All input and output components must reference a dataset in their configuration. Refer to Defining datasets and datastores.","Components are configured using their constructor parameters. All parameters can be marked with the @Option property, which lets you give a name to them.","For the name to be correct, you must follow these guidelines:","Use a valid Java name.","Do not include any . character in it.","Do not start the name with a $.","Defining a name is optional. If you don’t set a specific name, it defaults to the bytecode name. This can require you to compile with a -parameter flag to avoid ending up with names such as arg0, arg1, and so on.","Examples of option name:","Option name","Valid","myName","","my_name","","my.name","","$myName","","Parameter types can be primitives or complex objects with fields decorated with @Option exactly like method parameters.","It is recommended to use simple models which can be serialized in order to ease serialized component implementations.","For example:","Using this kind of API makes the configuration extensible and component-oriented, which allows you to define all you need.","The instantiation of the parameters is done from the properties passed to the component.","A primitive is a class which can be directly converted from a String to the expected type.","It includes all Java primitives, like the String type itself, but also all types with a org.apache.xbean.propertyeditor.Converter:","BigDecimal","BigInteger","File","InetAddress","ObjectName","URI","URL","Pattern","LocalDateTime","ZonedDateTime","The conversion from property to object uses the Dot notation.","For example, assuming the method parameter was configured with @Option(\"file\"):","matches","Lists rely on an indexed syntax to define their elements.","For example, assuming that the list parameter is named files and that the elements are of the FileOptions type, you can define a list of two elements as follows:","if you desire to override a config to truncate an array, use the index length, for example to truncate previous example to only CSV, you can set:","Similarly to the list case, the map uses .key[index] and .value[index] to represent its keys and values:","Avoid using the Map type. Instead, prefer configuring your component with an object if this is possible.","You can use metadata to specify that a field is required or has a minimum size, and so on. This is done using the validation metadata in the org.talend.sdk.component.api.configuration.constraint package:","Ensure the decorated option size is validated with a higher bound.","API: @org.talend.sdk.component.api.configuration.constraint.Max","Name: maxLength","Parameter Type: double","Supported Types: — java.lang.CharSequence","Sample:","Ensure the decorated option size is validated with a lower bound.","API: @org.talend.sdk.component.api.configuration.constraint.Min","Name: minLength","Parameter Type: double","Supported Types: — java.lang.CharSequence","Sample:","Validate the decorated string with a javascript pattern (even into the Studio).","API: @org.talend.sdk.component.api.configuration.constraint.Pattern","Name: pattern","Parameter Type: java.lang.string","Supported Types: — java.lang.CharSequence","Sample:","Ensure the decorated option size is validated with a higher bound.","API: @org.talend.sdk.component.api.configuration.constraint.Max","Name: max","Parameter Type: double","Supported Types: — java.lang.Number — int — short — byte — long — double — float","Sample:","Ensure the decorated option size is validated with a lower bound.","API: @org.talend.sdk.component.api.configuration.constraint.Min","Name: min","Parameter Type: double","Supported Types: — java.lang.Number — int — short — byte — long — double — float","Sample:","Mark the field as being mandatory.","API: @org.talend.sdk.component.api.configuration.constraint.Required","Name: required","Parameter Type: -","Supported Types: — java.lang.Object","Sample:","Ensure the decorated option size is validated with a higher bound.","API: @org.talend.sdk.component.api.configuration.constraint.Max","Name: maxItems","Parameter Type: double","Supported Types: — java.util.Collection","Sample:","Ensure the decorated option size is validated with a lower bound.","API: @org.talend.sdk.component.api.configuration.constraint.Min","Name: minItems","Parameter Type: double","Supported Types: — java.util.Collection","Sample:","Ensure the elements of the collection must be distinct (kind of set).","API: @org.talend.sdk.component.api.configuration.constraint.Uniques","Name: uniqueItems","Parameter Type: -","Supported Types: — java.util.Collection","Sample:","When using the programmatic API, metadata is prefixed by tcomp::. This prefix is stripped in the web for convenience, and the table above uses the web keys.","Also note that these validations are executed before the runtime is started (when loading the component instance) and that the execution will fail if they don’t pass. If it breaks your application, you can disable that validation on the JVM by setting the system property talend.component.configuration.validation.skip to true.","Datasets and datastores are configuration types that define how and where to pull the data from. They are used at design time to create shared configurations that can be stored and used at runtime.","All connectors (input and output components) created using Talend Component Kit must reference a valid dataset. Each dataset must reference a datastore.","Datastore: The data you need to connect to the backend.","Dataset: A datastore coupled with the data you need to execute an action.","Make sure that: a datastore is used in each dataset. each dataset has a corresponding input component (mapper or emitter). This input component must be able to work with only the dataset part filled by final users. Any other property implemented for that component must be optional. These rules are enforced by the validateDataSet validation. If the conditions are not met, the component builds will fail.","Make sure that:","a datastore is used in each dataset.","each dataset has a corresponding input component (mapper or emitter).","This input component must be able to work with only the dataset part filled by final users. Any other property implemented for that component must be optional.","These rules are enforced by the validateDataSet validation. If the conditions are not met, the component builds will fail.","A datastore defines the information required to connect to a data source. For example, it can be made of:","a URL","a username","a password.","You can specify a datastore and its context of use (in which dataset, etc.) from the Component Kit Starter.","Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.","Once you generate and import the project into an IDE, you can find datastores under a specific datastore node.","Example of datastore:","A dataset represents the inbound data. It is generally made of:","A datastore that defines the connection information needed to access the data.","A query.","You can specify a dataset and its context of use (in which input and output component it is used) from the Component Kit Starter.","Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.","Once you generate and import the project into an IDE, you can find datasets under a specific dataset node.","Example of dataset referencing the datastore shown above:","The display name of each dataset and datastore must be referenced in the message.properties file of the family package.","The key for dataset and datastore display names follows a defined pattern: ${family}.${configurationType}.${name}._displayName. For example:","These keys are automatically added for datasets and datastores defined from the Component Kit Starter.","When deploying a component or set of components that include datasets and datastores to Talend Studio, a new node is created under Metadata. This node has the name of the component family that was deployed.","It allows users to create reusable configurations for datastores and datasets.","With predefined datasets and datastores, users can then quickly fill the component configuration in their jobs. They can do so by selecting Repository as Property Type and by browsing to the predefined dataset or datastore.","Studio will generate connection and close components auto for reusing connection function in input and output components, just need to do like this example:","Then the runtime mapper and processor only need to use @Connection to get the connection like this:","The component server scans all configuration types and returns a configuration type index. This index can be used for the integration into the targeted platforms (Studio, web applications, and so on).","Mark a model (complex object) as being a dataset.","API: @org.talend.sdk.component.api.configuration.type.DataSet","Sample:","Mark a model (complex object) as being a datastore (connection to a backend).","API: @org.talend.sdk.component.api.configuration.type.DataStore","Sample:","Mark a model (complex object) as being a dataset discovery configuration.","API: @org.talend.sdk.component.api.configuration.type.DatasetDiscovery","Sample:","The component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","The configuration type index is represented as a flat tree that contains all the configuration types, which themselves are represented as nodes and indexed by ID.","Every node can point to other nodes. This relation is represented as an array of edges that provides the child IDs.","As an illustration, a configuration type index for the example above can be defined as follows:","If you need to define a binding between properties, you can use a set of annotations:","If the evaluation of the element at the location matches value then the element is considered active, otherwise it is deactivated.","API: @org.talend.sdk.component.api.configuration.condition.ActiveIf","Type: if","Sample:","Allows to set multiple visibility conditions on the same property.","API: @org.talend.sdk.component.api.configuration.condition.ActiveIfs","Type: ifs","Sample:","Where:","target is the element to evaluate.","value is the value to compare against.","strategy (optional) is the evaluation criteria. Possible values are:","CONTAINS: Checks if a string or list of strings contains the defined value.","DEFAULT: Compares against the raw value.","LENGTH: For an array or string, evaluates the size of the value instead of the value itself.","negate (optional) defines if the test must be positive (default, set to false) or negative (set to true).","operator (optional) is the comparison operator used to combine several conditions, if applicable. Possible values are AND and OR.","The target element location is specified as a relative path to the current location, using Unix path characters. The configuration class delimiter is /. The parent configuration class is specified by ... Thus, ../targetProperty denotes a property, which is located in the parent configuration class and is named targetProperty.","When using the programmatic API, metadata is prefixed with tcomp::. This prefix is stripped in the web for convenience, and the previous table uses the web keys.","For more details, refer to the related Javadocs.","A common use of the ActiveIf condition consists in testing if a target property has a value. To do that, it is possible to test if the length of the property value is different from 0:","target: foo - the path to the property to evaluate.","strategy: LENGTH - the strategy consists here in testing the length of the property value.","value: 0 - the length of the property value is compared to 0.","negate: true - setting negate to true means that the strategy of the target must be different from the value defined. In this case, the LENGTH of the value of the foo property must be different from 0.","The following example shows how to implement visibility conditions on several fields based on several checkbox configurations:","If the first checkbox is selected, an additional input field is displayed.","if the second or the third checkbox is selected, an additional input field is displayed.","if both second and third checkboxes are selected, an additional input field is displayed.","In some cases, you may need to add metadata about the configuration to let the UI render that configuration properly. For example, a password value that must be hidden and not a simple clear input box. For these cases - if you want to change the UI rendering - you can use a particular set of annotations:","Provide a default value the UI can use - only for primitive fields.","API: @org.talend.sdk.component.api.configuration.ui.DefaultValue","Allows to sort a class properties.","API: @org.talend.sdk.component.api.configuration.ui.OptionsOrder","Request the rendered to do what it thinks is best.","API: @org.talend.sdk.component.api.configuration.ui.layout.AutoLayout","Advanced layout to place properties by row, this is exclusive with @OptionsOrder.","the logic to handle forms (gridlayout names) is to use the only layout if there is only one defined, else to check if there are Main and Advanced and if at least Main exists, use them, else use all available layouts.","API: @org.talend.sdk.component.api.configuration.ui.layout.GridLayout","Allow to configure multiple grid layouts on the same class, qualified with a classifier (name)","API: @org.talend.sdk.component.api.configuration.ui.layout.GridLayouts","Put on a configuration class it notifies the UI an horizontal layout is preferred.","API: @org.talend.sdk.component.api.configuration.ui.layout.HorizontalLayout","Put on a configuration class it notifies the UI a vertical layout is preferred.","API: @org.talend.sdk.component.api.configuration.ui.layout.VerticalLayout","Mark a field as being represented by some code widget (vs textarea for instance).","API: @org.talend.sdk.component.api.configuration.ui.widget.Code","Mark a field as being a credential. It is typically used to hide the value in the UI.","API: @org.talend.sdk.component.api.configuration.ui.widget.Credential","Mark a field as being a date. It supports and is implicit - which means you don’t need to put that annotation on the option - for java.time.ZonedDateTime, java.time.LocalDate and java.time.LocalDateTime and is unspecified for other types.","API: @org.talend.sdk.component.api.configuration.ui.widget.DateTime","Mark a List<String> or List<Object> field as being represented as the component data selector.","API: @org.talend.sdk.component.api.configuration.ui.widget.Structure","Mark a field as being represented by a textarea(multiline text input).","API: @org.talend.sdk.component.api.configuration.ui.widget.TextArea","When using the programmatic API, metadata is prefixed with tcomp::. This prefix is stripped in the web for convenience, and the previous table uses the web keys.","You can also check this example about masking credentials.","Target support should cover org.talend.core.model.process.EParameterFieldType but you need to ensure that the web renderer is able to handle the same widgets.","You can find sample working components for each of the configuration cases below:","ActiveIf: Add visibility conditions on some configurations.","Checkbox: Add checkboxes or toggles to your component.","Code: Allow users to enter their own code.","Credential: Mark a configuration as sensitive data to avoid displaying it as plain text.","Datastore: Add a button allowing to check the connection to a datastore.","Datalist: Two ways of implementing a dropdown list with predefined choices.","Integer: Add numeric fields to your component configuration.","Min/Max: Specify a minimum or a maximum value for a numeric configuration.","Multiselect: Add a list and allow users to select multiple elements of that list.","Pattern: Enforce rules based on a specific a pattern to prevent users from entering invalid values.","Required: Make a configuration mandatory.","Suggestions: Suggest possible values in a field based on what the users are entering.","Table: Add a table to your component configuration.","Textarea: Add a text area for configurations expecting long texts or values.","Input: Add a simple text input field to the component configuration","Update: Provide a button allowing to fill a part of the component configuration based on a service.","Validation: Specify constraints to make sure that a URL is well formed."]},{"lang":"en","title":"Defining datasets and datastores","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/creating-dataset-datastore.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining datasets and datastores"],"lvl1":["Defining a datastore","Defining a dataset","Internationalizing datasets and datastores","Reusing datasets and datastores in Talend Studio","How to create a reusable connection in Studio","How does the component server interact with datasets and datastores"],"lvl2":["Dataset","Datastore","DatasetDiscovery"],"description":"Learn how to define datasets and datastores for input and output components.","keywords":"datastore, dataset, validation, input, output, studio, studio-integration, connection","text":["Datasets and datastores are configuration types that define how and where to pull the data from. They are used at design time to create shared configurations that can be stored and used at runtime.","All connectors (input and output components) created using Talend Component Kit must reference a valid dataset. Each dataset must reference a datastore.","Datastore: The data you need to connect to the backend.","Dataset: A datastore coupled with the data you need to execute an action.","Make sure that: a datastore is used in each dataset. each dataset has a corresponding input component (mapper or emitter). This input component must be able to work with only the dataset part filled by final users. Any other property implemented for that component must be optional. These rules are enforced by the validateDataSet validation. If the conditions are not met, the component builds will fail.","Make sure that:","a datastore is used in each dataset.","each dataset has a corresponding input component (mapper or emitter).","This input component must be able to work with only the dataset part filled by final users. Any other property implemented for that component must be optional.","These rules are enforced by the validateDataSet validation. If the conditions are not met, the component builds will fail.","A datastore defines the information required to connect to a data source. For example, it can be made of:","a URL","a username","a password.","You can specify a datastore and its context of use (in which dataset, etc.) from the Component Kit Starter.","Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.","Once you generate and import the project into an IDE, you can find datastores under a specific datastore node.","Example of datastore:","A dataset represents the inbound data. It is generally made of:","A datastore that defines the connection information needed to access the data.","A query.","You can specify a dataset and its context of use (in which input and output component it is used) from the Component Kit Starter.","Make sure to modelize the data your components are designed to handle before defining datasets and datastores in the Component Kit Starter.","Once you generate and import the project into an IDE, you can find datasets under a specific dataset node.","Example of dataset referencing the datastore shown above:","The display name of each dataset and datastore must be referenced in the message.properties file of the family package.","The key for dataset and datastore display names follows a defined pattern: ${family}.${configurationType}.${name}._displayName. For example:","These keys are automatically added for datasets and datastores defined from the Component Kit Starter.","When deploying a component or set of components that include datasets and datastores to Talend Studio, a new node is created under Metadata. This node has the name of the component family that was deployed.","It allows users to create reusable configurations for datastores and datasets.","With predefined datasets and datastores, users can then quickly fill the component configuration in their jobs. They can do so by selecting Repository as Property Type and by browsing to the predefined dataset or datastore.","Studio will generate connection and close components auto for reusing connection function in input and output components, just need to do like this example:","Then the runtime mapper and processor only need to use @Connection to get the connection like this:","The component server scans all configuration types and returns a configuration type index. This index can be used for the integration into the targeted platforms (Studio, web applications, and so on).","Mark a model (complex object) as being a dataset.","API: @org.talend.sdk.component.api.configuration.type.DataSet","Sample:","Mark a model (complex object) as being a datastore (connection to a backend).","API: @org.talend.sdk.component.api.configuration.type.DataStore","Sample:","Mark a model (complex object) as being a dataset discovery configuration.","API: @org.talend.sdk.component.api.configuration.type.DatasetDiscovery","Sample:","The component family associated with a configuration type (datastore/dataset) is always the one related to the component using that configuration.","The configuration type index is represented as a flat tree that contains all the configuration types, which themselves are represented as nodes and indexed by ID.","Every node can point to other nodes. This relation is represented as an array of edges that provides the child IDs.","As an illustration, a configuration type index for the example above can be defined as follows:"]},{"lang":"en","title":"Defining services","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-defining-services.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining services"],"description":"Get an overview of what are services and how to use services with Talend Component Kit","keywords":"service, component-manager, reuse configuration, overview, action, custom, interceptor, i18n, api","text":["Services are configurations that can be reused across several classes. Talend Component Kit comes with a predefined set of services that you can easily use.","You can still define your own services under the service node of your component project. By default, the Component Kit Starter generates a dedicated class in your project in which you can implement services.","Built-in services","Internationalizing a service","Providing actions through a service","Services and interceptors","Defining a custom API"]},{"lang":"en","title":"Defining the producer method","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-producer.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Defining the producer method"],"description":"How to develop a producer with Talend Component Kit","keywords":"component type, producer, emitter, input","text":["The Producer defines the source logic of an input component. It handles the interaction with a physical source and produces input data for the processing flow.","A producer must have a @Producer method without any parameter. It is triggered by the @Emitter method of the partition mapper and can return any data. It is defined in the <component_name>Source.java file:"]},{"lang":"en","title":"From Javajet to Talend Component Kit","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/javajet-to-componentkit.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["From Javajet to Talend Component Kit"],"lvl1":["Defining the component configuration","Defining the runtime","Component execution logic","Resources and examples"],"lvl2":["Widgets","Validations","Binding properties","After Variables","Main changes"],"lvl3":["Input/Text","Password","Textarea","Integer","Checkbox","List","Suggestions","Table","Code","Schema","Property validation","Property validation with Pattern","Data store validation","ActiveIf"],"description":"The Javajet framework is being replaced by the new Talend Component Kit. Learn the main differences and the new approach introduced with this framework.","keywords":"javajet, studio, studio-integration, learning, getting started, principles","text":["From the version 7.0 of Talend Studio, Talend Component Kit becomes the recommended framework to use to develop components.","This framework is being introduced to ensure that newly developed components can be deployed and executed both in on-premise/local and cloud/big data environments.","From that new approach comes the need to provide a complete yet unique and compatible way of developing components.","With the Component Kit, custom components are entirely implemented in Java. To help you get started with a new custom component development project, a Starter is available. Using it, you will be able to generate the skeleton of your project. By importing this skeleton in a development tool, you can then implement the components layout and execution logic in Java.","With the previous Javajet framework, metadata, widgets and configurable parts of a custom component were specified in XML. With the Component Kit, they are now defined in the <component_name><component_type>Configuration (for example, LoggerProcessorConfiguration) Java class of your development project.","Note that most of this configuration is transparent if you specified the Configuration Model of your components right before generating the project from the Starter.","Any undocumented feature or option is considered not supported by the Component Kit framework.","You can find examples of output in Studio or Cloud environments in the Gallery.","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","or","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","Javajet","Component Kit","or","Previously, the execution of a custom component was described through several Javajet files:","<component_name>_begin.javajet, containing the code required to initialize the component.","<component_name>_main.javajet, containing the code required to process each line of the incoming data.","<component_name>_end.javajet, containing the code required to end the processing and go to the following step of the execution.","With the Component Kit, the entire execution flow of a component is described through its main Java class <component_name><component_type> (for example, LoggerProcessor) and through services for reusable parts.","Each type of component has its own execution logic. The same basic logic is applied to all components of the same type, and is then extended to implement each component specificities. The project generated from the starter already contains the basic logic for each component.","Talend Component Kit framework relies on several primitive components.","All components can use @PostConstruct and @PreDestroy annotations to initialize or release some underlying resource at the beginning and the end of a processing.","In distributed environments, class constructor are called on cluster manager nodes. Methods annotated with @PostConstruct and @PreDestroy are called on worker nodes. Thus, partition plan computation and pipeline tasks are performed on different nodes.","","All the methods managed by the framework must be public. Private methods are ignored.","","","The framework is designed to be as declarative as possible but also to stay extensible by not using fixed interfaces or method signatures. This allows to incrementally add new features of the underlying implementations.","To ensure that the Cloud-compatible approach of the Component Kit framework is respected, some changes were introduced on the implementation side, including:","The File mode is no longer supported. You can still work with URIs and remote storage systems to use files. The file collection must be handled at the component implementation level.","The input and output connections between two components can only be of the Flow or Reject types. Other types of connections are not supported.","Every Output component must have a corresponding Input component and use a dataset. All datasets must use a datastore.","To get started with the Component Kit framework, you can go through the following documents:","Learn the basics about Talend Component Kit","Create and deploy your first Component Kit component","Learn about the Starter","Start implementing components","Integrate a component to Talend Studio","Check some examples of components built with Talend Component Kit"]},{"lang":"en","title":"Generating a project","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-generating-project.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Generating a project"],"description":"Get an overview of the first step to create a new component, which consists in building a project using the Component Kit Starter or the Component Kit plugin for IntelliJ","keywords":"starter, starter, overview, component project, intelliJ, intellij","text":["The first step when developing new components is to create a project that will contain the skeleton of your components and set you on the right track.","The project generation can be achieved using the Talend Component Kit Starter or the Talend Component Kit plugin for IntelliJ.","Through a user-friendly interface, you can define the main lines of your project and of your component(s), including their name, family, type, configuration model, and so on.","Once completed, all the information filled are used to generate a project that you will use as starting point to implement the logic and layout of your components, and to iterate on them.","Using the starter","Using the IntelliJ plugin","Once your project is generated, you can start implementing the component logic."]},{"lang":"en","title":"Generating a project using IntelliJ plugin","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/generate-project-using-intellij-plugin.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Generating a project using IntelliJ plugin"],"description":"Use the Talend Component Kit plugin for IntelliJ to generate a component project","keywords":"starter, starter, IDE, intellij, plugin","text":["Once the plugin installed, you can generate a component project.","Select File > New > Project.","In the New Project wizard, choose Talend Component and click Next.","The plugin loads the component starter and lets you design your components. For more information about the Talend Component Kit starter, check this tutorial.","Once your project is configured, select Next, then click Finish.","The project is automatically imported into the IDEA using the build tool that you have chosen."]},{"lang":"en","title":"Generating a project using the Component Kit Starter","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-generate-project-using-starter.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Generating a project using the Component Kit Starter"],"lvl1":["Configuring the project","Defining a Datastore","Defining a Dataset","Creating an Input component","Creating a Processor component","Creating an Output component","Generating and downloading the final project","Compiling and exploring the generated project files","Generating a project using an OpenAPI JSON descriptor"],"description":"Learn how to define the basic configuration of a component using the Talend Component Kit Starter to start your project","keywords":"tutorial, example, starter","text":["The Component Kit Starter lets you design your components configuration and generates a ready-to-implement project structure.","The Starter is available on the web or as an IntelliJ plugin.","This tutorial shows you how to use the Component Kit Starter to generate new components for MySQL databases. Before starting, make sure that you have correctly setup your environment. See this section.","When defining a project using the Starter, do not refresh the page to avoid losing your configuration.","Before being able to create components, you need to define the general settings of the project:","Create a folder on your local machine to store the resource files of the component you want to create. For example, C:/my_components.","Open the Starter in the web browser of your choice.","Select your build tool. This tutorial uses Maven, but you can select Gradle instead.","Add any facet you need. For example, add the Talend Component Kit Testing facet to your project to automatically generate unit tests for the components created in the project.","Enter the Component Family of the components you want to develop in the project. This name must be a valid java name and is recommended to be capitalized, for example 'MySQL'. Once you have implemented your components in the Studio, this name is displayed in the Palette to group all of the MySQL-related components you develop, and is also part of your component name.","Select the Category of the components you want to create in the current project. As MySQL is a kind of database, select Databases in this tutorial. This Databases category is used and displayed as the parent family of the MySQL group in the Palette of the Studio.","Complete the project metadata by entering the Group, Artifact and Package.","By default, you can only create processors. If you need to create Input or Output components, select Activate IO. By doing this:","Two new menu entries let you add datasets and datastores to your project, as they are required for input and output components.","Input and Output components without dataset (itself containing a datastore) will not pass the validation step when building the components. Learn more about datasets and datastores in this document.","An Input component and an Output component are automatically added to your project and ready to be configured.","Components added to the project using Add A Component can now be processors, input or output components.","A datastore represents the data needed by an input or output component to connect to a database.","When building a component, the validateDataSet validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.","You can define one or several datastores if you have selected the Activate IO step.","Select Datastore. The list of datastores opens. By default, a datastore is already open but not configured. You can configure it or create a new one using Add new Datastore.","Specify the name of the datastore. Modify the default value to a meaningful name for your project. This name must be a valid Java name as it will represent the datastore class in your project. It is a good practice to start it with an uppercase letter.","Edit the datastore configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes connection details to a database:","url","username","password.","Save the datastore configuration.","A dataset represents the data coming from or sent to a database and needed by input and output components to operate.","The validateDataSet validation checks that each input or output (processor without output branch) component uses a dataset and that this dataset has a datastore.","You can define one or several datasets if you have selected the Activate IO step.","Select Dataset. The list of datasets opens. By default, a dataset is already open but not configured. You can configure it or create a new one using the Add new Dataset button.","Specify the name of the dataset. Modify the default value to a meaningful name for your project. This name must be a valid Java name as it will represent the dataset class in your project. It is a good practice to start it with an uppercase letter.","Edit the dataset configuration. Parameter names must be valid Java names. Use lower case as much as possible. A typical configuration includes details of the data to retrieve:","Datastore to use (that contains the connection details to the database)","table name","data","Save the dataset configuration.","To create an input component, make sure you have selected Activate IO.","When clicking Add A Component in the Starter, a new step allows you to define a new component in your project. The intent in this tutorial is to create an input component that connects to a MySQL database, executes a SQL query and gets the result.","Choose the component type. Input in this case.","Enter the component name. For example, MySQLInput.","Click Configuration model. This button lets you specify the required configuration for the component. By default, a dataset is already specified.","For each parameter that you need to add, click the (+) button on the right panel. Enter the parameter name and choose its type then click the tick button to save the changes. In this tutorial, to be able to execute a SQL query on the Input MySQL database, the configuration requires the following parameters:+","a dataset (which contains the datastore with the connection information)","a timeout parameter.","Closing the configuration panel on the right does not delete your configuration. However, refreshing the page resets the configuration.","Specify whether the component issues a stream or not. In this tutorial, the MySQL input component created is an ordinary (non streaming) component. In this case, leave the Stream option disabled.","Select the Record Type generated by the component. In this tutorial, select Generic because the component is designed to generate records in the default Record format. You can also select Custom to define a POJO that represents your records.","Your input component is now defined. You can add another component or generate and download your project.","When clicking Add A Component in the Starter, a new step allows you to define a new component in your project. The intent in this tutorial is to create a simple processor component that receives a record, logs it and returns it at it is.","If you did not select Activate IO, all new components you add to the project are processors by default. If you selected Activate IO, you can choose the component type. In this case, to create a Processor component, you have to manually add at least one output.","If required, choose the component type: Processor in this case.","Enter the component name. For example, RecordLogger, as the processor created in this tutorial logs the records.","Specify the Configuration Model of the component. In this tutorial, the component doesn’t need any specific configuration. Skip this step.","Define the Input(s) of the component. For each input that you need to define, click Add Input. In this tutorial, only one input is needed to receive the record to log.","Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them. The input in this tutorial is a generic record. Enable the Generic option and click Save.","Define the Output(s) of the component. For each output that you need to define, click Add Output. The first output must be named MAIN. In this tutorial, only one generic output is needed to return the received record. Outputs can be configured the same way as inputs (see previous steps). You can define a reject output connection by naming it REJECT. This naming is used by Talend applications to automatically set the connection type to Reject.","Your processor component is now defined. You can add another component or generate and download your project.","To create an output component, make sure you have selected Activate IO.","When clicking Add A Component in the Starter, a new step allows you to define a new component in your project. The intent in this tutorial is to create an output component that receives a record and inserts it into a MySQL database table.","Output components are Processors without any output. In other words, the output is a processor that does not produce any records.","Choose the component type. Output in this case.","Enter the component name. For example, MySQLOutput.","Click Configuration Model. This button lets you specify the required configuration for the component. By default, a dataset is already specified.","For each parameter that you need to add, click the (+) button on the right panel. Enter the name and choose the type of the parameter, then click the tick button to save the changes. In this tutorial, to be able to insert a record in the output MySQL database, the configuration requires the following parameters:+","a dataset (which contains the datastore with the connection information)","a timeout parameter.","Closing the configuration panel on the right does not delete your configuration. However, refreshing the page resets the configuration.","Define the Input(s) of the component. For each input that you need to define, click Add Input. In this tutorial, only one input is needed.","Click the input name to access its configuration. You can change the name of the input and define its structure using a POJO. If you added several inputs, repeat this step for each one of them. The input in this tutorial is a generic record. Enable the Generic option and click Save.","Do not create any output because the component does not produce any record. This is the only difference between an output an a processor component.","Your output component is now defined. You can add another component or generate and download your project.","Once your project is configured and all the components you need are created, you can generate and download the final project. In this tutorial, the project was configured and three components of different types (input, processor and output) have been defined.","Click Finish on the left panel. You are redirected to a page that summarizes the project. On the left panel, you can also see all the components that you added to the project.","Generate the project using one of the two options available:","Download it locally as a ZIP file using the Download as ZIP button.","Create a GitHub repository and push the project to it using the Create on Github button.","In this tutorial, the project is downloaded to the local machine as a ZIP file.","Once the package is available on your machine, you can compile it using the build tool selected when configuring the project.","In the tutorial, Maven is the build tool selected for the project. In the project directory, execute the mvn package command. If you don’t have Maven installed on your machine, you can use the Maven wrapper provided in the generated project, by executing the ./mvnw package command.","If you have created a Gradle project, you can compile it using the gradle build command or using the Gradle wrapper: ./gradlew build.","The generated project code contains documentation that can guide and help you implementing the component logic. Import the project to your favorite IDE to start the implementation.","The Component Kit Starter allows you to generate a component development project from an OpenAPI JSON descriptor.","Open the Starter in the web browser of your choice.","Enable the OpenAPI mode using the toggle in the header.","Go to the API menu.","Paste the OpenAPI JSON descriptor in the right part of the screen. All the described endpoints are detected.","Unselect the endpoints that you do not want to use in the future components. By default, all detected endpoints are selected.","Go to the Finish menu.","Download the project.","When exploring the project generated from an OpenAPI descriptor, you can notice the following elements:","sources","the API dataset","an HTTP client for the API","a connection folder containing the component configuration. By default, the configuration is only made of a simple datastore with a baseUrl parameter."]},{"lang":"en","title":"Generating data","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/testing-generating-data.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Generating data"],"description":"Learn how to generate data for testing components developed with Talend Component Kit","keywords":"test, generate data, testing","text":["Several data generators exist if you want to populate objects with a semantic that is more evolved than a plain random string like commons-lang3:","github.com/Codearte/jfairy","github.com/DiUS/java-faker","github.com/andygibson/datafactory","etc.","Even more advanced, the following generators allow to directly bind generic data on a model. However, data quality is not always optimal:","github.com/devopsfolks/podam","github.com/benas/random-beans","etc.","There are two main kinds of implementation:","Implementations using a pattern and random generated data.","Implementations using a set of precomputed data extrapolated to create new values.","Check your use case to know which one fits best.","An alternative to data generation can be to import real data and use Talend Studio to sanitize the data, by removing sensitive information and replacing it with generated or anonymized data. Then you just need to inject that file into the system.","If you are using JUnit 5, you can have a look at glytching.github.io/junit-extensions/randomBeans."]},{"lang":"en","title":"Getting started with Talend Component Kit","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/getting-started.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Getting started with Talend Component Kit"],"lvl1":["Talend Component Kit methodology","Component types","Next"],"description":"Learn the basics about Talend Component Kit framework and get ready to create new components","keywords":"quickstart, overview, principle, description","text":["Talend Component Kit is a Java framework designed to simplify the development of components at two levels:","The Runtime, that injects the specific component code into a job or pipeline. The framework helps unifying as much as possible the code required to run in Data Integration (DI) and BEAM environments.","The Graphical interface. The framework helps unifying the code required to render the component in a browser or in the Eclipse-based Talend Studio (SWT).","Most part of the development happens as a Maven or Gradle project and requires a dedicated tool such as IntelliJ.","The Component Kit is made of:","A Starter, that is a graphical interface allowing you to define the skeleton of your development project.","APIs to implement components UI and runtime.","Development tools: Maven and Gradle wrappers, validation rules, packaging, Web preview, etc.","A testing kit based on JUnit 4 and 5.","By using this tooling in a development environment, you can start creating components as described below.","Developing new components using the Component Kit framework includes:","Creating a project using the starter or the Talend IntelliJ plugin. This step allows to build the skeleton of the project. It consists in:","Defining the general configuration model for each component in your project.","Generating and downloading the project archive from the starter.","Compiling the project.","Importing the compiled project in your IDE. This step is not required if you have generated the project using the IntelliJ plugin.","Implementing the components, including:","Registering the components by specifying their metadata: family, categories, version, icon, type and name.","Defining the layout and configurable part of the components.","Defining the execution logic of the components, also called runtime.","Testing the components.","Deploying the components to Talend Studio or Cloud applications.","Optionally, you can use services. Services are predefined or user-defined configurations that can be reused in several components.","","There are four types of components, each type coming with its specificities, especially on the runtime side.","Input components: Retrieve the data to process from a defined source. An input component is made of:","The execution logic of the component, represented by a Mapper or an Emitter class.","The source logic of the component, represented by a Source class.","The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a Configuration class. All input components must have a dataset specified in their configuration, and every dataset must use a datastore.","Processors: Process and transform the data. A processor is made of:","The execution logic of the component, describing how to process each records or batches of records it receives. It also describes how to pass records to its output connections. This logic is defined in a Processor class.","The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a Configuration class.","Output components: Send the processed data to a defined destination. An output component is made of:","The execution logic of the component, describing how to process each records or batches of records it receives. This logic is defined in an Output class. Unlike processors, output components are the last components of the execution and return no data.","The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a Configuration class. All input components must have a dataset specified in their configuration, and every dataset must use a datastore.","Standalone components: Make a call to the service or run a query on the database. A standalone component is made of:","The execution logic of the component, represented by a DriverRunner class.","The layout of the component and the configuration that the end-user will need to provide when using the component, defined by a Configuration class. All input components must have a datastore or dataset specified in their configuration, and every dataset must use a datastore.","The following example shows the different classes of an input components in a multi-component development project:","Setup your development environment","Generate your first project and develop your first component"]},{"lang":"en","title":"Handling component version migration","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-handle-talend-component-migration.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Handling component version migration"],"lvl1":["Requirements","Creating the version 1 of the component","Creating the version 2 of the component","Handling the migration from the version 1 to the version 2"],"lvl2":["Declaring the migration handler","Implementing the migration handler"],"description":"How to handle component version migration","keywords":"tutorial, migration, component, backward compatibility, configuration, option, component-manager, api","text":["Talend Component Kit provides a migration mechanism between two versions of a component to let you ensure backward compatibility.","For example, a new version of a component may have some new options that need to be remapped, set with a default value in the older versions, or disabled.","This tutorial shows how to create a migration handler for a component that needs to be upgraded from a version 1 to a version 2. The upgrade to the newer version includes adding new options to the component.","This tutorial assumes that you know the basics about component development and are familiar with component project generation and implementation.","To follow this tutorial, you need:","Java 8","A Talend component development environment using Talend Component Kit. Refer to this document.","Have generated a project containing a simple processor component using the Talend Component Kit Starter.","First, create a simple processor component configured as follows:","Create a simple configuration class that represents a basic authentication and that can be used in any component requiring this kind of authentication.","Create a simple output component that uses the configuration defined earlier. The component configuration is injected into the component constructor.","The version of the configuration class corresponds to the component version.","By configuring these two classes, the first version of the component is ready to use a simple authentication mechanism.","Now, assuming that the component needs to support a new authentication mode following a new requirement, the next steps are:","Creating a version 2 of the component that supports the new authentication mode.","Handling migration from the first version to the new version.","The second version of the component needs to support a new authentication method and let the user choose the authentication mode he wants to use using a dropdown list.","Add an Oauth2 authentication mode to the component in addition to the basic mode. For example:","The options of the new authentication mode are now defined.","Wrap the configuration created above in a global configuration with the basic authentication mode and add an enumeration to let the user choose the mode to use. For example, create an AuthenticationConfiguration class as follows:","Using the @ActiveIf annotation allows to activate the authentication type according to the selected authentication mode.","Edit the component to use the new configuration that supports an additional authentication mode. Also upgrade the component version from 1 to 2 as its configuration has changed.","The component now supports two authentication modes in its version 2. Once the new version is ready, you can implement the migration handler that will take care of adapting the old configuration to the new one.","What can happen if an old configuration is passed to the new component version?","It simply fails, as the version 2 does not recognize the old version anymore. For that reason, a migration handler that adapts the old configuration to the new one is required. It can be achieved by defining a migration handler class in the @Version annotation of the component class.","An old configuration may already be persisted by an application that integrates the version 1 of the component (Studio or web application).","Add a migration handler class to the component version.","Create the migration handler class MyOutputMigrationHandler.","the incoming version, which is the version of the configuration that we are migrating from","a map (key, value) of the configuration, where the key is the configuration path and the value is the value of the configuration.","You need to be familiar with the component configuration path construction to better understand this part. Refer to Defining component layout and configuration.","As a reminder, the following changes were made since the version 1 of the component:","The configuration BasicAuth from the version 1 is not the root configuration anymore, as it is under AuthenticationConfiguration.","AuthenticationConfiguration is the new root configuration.","The component supports a new authentication mode (Oauth2) which is the default mode in the version 2 of the component.","To migrate the old component version to the new version and to keep backward compatibility, you need to:","Remap the old configuration to the new one.","Give the adequate default values to some options.","In the case of this scenario, it means making all configurations based on the version 1 of the component have the authenticationMode set to basic by default and remapping the old basic authentication configuration to the new one.","if a configuration has been renamed between 2 component versions, you can get the old configuration option from the configuration map by using its old path and set its value using its new path.","You can now upgrade your component without losing backward compatibility."]},{"lang":"en","title":"Icons","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/icons.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Icons"]},{"lang":"en","title":"Implementing an Output component for Hazelcast","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-create-an-output-component.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Implementing an Output component for Hazelcast"],"lvl1":["Defining the configurable part and the layout of the component","Output Implementation"],"lvl2":["Defining the constructor method","Defining the PostConstruct method","Defining the PreDestroy method","Defining the ElementListener method","Testing the output component"],"description":"Example of output component implementation with Talend Component Kit","keywords":"tutorial, example, output, processor, hazelcast","text":["This tutorial is the continuation of Talend Input component for Hazelcast tutorial. We will not walk through the project creation again, So please start from there before taking this one.","This tutorial shows how to create a complete working output component for Hazelcast","As seen before, in Hazelcast there is multiple data source type. You can find queues, topics, cache, maps…","In this tutorials we will stick with the Map dataset and all what we will see here is applicable to the other types.","Let’s assume that our Hazelcast output component will be responsible of inserting data into a distributed Map. For that, we will need to know which attribute from the incoming data is to be used as a key in the map. The value will be the hole record encoded into a json format.","Bu that in mind, we can design our output configuration as: the same Datastore and Dataset from the input component and an additional configuration that will define the key attribute.","Let’s create our Output configuration class.","Let’s add the i18n properties of our configuration into the Messages.properties file","The skeleton of the output component looks as follows:","@Version annotation indicates the version of the component. It is used to migrate the component configuration if needed.","@Icon annotation indicates the icon of the component. Here, the icon is a custom icon that needs to be bundled in the component JAR under resources/icons.","@Processor annotation indicates that this class is the processor (output) and defines the name of the component.","constructor of the processor is responsible for injecting the component configuration and services. Configuration parameters are annotated with @Option. The other parameters are considered as services and are injected by the component framework. Services can be local (class annotated with @Service) or provided by the component framework.","The method annotated with @PostConstruct is executed once by instance and can be used for initialization.","The method annotated with @PreDestroy is used to clean resources at the end of the execution of the output.","Data is passed to the method annotated with @ElementListener. That method is responsible for handling the data output. You can define all the related logic in this method.","If you need to bulk write the updates accordingly to groups, see Processors and batch processing.","Now, we will need to add the display name of the Output to the i18n resources file Messages.properties","Let’s implement all of those methods","We will create the outpu contructor to inject the component configuration and some additional local and built in services.","Built in services are services provided by TCK.","Here we find:","configuration is the component configuration class","hazelcastService is the service that we have implemented in the input component tutorial. it will be responsible of creating a hazelcast client instance.","jsonb is a built in service provided by tck to handle json object serialization and deserialization. We will use it to convert the incoming record to json format before inseting them into the map.","Nothing to do in the post construct method. but we could for example initialize a hazle cast instance there. but we will do it in a lazy way on the first call in the @ElementListener method","Shut down the Hazelcast client instance and thus free the Hazelcast map reference.","We get the key attribute from the incoming record and then convert the hole record to a json string. Then we insert the key/value into the hazelcast map.","Let’s create a unit test for our output component. The idea will be to create a job that will insert the data using this output implementation.","So, let’s create out test class.","Here we start by creating a hazelcast test instance, and we initialize the map. we also shutdown the instance after all the test are executed.","Now let’s create our output test.","Here we start preparing the emitter test component provided bt TCK that we use in our test job to generate random data for our output. Then, we use the output component to fill the hazelcast map.","By the end we test that the map contains the exact amount of data inserted by the job.","Run the test and check that it’s working.","Congratulation you just finished your output component."]},{"lang":"en","title":"Implementing batch processing","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/concept-processor-and-batch-processing.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Implementing batch processing"],"lvl1":["What is batch processing","Batch processing implementation logic"],"description":"Optimize the way your processor component handle records using groups","keywords":"bulk, bulking, chunk, group, maxBatchSize, bulking, batch","text":["Batch processing refers to the way execution environments process batches of data handled by a component using a grouping mechanism.","By default, the execution environment of a component automatically decides how to process groups of records and estimates an optimal group size depending on the system capacity. With this default behavior, the size of each group could sometimes be optimized for the system to handle the load more effectively or to match business requirements.","For example, real-time or near real-time processing needs often imply processing smaller batches of data, but more often. On the other hand, a one-time processing without business contraints is more effectively handled with a batch size based on the system capacity.","Final users of a component developed with the Talend Component Kit that integrates the batch processing logic described in this document can override this automatic size. To do that, a maxBatchSize option is available in the component settings and allows to set the maximum size of each group of data to process.","A component processes batch data as follows:","Case 1 - No maxBatchSize is specified in the component configuration. The execution environment estimates a group size of 4. Records are processed by groups of 4.","Case 2 - The runtime estimates a group size of 4 but a maxBatchSize of 3 is specified in the component configuration. The system adapts the group size to 3. Records are processed by groups of 3.","","Batch processing relies on the sequence of three methods: @BeforeGroup, @ElementListener, @AfterGroup, that you can customize to your needs as a component Developer.","The group size automatic estimation logic is automatically implemented when a component is deployed to a Talend application.","Each group is processed as follows until there is no record left:","The @BeforeGroup method resets a record buffer at the beginning of each group.","The records of the group are assessed one by one and placed in the buffer as follows: The @ElementListener method tests if the buffer size is greater or equal to the defined maxBatchSize. If it is, the records are processed. If not, then the current record is buffered.","The previous step happens for all records of the group. Then the @AfterGroup method tests if the buffer is empty.","","You can define the following logic in the processor configuration:","You can also use the condensed syntax for this kind of processor:","When writing tests for components, you can force the maxBatchSize parameter value by setting it with the following syntax: <configuration prefix>.$maxBatchSize=10.","You can learn more about processors in this document."]},{"lang":"en","title":"Implementing components","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-creating-components.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Implementing components"],"description":"Get an overview of the main steps to code the logic of your custom Talend Componit Kit components","keywords":"create, code, class, logic, layout, configuration, dev, overview, api","text":["Once you have generated a project, you can start implementing the logic and layout of your components and iterate on it. Depending on the type of component you want to create, the logic implementation can differ. However, the layout and component metadata are defined the same way for all types of components in your project. The main steps are:","Defining family and component metadata","Defining an input component logic","Defining a processor/output logic","Defining a standalone component logic","Defining component layout and configuration","","In some cases, you will require specific implementations to handle more advanced cases, such as:","Internationalizing a component","Managing component versions","Masking sensitive data","Implementing batch processing","Implementing streaming on a component","You can also make certain configurations reusable across your project by defining services. Using your Java IDE along with a build tool supported by the framework, you can then compile your components to test and deploy them to Talend Studio or other Talend applications:","Building components with Maven","Building components with Gradle","Wrapping a Beam I/O","In any case, follow these best practices to ensure the components you develop are optimized.","You can also learn more about component loading and plugins here:","Loading a component"]},{"lang":"en","title":"Implementing streaming on a component","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-implementing-streaming.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Implementing streaming on a component"],"lvl1":["Choosing between batch and streaming","Enabling streaming from the Component Kit starter","Configuring streaming from the project"],"lvl2":["Constant strategy","Exponential strategy"],"description":"How to make your input component ready for a continuous flow of data.","keywords":"stream, infinite, partition mapper, input","text":["By default, input components are designed to receive a one-time batch of data to process. By enabling the streaming mode, you can instead set your component to process a continuous incoming flow of data.","When streaming is enabled on an input component, the component tries to pull data from its producer. When no data is pulled, it waits for a defined period of time before trying to pull data again, and so on. This period of time between tries is defined by a strategy.","This document explains how to configure this strategy and the cases where it can fit your needs.","Before enabling streaming on your component, make sure that it fits the scope and requirements of your project and that regular batch processing cannot be used instead.","Streaming is designed to help you dealing with real-time or near real-time data processing cases, and should be used only for such cases. Enabling streaming will impact the performance when processing batches of data.","You can enable streaming right from the design phase of the project by enabling the Stream toggle in the basic configuration of your future component in the Component Kit Starter.","Doing so adds a default streaming-ready configuration to your component when generating the project. This default configuration implements a constant pause duration of 500 ms between retries, with no limit of retries.","If streaming was not enabled at all during the project generation or if you need to implement a more specific configuration, you can change the default settings according to your needs:","Add the infinite=true parameter to your component class.","Define the number of retries allowed in the component family LocalConfiguration, using the talend.input.streaming.retry.maxRetries parameter. It is set by default to Integer.MAX_VALUE.","Define the pausing strategy between retries in the component family LocalConfiguration, using the talend.input.streaming.retry.strategy parameter. Possible values are:","constant (default). It sets a constant pause duration between retries.","exponential. It sets an exponential backoff pause duration.","See the tables below for more details about each strategy.","Parameter","Description","Default value","talend.input.streaming.retry.constant.timeout","Pause duration for the constant strategy, in ms.","500","Parameter","Description","Default value","talend.input.streaming.retry.exponential.exponent","Exponent of the exponential calculation.","1.5","talend.input.streaming.retry.exponential.randomizationFactor","Randomization factor used in the calculation.","0.5","talend.input.streaming.retry.exponential.maxDuration","Maximum pausing duration between two retries.","5*60*1000 (5 minutes)","talend.input.streaming.retry.exponential.initialBackOff","Initial backoff value.","1000 (1 second)","The values of these parameters are then used in the following calculations to determine the exact pausing duration between two retries.","For more clarity in the formulas below, parameter names have been replaced with variables.","First, the current interval duration is calculated:","\\$A = min(B xx E^I, F)\\$","Where:","A: currentIntervalMillis","B: initialBackOff","E: exponent","I: current number of retries","F: maxDuration","Then, from the current interval duration, the next interval duration is calculated:","\\$D = min(F, A + ((R xx 2-1) xx C xx A))\\$","Where:","D: nextBackoffMillis","F: maxDuration","A: currentIntervalMillis","R: random","C: randomizationFactor"]},{"lang":"en","title":"Installing components using a CAR file","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/studio-from-car.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Installing components using a CAR file"],"lvl1":["Deploying from the CAR file to Talend Studio","Deploying a component archive to a remote project from Talend Studio","Troubleshooting"],"description":"How to build a component archive that you can easily share and how to install the shared .car file in Talend Studio.","keywords":"deploy, install, car, .car, car-bundler, component archive, studio-integration","text":["Components built using Talend Component Kit can be shared as component archives (.car). These CAR files are executable files allowing to easily deploy the components it contains to any compatible version of Talend Studio.","Component developers can generate .car files from their projects to share their components and make them available for other users, as detailed in this document.","This document assumes that you have a component archive (.car) file and need to deploy it to Talend Studio.","The component archive (.car) is executable and exposes the studio-deploy command which takes a Talend Studio home path as parameter. When executed, it installs the dependencies into the Studio and registers the component in your instance. For example:","You can also upload the dependencies to your Nexus server using the following command:","In this command, Nexus URL and repository name are mandatory arguments. All other arguments are optional. If arguments contain spaces or special symbols, you need to quote the whole value of the argument. For example:","Talend Studio allows you to share components you have created using Talend Component Kit to other users working on the same remote project.","Remote projects are available with Enterprise versions of Talend Studio only. Also, note that this feature has been removed in Studio since 7.3 release.","Make sure you are connected to a remote project and the artifact repository for component sharing has been properly configured.","On the toolbar of the Studio main window, click or click File > Edit Project Properties from the menu bar to open the Project Settings dialog box.","In the tree view of the dialog box, select Repository Share to open the corresponding view.","Select the Propagate components update to Artifact Repository check box.","In the Repository ID field, specify the artifact repository configured for component sharing, and then click Check connection to verify the connectivity.","Click Apply and Close to validate the settings and close the dialog box.","Create a folder named patches at the root of your Talend Studio installation directory, then copy the .car files of the components you want share to this folder.","Restart your Talend Studio and connect to the remote project.","The components are deployed automatically to the repository and available in the Palette for other users when connected to a remote project with the same sharing repository configuration.","My custom component builds correctly but does not appear in Talend Studio, how to fix it? This issue can be caused by the icon specified in the component metadata.","Make sure to specify a custom icon for the component and the component family.","These custom icons must be in PNG format to be properly handled by Talend Studio.","Remove SVG parameters from the talend.component.server.icon.paths property in the HTTP server configuration. Refer to this section.","Learn more about defining custom icons for components in this document."]},{"lang":"en","title":"Installing the Talend Component Kit IntelliJ plugin","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/installing-talend-intellij-plugin.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Installing the Talend Component Kit IntelliJ plugin"],"lvl1":["Installing the IntelliJ plugin","About the internationalization completion"],"description":"how to install the Talend Component Kit plugin for IntelliJ","keywords":"IntelliJ, plugin, starter","text":["The Talend Component Kit IntelliJ plugin is a plugin for the IntelliJ Java IDE. It adds support for the Talend Component Kit project creation.","Main features:","Project generation support.","Internationalization completion for component configuration.","In the Intellij IDEA:","Go to File > Settings…","On the left panel, select Plugins.","Access the Marketplace tab.","Enter Talend in the search field and Select Talend Component Kit.","Select Install.","Click the Restart IDE button.","Confirm the IDEA restart to complete the installation.","The plugin is now installed on your IntelliJ IDEA. You can start using it.","The plugin offers auto-completion for the configuration internationalization. The Talend component configuration lets you setup translatable and user-friendly labels for your configuration using a property file. Auto-completion in possible for the configuration keys and default values in the property file.","For example, you can internationalize a simple configuration class for a basic authentication that you use in your component:","This configuration class contains three properties which you can attach a user-friendly label to.","For example, you can define a label like My server URL for the url option:","Locate or create a Messages.properties file in the project resources and add the label to that file. The plugin automatically detects your configuration and provides you with key completion in the property file.","Press Ctrl+Space to see the key suggestions."]},{"lang":"en","title":"Integrating components into Talend Cloud","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-cloud-integration.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Integrating components into Talend Cloud"],"description":"Integrate components into Talend Cloud and learn about the component server","keywords":"web, component server, component-server, cloud","text":["Learn about the Component Server with the following articles:","Component server and HTTP API","Component Server Vault Proxy"]},{"lang":"en","title":"Integrating components into Talend Studio","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-deploying-components.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Integrating components into Talend Studio"],"description":"Get an overview of how to integrate your components created using Talend Component Kit to Talend Studio","keywords":"integration, deployment, open studio, studio, studio-integration","text":["To be able to see and use your newly developed components, you need to integrate them to the right application.","Currently, you can deploy your components to Talend Studio as part of your development process to iterate on them:","Iterating on component development with Talend Studio","You can also share your components externally and install them using a component archive (.car) file.","Sharing and installing components in Talend Studio","Check the versions of the framework that are compatible with your version of Talend Studio in this document.","If you were used to create custom components with the Javajet framework and want to get to know the new approach and main differences of the Component Kit framework, refer to this document."]},{"lang":"en","title":"Internationalizing components","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-internationalization.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Internationalizing components"],"lvl1":["Default components keys","Internationalizing a configuration class"],"description":"How to implement internationalization with Talend Component Kit","keywords":"messages, internationalization, i18n","text":["In common cases, you can store messages using a properties file in your component module to use internationalization.","This properties file must be stored in the same package as the related components and named Messages. For example, org.talend.demo.MyComponent uses org.talend.demo.Messages[locale].properties.","This file already exists when you import a project generated from the starter.","Out of the box components are internationalized using the same location logic for the resource bundle. The supported keys are:","Name Pattern","Description","${family}._displayName","Display name of the family","${family}.${category}._category","Display name of the category ${category} in the family ${family}.","${family}.${configurationType}.${name}._displayName","Display name of a configuration type (dataStore or dataSet). Important: this key is read from the family package (not the class package), to unify the localization of the metadata.","${family}.actions.${actionType}.${actionName}._displayName","Display name of an action of the family. Specifying it is optional and will default on the action name if not set.","${family}.${component_name}._displayName","Display name of the component (used by the GUIs)","${property_path}._displayName","Display name of the option.","${property_path}._documentation","Equivalent to @Documentation(\"…\") but supporting internationalization (see Maven/Gradle documentation goal/task).","${property_path}._placeholder","Placeholder of the option.","${simple_class_name}.${property_name}._displayName","Display name of the option using its class name.","${simple_class_name}.${property_name}._documentation","See ${property_path}._documentation.","${simple_class_name}.${property_name}._placeholder","See ${property_path}._placeholder.","${enum_simple_class_name}.${enum_name}._displayName","Display name of the enum_name value of the enum_simple_class_name enumeration.","${property_path or simple_class_name}._gridlayout.${layout_name}._displayName","Display name of tab corresponding to the layout (tab). Note that this requires the server talend.component.server.gridlayout.translation.support option to be set to true and it is not yet supported by the Studio.","Example of configuration for a component named list and belonging to the memory family (@Emitter(family = \"memory\", name = \"list\")):","Configuration classes can be translated using the simple class name in the messages properties file. This is useful in case of common configurations shared by multiple components.","For example, if you have a configuration class as follows :","You can give it a translatable display name by adding ${simple_class_name}.${property_name}._displayName to Messages.properties under the same package as the configuration class.","If you have a display name using the property path, it overrides the display name defined using the simple class name. This rule also applies to placeholders."]},{"lang":"en","title":"Internationalizing services","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/services-internationalization.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Internationalizing services"],"lvl1":["Internationalization API"],"description":"How to internationalize a service using Talend Component Kit","keywords":"service, component-manager, internationalization, i18n, language, lang, locale","text":["Internationalization requires following several best practices:","Storing messages using ResourceBundle properties file in your component module.","The location of the properties is in the same package than the related components and is named Messages. For example, org.talend.demo.MyComponent uses org.talend.demo.Messages[locale].properties.","Use the internationalization API for your own messages.","The Internationalization API is the mechanism to use to internationalize your own messages in your own components.","The principle of the API is to design messages as methods returning String values and get back a template using a ResourceBundle named Messages and located in the same package than the interface that defines these methods.","To ensure your internationalization API is identified, you need to mark it with the @Internationalized annotation:","The corresponding Messages.properties placed in the org/superbiz resource folder contains the following:"]},{"lang":"en","title":"Iterating on component development with Talend Studio","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/studio.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Iterating on component development with Talend Studio"],"lvl1":["Version compatibility","Installing the components","Configuring the component server","Debugging your custom component in Talend Studio","Random port when running concurrent studio instances"],"lvl2":["Enabling the developer mode","Debugging the runtime or the Guess schema option of a component","Debugging UI actions and validations"],"description":"How to install and configure components developed with Talend Component Kit in Talend Open Studio","keywords":"component server, deploy, install, studio, studio-integration, car, car-bundler, version, component-server, debug","text":["Integrate components you developed using Talend Component Kit to Talend Studio in a few steps. Also learn how to enable the developer and debugging modes to iterate on your component development.","The version of Talend Component Kit you need to use to develop new components depends on the version of Talend Studio in which components will be integrated.","Refer to this document to learn about compatibility between Talend Component Kit and the different versions of Talend applications.","Learn how to build and deploy components to Talend Studio using Maven or Gradle Talend Component Kit plugins.","This can be done using the deploy-in-studio goal from your development environment.","If you are unfamiliar with component development, you can also follow this example to go through the entire process, from creating a project to using your new component in Talend Studio.","The Studio integration relies on the Component Server, that the Studio uses to gather data about components created using Talend Component Kit.","You can change the default configuration of component server by modifying the $STUDIO_HOME/configuration/config.ini file.","The following parameters are available:","Name","Description","Default","component.environment","Enables the developer mode when set to dev","-","component.debounce.timeout","Specifies the timeout (in milliseconds) before calling listeners in components Text fields","750","component.kit.skip","If set to true, the plugin is not enabled. It is useful if you don’t have any component developed with the framework.","false","component.java.arguments","Component server additional options","-","component.java.m2","Maven repository that the server uses to resolve components","Defaults to the global Studio configuration","component.java.coordinates","A list of comma-separated GAV (groupId:artifactId:version) of components to register","-","component.java.registry","A properties file with values matching component GAV (groupId:artifactId:version) registered at startup. Only use slashes (even on windows) in the path.","-","component.java.port","Sets the port to use for the server","random","components.server.beam.active","Active, if set to true, Beam support (Experimental). It requires Beam SDK Java core dependencies to be available.","false","component.server.jul.forceConsole","Adds a console handler to JUL to see logs in the console. This can be helpful in development because the formatting is clearer than the OSGi one in workspace/.metadata/.log.","It uses the java.util.logging.SimpleFormatter.format property to define its format. By default, it is %1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n, but for development purposes [%4$s] %5$s%6$s%n is simpler and more readable.","false","Here is an example of a common developer configuration/config.ini file:","The developer mode is especially useful to iterate on your component development and to avoid closing and restarting Talend Studio every time you make a change to a component. It adds a Talend Component Kit button in the main toolbar:","When clicking this button, all components developed with the Talend Component Kit framework are reloaded. The cache is invalidated and the components refreshed.","You still need to add and remove the components to see the changes.","To enable it, simply set the component.environment parameter to dev in the config.ini configuration file of the component server.","Several methods allow you to debug custom components created with Talend Component Kit in Talend Studio.","From your development tool, create a new Remote configuration, and copy the Command line arguments for running remote JVM field. For example, -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005, where:","the suspend parameter of the -agentlib argument specifies whether you want to suspend the debugged JVM until the debugger attaches to it. Possible values are n (no, default value) or y (yes).","the address parameter of the -agentlib argument is the port used for the remote configuration. Make sure this port is available.","Open Talend Studio.","Create a new Job that uses the component you want to debug or open an existing one that already uses it.","Go to the Run tab of the Job and select Use specific JVM arguments.","Click New to add an argument.","In the popup window, paste the arguments copied from the IDE.","Enter the corresponding debug mode:","To debug the runtime, run the Job and access the remote host configured in the IDE.","To debug the Guess schema option, click the Guess schema action button of the component and access the remote host configured in the IDE.","From your development tool, create a new Remote configuration, and copy the Command line arguments for running remote JVM field. For example, -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005, where:","suspend defines whether you need to access the defined configuration to run the remote JVM. Possible values are n (no, default value) or y (yes).","address is the port used for the remote configuration. Make sure this port is available.","Access the installation directory of your Talend Sutdio.","Open the .ini file corresponding to your Operating System. For example, TOS_DI-win-x86_64.ini.","Paste the arguments copied from the IDE in a new line of the file.","Go to Talend Studio to use the component, and access the host host configured in the IDE.","If you run multiple Studio instances automatically in parallel, you can run into some issues with the random port computation. For example on a CI platform. For that purpose, you can create the $HOME/.talend/locks/org.talend.sdk.component.studio-integration.lock file.","Then, when a server starts, it acquires a lock on that file and prevents another server to get a port until it is started. It ensures that you can’t have two concurrent processes getting the same port allocated.","However, it is highly unlikely to happen on a desktop. In that case, forcing a different value through component.java.port in your config.ini file is a better solution for local installations."]},{"lang":"en","title":"Knowledge base","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-knowledge-base.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Knowledge base"],"description":"Read advanced articles about Talend Component Kit","keywords":"advanced article","text":["Learn about the latest news or go deeper in the framework with the following articles.","Changelog","Creating plugins","Running Component Kit components on a Remote Engine"]},{"lang":"en","title":"Managing component versions and migration","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-versions-and-migration.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Managing component versions and migration"],"lvl1":["Difference between migrating a component configuration and a nested configuration"],"description":"How to handle component versions and migration","keywords":"migrationHandler, version, migration, backward compatibility, configuration, option, api","text":["If some changes impact the configuration, they can be managed through a migration handler at the component level (enabling trans-model migration support).","The @Version annotation supports a migrationHandler method which migrates the incoming configuration to the current model.","For example, if the filepath configuration entry from v1 changed to location in v2, you can remap the value in your MigrationHandler implementation.","A best practice is to split migrations into services that you can inject in the migration handler (through constructor) rather than managing all migrations directly in the handler. For example:","What is important to notice in this snippet is the fact that you can organize your migrations the way that best fits your component.","If you need to apply migrations in a specific order, make sure that they are sorted.","Consider this API as a migration callback rather than a migration API. Adjust the migration code structure you need behind the MigrationHandler, based on your component requirements, using service injection.","A nested configuration always migrates itself with any root prefix, whereas a component configuration always roots the full configuration. For example, if your model is the following:","Then the component will see the path configuration.datastore.url for the datastore url whereas the datastore will see the path url for the same property. You can see it as configuration types - @DataStore, @DataSet - being configured with an empty root path."]},{"lang":"en","title":"Masking sensitive data in your configuration","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-configuration-sensitive-data.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Masking sensitive data in your configuration"],"lvl1":["Marking sensitive data"],"description":"Learn how to mark sensitive data such as credentials when developing components using Talend Component Kit","keywords":"tutorial, example, credentials, password","text":["This tutorial shows how to correctly mask the sensitive data of a component configuration.","It is very common to define credentials when configuring a component. Most common cases can include passwords, secrets, keys (it is also common to show them in plain text in a textarea), and tokens.","For example, this REST client configuration specifies that a username, a password and a token are needed to connect to the REST API:","This configuration defines that these credentials are three simple String, represented as plain inputs, which causes severe security concerns:","The password and token are clearly readable in all Talend user interfaces (Studio or Web),","The password and token are potentially stored in clear.","To avoid this behavior, you need to mark sensitive data as @Credential.","Talend Component Kit provides you with the @Credential marker, that you can use on any @Option. This marker has two effects:","It Replaces the default input widget by a password oriented widget","It Requests the Studio or the Talend Cloud products to store the data as sensitive data (as encrypted values).","In order to ensure that the password and token are never stored in clear or shown in the code, add the @Credential marker to the sensitive data. For example:","Your password and token (or any other sensitive data that you need to mask) are not accessible by error anymore."]},{"lang":"en","title":"OpenAPI definition","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/rest-openapi-vault.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["OpenAPI definition"],"lvl3":["Component Server API"],"description":"Component Kit Vault Server OpenAPI Documentation","keywords":"Swagger, REST, API"},{"lang":"en","title":"OpenAPI definition","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/rest-openapi.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["OpenAPI definition"],"lvl3":["Component Server API"],"description":"Component Kit OpenAPI Documentation","keywords":"Swagger, REST, API, component-server"},{"lang":"en","title":"Providing actions for consumers","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/services-actions.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Providing actions for consumers"],"lvl1":["Particular action types","Internationalization"],"lvl2":["Close Connection","Create Connection","Discoverdataset","Dynamic Values","Healthcheck","Schema","Suggestions","Update","User","Validation","built_in_suggestable"],"lvl3":["Built In Actions"],"description":"How to define actions in a service","keywords":"service, component-manager, action, connection, discover, dynamic, healthcheck, schema, suggestions, validation, i18n, api","text":["In some cases you can need to add some actions that are not related to the runtime. For example, enabling users of the plugin/library to test if a connection works properly.","To do so, you need to define an @Action, which is a method with a name (representing the event name), in a class decorated with @Service:","Services are singleton. If you need some thread safety, make sure that they match that requirement. Services should not store any status either because they can be serialized at any time. Status are held by the component.","Services can be used in components as well (matched by type). They allow to reuse some shared logic, like a client. Here is a sample with a service used to access files:","The service is automatically passed to the constructor. It can be used as a bean. In that case, it is only necessary to call the service method.","Some common actions need a clear contract so they are defined as API first-class citizen. For example, this is the case for wizards or health checks. Here is the list of the available actions:","Mark an action works for closing runtime connection, returning a close helper object which do real close action. The functionality is for the Studio only, studio will use the close object to close connection for existed connection, and no effect for cloud platform.","Type: close_connection","API: @org.talend.sdk.component.api.service.connection.CloseConnection","Returned type: org.talend.sdk.component.api.service.connection.CloseConnectionObject","Sample:","Mark an action works for creating runtime connection, returning a runtime connection object like jdbc connection if database family. Its parameter MUST be a datastore. Datastore is configuration type annotated with @DataStore. The functionality is for the Studio only, studio will use the runtime connection object when use existed connection, and no effect for cloud platform.","Type: create_connection","API: @org.talend.sdk.component.api.service.connection.CreateConnection","This class marks an action that explore a connection to retrieve potential datasets.","Type: discoverdataset","API: @org.talend.sdk.component.api.service.discovery.DiscoverDataset","Returned type: org.talend.sdk.component.api.service.discovery.DiscoverDatasetResult","Sample:","Mark a method as being useful to fill potential values of a string option for a property denoted by its value. You can link a field as being completable using @Proposable(value). The resolution of the completion action is then done through the component family and value of the action. The callback doesn’t take any parameter.","Type: dynamic_values","API: @org.talend.sdk.component.api.service.completion.DynamicValues","Returned type: org.talend.sdk.component.api.service.completion.Values","Sample:","This class marks an action doing a connection test","Type: healthcheck","API: @org.talend.sdk.component.api.service.healthcheck.HealthCheck","Returned type: org.talend.sdk.component.api.service.healthcheck.HealthCheckStatus","Sample:","Mark an action as returning a discovered schema. Its parameter MUST be a dataset. Dataset is configuration type annotated with @DataSet. If component has multiple datasets, then dataset used as action parameter should have the same identifier as this @DiscoverSchema.","Type: schema","API: @org.talend.sdk.component.api.service.schema.DiscoverSchema","Returned type: org.talend.sdk.component.api.record.Schema","Sample:","Mark a method as being useful to fill potential values of a string option. You can link a field as being completable using @Suggestable(value). The resolution of the completion action is then done when the user requests it (generally by clicking on a button or entering the field depending the environment).","Type: suggestions","API: @org.talend.sdk.component.api.service.completion.Suggestions","Returned type: org.talend.sdk.component.api.service.completion.SuggestionValues","Sample:","This class marks an action returning a new instance replacing part of a form/configuration.","Type: update","API: @org.talend.sdk.component.api.service.update.Update","Extension point for custom UI integrations and custom actions.","Type: user","API: @org.talend.sdk.component.api.service.Action","Mark a method as being used to validate a configuration.","this is a server validation so only use it if you can’t use other client side validation to implement it.","Type: validation","API: @org.talend.sdk.component.api.service.asyncvalidation.AsyncValidation","Returned type: org.talend.sdk.component.api.service.asyncvalidation.ValidationResult","Sample:","These actions are provided - or not - by the application the UI runs within.","always ensure you don’t require this action in your component.","Mark the decorated field as supporting suggestions, i.e. dynamically get a list of valid values the user can use. It is however different from @Suggestable by looking up the implementation in the current application and not the services. Finally, it is important to note that it can do nothing in some environments too and that there is no guarantee the specified action is supported.","API: @org.talend.sdk.component.api.configuration.action.BuiltInSuggestable","Internationalization is supported through the injection of the $lang parameter, which allows you to get the correct locale to use with an @Internationalized service:","You can combine the $lang option with the @Internationalized and @Language parameters."]},{"lang":"en","title":"Record types","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/record-types.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Record types"],"lvl1":["Record","JsonObject","Pojo"],"lvl2":["Creating a record","Accessing and reading a record","Supported data types","Example: discovering a schema","Authorized characters in entry names","Data types in arrays"],"description":"How to modelize data processed or emitted by components.","keywords":"record, pojo, builder, factory, types, schema, discover, jsonObject, json, record-schema","text":["Components are designed to manipulate data (access, read, create). Talend Component Kit can handle several types of data, described in this document.","By design, the framework must run in DI (plain standalone Java program) and in Beam pipelines. It is out of scope of the framework to handle the way the runtime serializes - if needed - the data.","For that reason, it is critical not to import serialization constraints to the stack. As an example, this is one of the reasons why Record or JsonObject were preferred to Avro IndexedRecord.","Any serialization concern should either be hidden in the framework runtime (outside of the component developer scope) or in the runtime integration with the framework (for example, Beam integration).","Record is the default format. It offers many possibilities and can evolve depending on the Talend platform needs. Its structure is data-driven and exposes a schema that allows to browse it.","Projects generated from the Talend Component Kit Starter are by default designed to handle this format of data.","Record is a Java interface but never implement it yourself to ensure compatibility with the different Talend products. Follow the guidelines below.","You can build records using the newRecordBuilder method of the RecordBuilderFactory (see here).","For example:","In the example above, the schema is dynamically computed from the data. You can also do it using a pre-built schema, as follows:","The example above uses a schema that was pre-built using factory.newSchemaBuilder(Schema.Type.RECORD).","When using a pre-built schema, the entries passed to the record builder are validated. It means that if you pass a null value null or an entry type that does not match the provided schema, the record creation fails. It also fails if you try to add an entry which does not exist or if you did not set a not nullable entry.","Using a dynamic schema can be useful on the backend but can lead users to more issues when creating a pipeline to process the data. Using a pre-built schema is more reliable for end-users.","You can access and read data by relying on the getSchema method, which provides you with the available entries (columns) of a record. The Entry exposes the type of its value, which lets you access the value through the corresponding method. For example, the Schema.Type.STRING type implies using the getString method of the record.","For example:","The Record format supports the following data types:","String","Boolean","Int","Long","Float","Double","DateTime","Array","Bytes","Record","A map can always be modelized as a list (array of records with key and value entries).","For example:","For example, you can use the API to provide the schema. The following method needs to be implemented in a service.","Manually constructing the schema without any data:","Returning the schema from an already built record:","MyDataset is the class that defines the dataset. Learn more about datasets and datastores in this document.","Entry names for Record and JsonObject types must comply with the following rules:","The name must start with a letter or with _. If not, the invalid characters are ignored until the first valid character.","Following characters of the name must be a letter, a number, or . If not, the invalid character is replaced with .","For example:","1foo becomes foo.","f@o becomes f_o.","1234f5@o becomes ___f5_o.","foo123 stays foo123.","Each array uses only one schema for all of its elements. If an array contains several elements, they must be of the same data type.","For example, the following array is not correct as it contains a string and an object:","The runtime also supports JsonObject as input and output component type. You can rely on the JSON services (Jsonb, JsonBuilderFactory) to create new instances.","This format is close to the Record format, except that it does not natively support the Datetime type and has a unique Number type to represent Int, Long, Float and Double types. It also does not provide entry metadata like nullable or comment, for example.","It also inherits the Record format limitations.","The runtime also accepts any POJO as input and output component type. In this case, it uses JSON-B to treat it as a JsonObject."]},{"lang":"en","title":"Registering components","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/component-registering.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Registering components"],"lvl1":["Component family and categories","Component icon and version","Component extra metadatas"],"lvl2":["Defining a custom icon for a component or component family"],"description":"How to define component and component family metadata","keywords":"icon, component version, component name, family, category, metadata","text":["Before implementing a component logic and configuration, you need to specify the family and the category it belongs to, the component type and name, as well as its name and a few other generic parameters. This set of metadata, and more particularly the family, categories and component type, is mandatory to recognize and load the component to Talend Studio or Cloud applications.","Some of these parameters are handled at the project generation using the starter, but can still be accessed and updated later on.","The family and category of a component is automatically written in the package-info.java file of the component package, using the @Components annotation. By default, these parameters are already configured in this file when you import your project in your IDE. Their value correspond to what was defined during the project definition with the starter.","Multiple components can share the same family and category value, but the family + name pair must be unique for the system.","A component can belong to one family only and to one or several categories. If not specified, the category defaults to Misc.","The package-info.java file also defines the component family icon, which is different from the component icon. You can learn how to customize this icon in this section.","Here is a sample package-info.java:","Another example with an existing component:","Components can require metadata to be integrated in Talend Studio or Cloud platforms. Metadata is set on the component class and belongs to the org.talend.sdk.component.api.component package.","When you generate your project and import it in your IDE, icon and version both come with a default value.","@Icon: Sets an icon key used to represent the component. You can use a custom key with the custom() method but the icon may not be rendered properly. The icon defaults to Check. Replace it with a custom icon, as described in this section.","@Version: Sets the component version. 1 by default. Learn how to manage different versions and migrations between your component versions in this section.","For example:","Every component family and component needs to have a representative icon. You have to define a custom icon as follows:","For the component family the icon is defined in the package-info.java file.","For the component itself, you need to declare the icon in the component class.","Custom icons must comply with the following requirements:","Icons must be stored in the src/main/resources/icons folder of the project.","Icon file names need to match one of the following patterns: IconName.svg or IconName_icon32.png. The latter will run in degraded mode in Talend Cloud. Replace IconName by the name of your choice.","Icons must be squared, even for the SVG format.","Note that SVG icons are not supported by Talend Studio and can cause the deployment of the component to fail. If you aim at deploying a custom component to Talend Studio, specify PNG icons or use the Maven (or Gradle) svg2png plugin to convert SVG icons to PNG. If you want a finer control over both images, you can provide both in your component. Ultimately, you can also remove SVG parameters from the talend.component.server.icon.paths property in the HTTP server configuration.","Note that SVG icons are not supported by Talend Studio and can cause the deployment of the component to fail.","If you aim at deploying a custom component to Talend Studio, specify PNG icons or use the Maven (or Gradle) svg2png plugin to convert SVG icons to PNG. If you want a finer control over both images, you can provide both in your component.","Ultimately, you can also remove SVG parameters from the talend.component.server.icon.paths property in the HTTP server configuration.","For any purpose, you can also add user defined metadatas to your component with the @Metadatas annotation.","Example:","You can also use a SPI implementing org.talend.sdk.component.spi.component.ComponentMetadataEnricher.","Methodology for creating components","Generating a project using the starter","Managing component versions","Defining an input component","Defining a processor or output component","Defining a driver runner component","Defining component layout and configuration","Best practices"]},{"lang":"en","title":"Running Component Kit components on a Remote Engine","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/running-on-remote-engine.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Running Component Kit components on a Remote Engine"],"lvl1":["Remote Engine Customizer","Using the tool"],"description":"How to customize components for testing on a remote engine","keywords":"remote engine, docker, customizer, tool, car, car-bundler, test, testing, cloud, extension, custom","text":["The Remote Engine is a key piece for executing components with Talend Pipeline Designer. To customize it for testing purposes, a helper tool is available.","The following content and the tool it describes are not officially supported as a Talend Cloud feature and are provided \"as it\" without any guarantee.","The remote-engine-customizer is a simple tool that reads the Remote Engine docker-compose.yml file, extracts the connectors image and rebuilds it adding configured connectors to the image. By default, it replaces the original image with the newly built one and saves the old file in the .remote_engine_customizer/backup/ directory of the Remote Engine.","The customizer is provided as a docker container.","You can run the tool using the register-component-archive command:","You can get more details about the tool with the following command:","You can find out all the available versions at hub.docker.com/r/tacokit/remote-engine-customizer/tags.","The command accepts the following parameters:","When running using the docker container, you must mount several files/folders. For example:","Once you have built the new image, you must restart the Remote Engine. You can verify that the new image is available by running docker run --entrypoint sh -it [newimage] before."]},{"lang":"en","title":"Secrets/Passwords and Maven","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/testing-maven-passwords.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Secrets/Passwords and Maven"],"description":"Learn how to reuse Maven server files and credentials for testing purposes","keywords":"continuous integration, testing, password, maven, credentials","text":["You can reuse Maven settings.xml server files, including the encrypted ones. org.talend.sdk.component.maven.MavenDecrypter allows yo to find a username/password from a server identifier:","It is very useful to avoid storing secrets and to perform tests on real systems on a continuous integration platform.","Even if you do not use Maven on the platform, you can generate the settings.xml and`settings-security.xml` files to use that feature. See maven.apache.org/guides/mini/guide-encryption.html for more details."]},{"lang":"en","title":"Services and interceptors","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/services-interceptors.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Services and interceptors"],"description":"How to define an interceptor using Talend Component Kit services","keywords":"service, component-manager, interceptor","text":["For common concerns such as caching, auditing, and so on, you can use an interceptor-like API. It is enabled on services by the framework.","An interceptor defines an annotation marked with @Intercepts, which defines the implementation of the interceptor (InterceptorHandler).","For example:","The handler is created from its constructor and can take service injections (by type). The first parameter, however, can be BiFunction<Method, Object[], Object>, which represents the invocation chain if your interceptor can be used with others.","If you make a generic interceptor, pass the invoker as first parameter. Otherwise you cannot combine interceptors at all.","Here is an example of interceptor implementation for the @Logged API:","This implementation is compatible with interceptor chains because it takes the invoker as first constructor parameter and it also takes a service injection. Then, the implementation simply does what is needed, which is logging the invoked method in this case.","The findAnnotation annotation, inherited from InterceptorHandler, is an utility method to find an annotation on a method or class (in this order)."]},{"lang":"en","title":"Setting up your environment","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-setup-environment.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Setting up your environment"],"description":"Learn about the prerequisites and tools you need to install to develop components using Talend Component Kit","keywords":"install, installation, setup, requirements, tool","text":["Before being able to develop components using Talend Component Kit, you need the right system configuration and tools.","Although Talend Component Kit comes with some embedded tools, such as Maven and Gradle wrappers, you still need to prepare your system. A Talend Component Kit plugin for IntelliJ is also available and allows to design and generate your component project right from IntelliJ.","System requirements","Installing the IntelliJ plugin"]},{"lang":"en","title":"Singer Java","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/singer.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Singer Java"],"lvl1":["singer-java","component-kitap"],"lvl2":["Setup/Usage","Configuration"],"description":"Write a custom singer tap/target in Java","keywords":"singer, kitap, tap, target, stitch","text":["singer-java module provide a Java API to write a custom singer.","To import it, add the following dependency:","Then you have access to the Singer class and its companion which provides the primitives to output properly the data:","To build schema, keys, bookmarks, json and state which are all either JsonObject or JsonArray you can rely on JsonBuilderFactory which can be instantiated with this snippet:","component-kitap is the name of the integration between singer-java and Talend Component Kit. It enables to run native Talend Component Kit components through a tap.","The module relies on a proper setup of the component and classpath:","Classpath is well setup - composed of component-kitap with a default SLF4J binding configured to log only errors on stderr. For convenience, you can use the all in one bundle provided by the module: org.talend.sdk.component:component-kitapp:${kit.version}:fatjar.","Component is \"deployed\" - i.e. its maven repository is set provisionned with its dependencies. If you downloaded a component as a .car then you can run the car to do it. You can enforce the maven location through the system property talend.component.manager.m2.repository.","Regarding SLF4J, the fatjar uses slf4j-standard of the framework which enables to set the logged level to error through a system property: -Dorg.talend.sdk.component.slf4j.StdLogger.level=err.","To automatically register a component plugin/family you must add to the classpath a TALEND-INF/plugins.properties: The file only need to contain the registration of the plugin jar:","Therefore the launch command can look like:","Alternatively you can use org.talend.sdk.component.singer.kitap.Carpates main to launch the application, it differs from Kitap in the sense it takes a .car as option and avoids to pre-build the m2 repository:","Here is an example with a real component:","The config.json must respect this format:","in some environment, such a JSON is not desirable, it is possible to put component_config attribute as a string containing the full json (escaped indeed) too."]},{"lang":"en","title":"Studio schema","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/studio-schema.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Studio schema"],"lvl1":["Dynamic schema","Accessing columns metadata","Notes when designing an output connector"],"description":"How to access studio's schema in your component.","keywords":"studio, studio-integration, schema, metadata, dynamic, columns, output, sink, connector, record-schema","text":["Since the 1.1.25 release, the dynamic column feature is supported in Studio with component-runtime components.","Dynamic column is available with Enterprise versions of Talend Studio only.","In Studio, we can define for each component a schema with associated metadata.","To access those informations in your component, you’ve to do a few things:","Using the @Structure annotation","API: @org.talend.sdk.component.api.configuration.ui.widget.Structure","According the specified field type, you will acess to","the column names list with List<String>","a subset or all wanted metadata with List<MySchemaMeta> (see below)","Then, we should have a class SchemaInfo as following:","Defining a specific class for holding metadata If you don’t want just only column names (using List<String>), you’ll have to define a custom class.","Available Studio metadata informations","Field name","Type","Name in Studio","label","String","Column","originalDbColumnName","String","Db Column","key","Boolean","Key","type","String","DB Type","talendType","String","Type","nullable","Boolean","Nullable","pattern","String","Date Pattern","length","int","Length","precision","int","Precision","defaultValue","String","Default","comment","String","Comment","Available since 1.43.x release","As Talend Component Kit Schema's types aren’t matching all Studio types, we wrap those types in wider types (like Character or char wrapped into String, Short to Integer, and so on…).","Anyway, the original type coming from Studio’s IPersistableRow is stored in record’s schema properties under the property name talend.studio.type.","Studio managed types are: id_BigDecimal, id_Boolean, id_Byte, id_byte[], id_Character, id_Date, id_Double, id_Document, id_Dynamic, id_Float, id_Integer, id_List, id_Long, id_Object, id_Short, id_String.","When handling an output connector designed for Studio, you should have to check for this property to get an accurate type for output.","For instance, java.math.BigDecimal is handled in framework as a Type.STRING, so when an output connector will receive a record, in studio context, you’ll need to check for the property and cast it correctly.","Here is a simple processor before writing to backend destination:","This usage of properties is cumbersome but may fix some potential issues for now. We plan to widen managed types in Record and Schema in a few iterations (No ETA defined yet)."]},{"lang":"en","title":"System prerequisites","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/system-prerequisites.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["System prerequisites"],"description":"Get ready to develop components by setting up your environment with the right tools","keywords":"install, installation, tool","text":["In order to use Talend Component Kit, you need the following tools installed on your machine:","Java JDK 1.8.x. You can download it from Oracle website.","Talend Open Studio to integrate your components.","A Java Integrated Development Environment such as Eclipse or IntelliJ. IntelliJ is recommended as a Talend Component Kit plugin is available.","Optional: If you use IntelliJ, you can install the Talend Component Kit plugin for IntelliJ.","Optional: A build tool:","Apache Maven 3.5.4 is recommended to develop a component or the project itself. You can download it from Apache Maven website.","You can also use Gradle, but at the moment certain features are not supported, such as validations.","It is optional to install a build tool independently since Maven and Gradle wrappers are already available with Talend Component Kit."]},{"lang":"en","title":"Talend Component Kit Developer Reference Guide ::","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/search.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Search results"]},{"lang":"en","title":"Talend Component Kit Javadocs","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/apidocs.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Talend Component Kit Javadocs"],"description":"The list of API references related to Talend Component Kit.","keywords":"API, Talend Component Kit Javadoc, javadoc","text":["Refer to the following links to access the detailed API reference documentation:","API Documentation","JUnit API Documentation","HTTP JUnit API Documentation"]},{"lang":"en","title":"Talend Component Kit Overview","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tck-framework-overview.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Talend Component Kit Overview"],"lvl1":["Framework tools","Repositories"],"description":"Learn the basic concepts of the Talend Component Kit framework","keywords":"framework","text":["Talend Component Kit is a toolkit based on Java and designed to simplify the development of components at two levels:","Runtime: Runtime is about injecting the specific component code into a job or pipeline. The framework helps unify as much as possible the code required to run in Data Integration (DI) and BEAM environments.","Graphical interface: The framework helps unify the code required to be able to render the component in a browser (web) or in the Eclipse-based Studio (SWT).","The Talend Component Kit framework is made of several tools designed to help you during the component development process. It allows to develop components that fit in both Java web UIs.","Starter: Generate the skeleton of your development project using a user-friendly interface. The Talend Component Kit Starter is available as a web tool or as a plugin for the IntelliJ IDE.","","Component API: Check all classes available to implement components.","Build tools: The framework comes with Maven and Gradle wrappers, which allow to always use the version of Maven or Gradle that is right for your component development environment and version.","Testing tools: Test components before integrating them into Talend Studio or Cloud applications. Testing tools include the Talend Component Kit Web Tester, which allows to check the web UI of your components on your local machine.","","You can find more details about the framework design in this document.","The Talend Component Kit project is available on GitHub in the following repository"]},{"lang":"en","title":"Talend Component Kit best practices","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/best-practices.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Talend Component Kit best practices"],"lvl1":["Organizing your code","Configuring components","Handling UI interactions","Enforcing versioning on components","Testing components"],"lvl2":["Serializing your configuration","Input and output components","Processor components","Validations","Completion","Component representation"],"lvl3":["About actions","Limitations","Light validations","Custom validations"],"description":"List of best practices for developing Talend components.","keywords":"best practices, checklist","text":["Some recommendations apply to the way component packages are organized:","Make sure to create a package-info.java file with the component family/categories at the root of your component package:","Create a package for the configuration.","Create a package for the actions.","Create a package for the component and one sub-package by type of component (input, output, processors, and so on).","It is recommended to serialize your configuration in order to be able to pass it through other components.","When building a new component, the first step is to identify the way it must be configured.","The two main concepts are:","The DataStore which is the way you can access the backend.","The DataSet which is the way you interact with the backend.","For example:","Example description","DataStore","DataSet","Accessing a relational database like MySQL","JDBC driver, URL, username, password","Query to execute, row mapper, and so on.","Accessing a file system","File pattern (or directory + file extension/prefix/…)","File format, buffer size, and so on.","It is common to have the dataset including the datastore, because both are required to work. However, it is recommended to replace this pattern by defining both dataset and datastore in a higher level configuration model. For example:","Input and output components are particular because they can be linked to a set of actions. It is recommended to wire all the actions you can apply to ensure the consumers of your component can provide a rich experience to their users.","The most common actions are the following ones:","This action exposes a way to ensure the datastore/connection works.","Configuration example:","Action example:","Until the studio integration is complete, it is recommended to limit processors to one input.","Configuring processor components is simpler than configuring input and output components because it is specific for each component. For example, a mapper takes the mapping between the input and output models:","It is recommended to provide as much information as possible to let the UI work with the data during its edition.","Light validations are all the validations you can execute on the client side. They are listed in the UI hint section.","Use light validations first before going with custom validations because they are more efficient.","Custom validations enforce custom code to be executed, but are heavier to execute.","Prefer using light validations when possible.","Define an action with the parameters needed for the validation and link the option you want to validate to this action. For example, to validate a dataset for a JDBC driver:","You can also define a Validable class and use it to validate a form by setting it on your whole configuration:","The parameter binding of the validation method uses the same logic as the component configuration injection. Therefore, the @Option method specifies the prefix to use to reference a parameter. It is recommended to use @Option(\"value\") until you know exactly why you don’t use it. This way, the consumer can match the configuration model and just prefix it with value. to send the instance to validate.","Validations are triggers based on \"events\". If you mark part of a configuration as @Validable but this configuration is translated to a widget without any interaction, then no validation will happen. The rule of thumb is to mark only primitives and simple types (list of primitives) as @Validable.","It can be handy and user-friendly to provide completion on some fields. For example, to define completion for available drivers:","Each component must have its own icon:","You can use talend.surge.sh/icons/ to find the icon you want to use.","It is recommended to enforce the version of your component, event though it is not mandatory for the first version.","If you break a configuration entry in a later version; make sure to:","Upgrade the version.","Support a migration of the configuration.","Testing your components is critical. You can use unit and simple standalone JUnit tests, but it is also highly recommended to have Beam tests in order to make sure that your component works in Big Data."]},{"lang":"en","title":"Talend Component Kit design overview","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/framework_design.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Talend Component Kit design overview"],"lvl1":["Component API","Isolated","REST","Fixed set of icons"],"lvl2":["Evolutive","Static","Flexible data modeling","Consumable model","Execution with streaming"],"lvl3":["UI-friendly","Auditable and with clear expectations","Dev-friendly"],"text":["The component API is declarative (through annotations) to ensure it is:","Evolutive. It can get new features without breaking old code.","As static as possible.","Because it is fully declarative, any new API can be added iteratively without requiring any change to existing components.","For example, in the case of Beam potential evolution:","would not be affected by the addition of the new Timer API, which can be used as follows:","The intent of the framework is to be able to fit in a Java UI as well as in a web UI.","It must be understood as colocalized and remote UI. The goal is to move as much as possible the logic to the UI side for UI-related actions. For example, validating a pattern, a size, and so on, should be done on the client side rather than on the server side. Being static encourages this practice.","The other goal of being static in the API definition is to ensure that the model will not be mutated at runtime and that all the auditing and modeling can be done before, at the design phase.","Being static also ensures that the development can be validated as much as possible through build tools. This does not replace the requirement to test the components but helps developers to maintain components with automated tools.","Refer to this document.","The components must be able to execute even if they have conflicting libraries. For that purpose, classloaders must be isolated. A component defines its dependencies based on a Maven format and is always bound to its own classloader.","The definition payload is as flat as possible and strongly typed to ensure it can be manipulated by consumers. This way, consumers can add or remove fields with simple mapping rules, without any abstract tree handling.","The execution (runtime) configuration is the concatenation of framework metadata (only the version) and a key/value model of the instance of the configuration based on the definition properties paths for the keys. It enables consumers to maintain and work with the keys/values according to their need.","The framework not being responsible for any persistence, it is very important to make sure that consumers can handle it from end to end, with the ability to search for values (update a machine, update a port and so on) and keys (for example, a new encryption rule on key certificate).","Talend Component Kit is a metamodel provider (to build forms) and a runtime execution platform. It takes a configuration instance and uses it volatilely to execute a component logic. This implies it cannot own the data nor define the contract it has for these two endpoints and must let the consumers handle the data lifecycle (creation, encryption, deletion, and so on).","A new mime type called talend/stream is introduced to define a streaming format.","It matches a JSON object per line:","Icons (@Icon) are based on a fixed set. Custom icons can be used but their display cannot be guaranteed. Components can be used in any environment and require a consistent look that cannot be guaranteed outside of the UI itself. Defining keys only is the best way to communicate this information.","Once you know exactly how you will deploy your component in the Studio, then you can use `@Icon(value = CUSTOM, custom = \"…\") to use a custom icon file."]},{"lang":"en","title":"Talend Component Kit methodology","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/methodology-creating-components.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Talend Component Kit methodology"],"description":"Learn the main steps to build a custom component using Talend Component Kit","keywords":"get started, learn","text":["Developing new components using the Component Kit framework includes:","Creating a project using the starter or the Talend IntelliJ plugin. This step allows to build the skeleton of the project. It consists in:","Defining the general configuration model for each component in your project.","Generating and downloading the project archive from the starter.","Compiling the project.","Importing the compiled project in your IDE. This step is not required if you have generated the project using the IntelliJ plugin.","Implementing the components, including:","Registering the components by specifying their metadata: family, categories, version, icon, type and name.","Defining the layout and configurable part of the components.","Defining the execution logic of the components, also called runtime.","Testing the components.","Deploying the components to Talend Studio or Cloud applications.","Optionally, you can use services. Services are predefined or user-defined configurations that can be reused in several components.",""]},{"lang":"en","title":"Talend Input component for Hazelcast","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-create-an-input-component.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Talend Input component for Hazelcast"],"lvl1":["Creating the project","Registering the Hazelcast components family","Defining the Hazelcast component configuration","Introducing TCK services"],"lvl2":["Creating the package-info.java file","Creating the internationalization file","Providing the family icon","Datastore","Dataset","Source","Source implementation for Hazelcast","Testing the Source","Partition Mapper"],"lvl3":["Assessor","Split","Source","Emitter"],"description":"Example of input component implementation with Talend Component Kit","keywords":"tutorial, example, partition mapper, producer, source, hazelcast, distributed","text":["This tutorial walks you through the creation, from scratch, of a complete Talend input component for Hazelcast using the Talend Component Kit (TCK) framework.","Hazelcast is an in-memory distributed system that can store data, which makes it a good example of input component for distributed systems. This is enough for you to get started with this tutorial, but you can find more information about it here: hazelcast.org/.","A TCK project is a simple Java project with specific configurations and dependencies. You can choose your preferred build tool from Maven or Gradle as TCK supports both. In this tutorial, Maven is used.","The first step consists in generating the project structure using Talend Starter Toolkit .","Go to starter-toolkit.talend.io/ and fill in the project information as shown in the screenshots below, then click Finish and Download as ZIP.","image::tutorial_hazelcast_generateproject_1.png[] image::tutorial_hazelcast_generateproject_2.png[]","Extract the ZIP file into your workspace and import it to your preferred IDE. This tutorial uses Intellij IDE, but you can use Eclipse or any other IDE that you are comfortable with.","You can use the Starter Toolkit to define the full configuration of the component, but in this tutorial some parts are configured manually to explain key concepts of TCK.","The generated pom.xml file of the project looks as follows:","Change the name tag to a more relevant value, for example: <name>Component Hazelcast</name>.","The component-api dependency provides the necessary API to develop the components.","talend-component-maven-plugin provides build and validation tools for the component development.","The Java compiler also needs a Talend specific configuration for the components to work correctly. The most important is the -parameters option that preserves the parameter names needed for introspection features that TCK relies on.","Download the mvn dependencies declared in the pom.xml file:","You should get a BUILD SUCCESS at this point:","Create the project structure:","Create the component Java packages.","Packages are mandatory in the component model and you cannot use the default one (no package). It is recommended to create a unique package per component to be able to reuse it as dependency in other components, for example to guarantee isolation while writing unit tests.","The project is now correctly set up. The next steps consist in registering the component family and setting up some properties.","Registering every component family allows the component server to properly load the components and to ensure they are available in Talend Studio.","The family registration happens via a package-info.java file that you have to create.","Move to the src/main/java/org/talend/components/hazelcast package and create a package-info.java file:","@Components: Declares the family name and the categories to which the component belongs.","@Icon: Defines the component family icon. This icon is visible in the Studio metadata tree.","Talend Component Kit supports internationalization (i18n) via Java properties files. Using these files, you can customize and translate the display name of properties such as the name of a component family or, as shown later in this tutorial, labels displayed in the component configuration.","Go to src/main/resources/org/talend/components/hazelcast and create an i18n Messages.properties file as below:","You can define the component family icon in the package-info.java file. The icon image must exist in the resources/icons folder.","TCK supports both SVG and PNG formats for the icons.","Create the icons folder and add an icon image for the Hazelcast family.","This tutorial uses the Hazelcast icon from the official GitHub repository that you can get from: avatars3.githubusercontent.com/u/1453152?s=200&v=4","Download the image and rename it to Hazelcast_icon32.png. The name syntax is important and should match <Icon id from the package-info>_icon.32.png.","The component registration is now complete. The next step consists in defining the component configuration.","All Input and Output (I/O) components follow a predefined model of configuration. The configuration requires two parts:","Datastore: Defines all properties that let the component connect to the targeted system.","Dataset: Defines the data to be read or written from/to the targeted system.","Connecting to the Hazelcast cluster requires the IP address, group name and password of the targeted cluster.","In the component, the datastore is represented by a simple POJO.","Create a HazelcastDatastore.java class file in the src/main/java/org/talend/components/hazelcast folder.","Define the i18n properties of the datastore. In the Messages.properties file let add the following lines:","The Hazelcast datastore is now defined.","Hazelcast includes different types of datastores. You can manipulate maps, lists, sets, caches, locks, queues, topics and so on.","This tutorial focuses on maps but still applies to the other data structures.","Reading/writing from a map requires the map name.","Create the dataset class by creating a HazelcastDataset.java file in src/main/java/org/talend/components/hazelcast.","The @Dataset annotation marks the class as a dataset. Note that it also references a datastore, as required by the components model.","Just how it was done for the datastore, define the i18n properties of the dataset. To do that, add the following lines to the Messages.properties file.","The component configuration is now ready. The next step consists in creating the Source that will read the data from the Hazelcast map.","The Source is the class responsible for reading the data from the configured dataset.","A source gets the configuration instance injected by TCK at runtime and uses it to connect to the targeted system and read the data.","Create a new class as follows.","The source also needs i18n properties to provide a readable display name. Add the following line to the Messages.properties file.","At this point, it is already possible to see the result in the Talend Component Web Tester to check how the configuration looks like and validate the layout visually. To do that, execute the following command in the project folder.","This command starts the Component Web Tester and deploys the component there.","Access localhost:8080/.","The source is set up. It is now time to start creating some Hazelcast specific code to connect to a cluster and read values for a map.","Add the hazelcast-client Maven dependency to the pom.xml of the project, in the dependencies node.","Add a Hazelcast instance to the @PostConstruct method.","Declare a HazelcastInstance attribute in the source class.","Any non-serializable attribute needs to be marked as transient to avoid serialization issues.","Implement the post construct method.","The component configuration is mapped to the Hazelcast client configuration to create a Hazelcast instance. This instance will be used later to get the map from its name and read the map data. Only the required configuration in the component is exposed to keep the code as simple as possible.","Implement the code responsible for reading the data from the Hazelcast map through the Producer method.","The Producer implements the following logic:","Check if the map iterator is already initialized. If not, get the map from its name and initialize the map iterator. This is done in the @Producer method to ensure the map is initialized only if the next() method is called (lazy initialization). It also avoids the map initialization in the PostConstruct method as the Hazelcast map is not serializable.","All the objects initialized in the PostConstruct method need to be serializable as the source can be serialized and sent to another worker in a distributed cluster.","From the map, create an iterator on the map keys that will read from the map.","Transform every key/value pair into a Talend Record with a \"key, value\" object on every call to next().","The RecordBuilderFactory class used above is a built-in service in TCK injected via the Source constructor. This service is a factory to create Talend Records.","Now, the next() method will produce a Record every time it is called. The method will return \"null\" if there is no more data in the map.","Implement the @PreDestroy annotated method, responsible for releasing all resources used by the Source. The method needs to shut the Hazelcast client instance down to release any connection between the component and the Hazelcast cluster.","The Hazelcast Source is completed. The next section shows how to write a simple unit test to check that it works properly.","TCK provides a set of APIs and tools that makes the testing straightforward.","The test of the Hazelcast Source consists in creating an embedded Hazelcast instance with only one member and initializing it with some data, and then in creating a test Job to read the data from it using the implemented Source.","Add the required Maven test dependencies to the project.","Initialize a Hazelcast test instance and create a map with some test data. To do that, create the HazelcastSourceTest.java test class in the src/test/java folder. Create the folder if it does not exist.","The above example creates a Hazelcast instance for the test and creates the MY-DISTRIBUTED-MAP map. The getMap creates the map if it does not already exist. Some keys and values uses in the test are added. Then, a simple test checks that the data is correctly initialized. Finally, the Hazelcast test instance is shut down.","Run the test and check in the logs that a Hazelcast cluster of one member has been created and that the test has passed.","To be able to test components, TCK provides the @WithComponents annotation which enables component testing. Add this annotation to the test. The annotation takes the component Java package as a value parameter.","Create the test Job that configures the Hazelcast instance and link it to an output that collects the data produced by the Source.","Execute the unit test and check that it passes, meaning that the Source is reading the data correctly from Hazelcast.","The Source is now completed and tested. The next section shows how to implement the Partition Mapper for the Source. In this case, the Partition Mapper will split the work (data reading) between the available cluster members to distribute the workload.","The Partition Mapper calculates the number of Sources that can be created and executed in parallel on the available workers of a distributed system. For Hazelcast, it corresponds to the cluster member count.","To fully illustrate this concept, this section also shows how to enhance the test environment to add more Hazelcast cluster members and initialize it with more data.","Instantiate more Hazelcast instances, as every Hazelcast instance corresponds to one member in a cluster. In the test, it is reflected as follows:","The above code sample creates two Hazelcast instances, leading to the creation of two Hazelcast members. Having a cluster of two members (nodes) will allow to distribute the data. The above code also adds more data to the test map and updates the shutdown method and the test.","Run the test on the multi-nodes cluster.","The Source is a simple implementation that does not distribute the workload and reads the data in a classic way, without distributing the read action to different cluster members.","Start implementing the Partition Mapper class by creating a HazelcastPartitionMapper.java class file.","When coupling a Partition Mapper with a Source, the Partition Mapper becomes responsible for injecting parameters and creating source instances. This way, all the attribute initialization part moves from the Source to the Partition Mapper class.","The configuration also sets an instance name to make it easy to find the client instance in the logs or while debugging.","The Partition Mapper class is composed of the following:","constructor: Handles configuration and service injections","Assessor: This annotation indicates that the method is responsible for assessing the dataset size. The underlying runner uses the estimated dataset size to compute the optimal bundle size to distribute the workload efficiently.","Split: This annotation indicates that the method is responsible for creating Partition Mapper instances based on the bundle size requested by the underlying runner and the size of the dataset. It creates as much partitions as possible to parallelize and distribute the workload efficiently on the available workers (known as members in the Hazelcast case).","Emitter: This annotation indicates that the method is responsible for creating the Source instance with an adapted configuration allowing to handle the amount of records it will produce and the required services. I adapts the configuration to let the Source read only the requested bundle of data.","The Assessor method computes the memory size of every member of the cluster. Implementing it requires submitting a calculation task to the members through a serializable task that is aware of the Hazelcast instance.","Create the serializable task.","The purpose of this class is to submit any task to the Hazelcast cluster.","Use the created task to estimate the dataset size in the Assessor method.","The Assessor method calculates the memory size that the map occupies for all members. In Hazelcast, distributing a task to all members can be achieved using an execution service initialized in the getExecutorService() method. The size of the map is requested on every available member. By summing up the results, the total size of the map in the distributed cluster is computed.","The Split method calculates the heap size of the map on every member of the cluster. Then, it calculates how many members a source can handle.","If a member contains less data than the requested bundle size, the method tries to combine it with another member. That combination can only happen if the combined data size is still less or equal to the requested bundle size.","The following code illustrates the logic described above.","The next step consists in adapting the source to take the Split into account.","The following sample shows how to adapt the Source to the Split carried out previously.","The next method reads the data from the members received from the Partition Mapper.","A Big Data runner like Spark will get multiple Source instances. Every source instance will be responsible for reading data from a specific set of members already calculated by the Partition Mapper.","The data is fetched only when the next method is called. This logic allows to stream the data from members without loading it all into the memory.","Implement the method annotated with @Emitter in the HazelcastPartitionMapper class.","The createSource() method creates the source instance and passes the required services and the selected Hazelcast members to the source instance.","Run the test and check that it works as intended.","The component implementation is now done. It is able to read data and to distribute the workload to available members in a Big Data execution environment.","Refactor the component by introducing a service to make some pieces of code reusable and avoid code duplication.","Refactor the Hazelcast instance creation into a service.","Inject this service to the Partition Mapper to reuse it.","Adapt the Source class to reuse the service.","Run the test one last time to ensure everything still works as expected.","Thank you for following this tutorial. Use the logic and approach presented here to create any input component for any system."]},{"lang":"en","title":"Testing a REST API","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-test-rest-api.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Testing a REST API"],"lvl1":["Creating the unit test","Transforming the unit test into a mocked test"],"description":"Learn how to test a component that consumes a REST API through this tutorial","keywords":"tutorial, example, REST API, zendesk, test, testing","text":["Testing code that consumes REST APIs can sometimes present many constraints: API rate limit, authentication token and password sharing, API availability, sandbox expiration, API costs, and so on.","As a developer, it becomes critical to avoid those constraints and to be able to easily mock the API response.","The component framework provides an API simulation tool that makes it easy to write unit tests.","This tutorial shows how to use this tool in unit tests. As a starting point, the tutorial uses the component that consumes Zendesk Search API and that was created in a previous tutorial. The goal is to add unit tests for it.","For this tutorial, four tickets that have the open status have been added to the Zendesk test instance used in the tests.","To learn more about the testing methodology used in this tutorial, refer to Component JUnit testing.","Create a unit test that performs a real HTTP request to the Zendesk Search API instance. You can learn how to create a simple unit test in this tutorial.","the authentication configuration using Zendesk instance URL and credentials.","the search query configuration to get all the open ticket, ordered by creation date and sorted in descending order.","The test is now complete and working. It performs a real HTTP request to the Zendesk instance.","As an alternative, you can use mock results to avoid performing HTTP requests every time on the development environment. The real HTTP requests would, for example, only be performed on an integration environment.","To transform the unit test into a mocked test that uses a mocked response of the Zendesk Search API:","Add the two following JUnit rules provided by the component framework.","JUnit4HttpApi: This rule starts a simulation server that acts as a proxy and catches all the HTTP requests performed in the tests. This simulation server has two modes :","capture : This mode forwards the captured HTTP request to the real server and captures the response.","simulation : this mode returns a mocked response from the responses already captured. This rule needs to be added as a class rule.","JUnit4HttpApi: This rule has a reference to the first rule. Its role is to configure the simulation server for every unit test. It passes the context of the running test to the simulation server. This rule needs to be added as a simple (method) rule.","Example to run in a simulation mode:","Make the test run in capture mode to catch the real API responses that can be used later in the simulated mode. To do that, set a new talend.junit.http.capture environment variable to true. This tells the simulation server to run in a capture mode.","The captured response is saved in the resources/talend.testing.http package in a JSON format, then reused to perform the API simulation."]},{"lang":"en","title":"Testing a component","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-test-your-components.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Testing a component"],"description":"Example of input component testing using Talend Component Kit","keywords":"tutorial, example, test, hazelcast, testing","text":["This tutorial focuses on writing unit tests for the input component that was created in this previous tutorial.","This tutorial covers:","How to load components in a unit test.","How to create a job pipeline.","How to run the test in standalone mode.","The test class is as follows:"]},{"lang":"en","title":"Testing best practices","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/testing-best-practices.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Testing best practices"],"lvl1":["Parameterized tests"],"lvl2":["JUnit 4","JUnit 5"],"description":"Learn the best practices for testing components developed with Talend Component Kit","keywords":"test, best practices, testing","text":["This section mainly concerns tools that can be used with JUnit. You can use most of these best practices with TestNG as well.","Parameterized tests are a great solution to repeat the same test multiple times. This method of testing requires defining a test scenario (I test function F) and making the input/output data dynamic.","Here is a test example, which validates a connection URI using ConnectionService:","The testing method is always the same. Only values are changing. It can therefore be rewritten using JUnit Parameterized runner, as follows:","You don’t have to define a single @Test method. If you define multiple methods, each of them is executed with all the data. For example, if another test is added to the previous example, four tests are executed - 2 per data).","With JUnit 5, parameterized tests are easier to use. The full documentation is available at junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests.","The main difference with JUnit 4 is that you can also define inline that the test method is a parameterized test as well as the values to use:","However, you can still use the previous behavior with a method binding configuration:","This last option allows you to inject any type of value - not only primitives - which is common to define scenarios.","Add the junit-jupiter-params dependency to benefit from this feature."]},{"lang":"en","title":"Testing components","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-testing-components.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Testing components"],"description":"Learn how to test your component logic in the environment you need using Talend Component Kit","keywords":"test, overview, environment, beam, runtime, testing","text":["Developing new components includes testing them in the required execution environments. Use the following articles to learn about the best practices and the available options to fully test your components.","Component testing best practices","Component testing kit","Beam testing","Testing in multiple environments","Reusing Maven credentials","Generating data for testing","Simple/Test Pipeline API","Beam Pipeline API"]},{"lang":"en","title":"Testing in a Continuous Integration environment","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/tutorial-dev-vs-ci-setup.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Testing in a Continuous Integration environment"],"lvl1":["Setting up credentials","Adapting the unit test","Setting up the CI server in passthrough mode"],"description":"Learn how to test components in a continuous integration environment","keywords":"tutorial, example, test, CI, continuous integration, testing","text":["This tutorial shows how to adapt the test configuration of the Zendesk search component that was done in this previous tutorial to make it work in a Continuous Integration environment.","In the test, the Zendesk credentials are used directly in the code to perform a first capture of the API response. Then, fake credentials are used in the simulation mode because the real API is not called anymore.","However, in some cases, you can require to continue calling the real API on a CI server or on a specific environment.","To do that, you can adapt the test to get the credentials depending on the execution mode (simulation/passthrough).","These instructions concern the CI server or on any environment that requires real credentials.","This tutorial uses:","A Maven server that supports password encryption as a credential provider. Encryption is optional but recommended.","The MavenDecrypterRule test rule provided by the framework. This rule lets you get credentials from Maven settings using a server ID.","To create encrypted server credentials for the Zendesk instance:","Create a master password using the command: mvn --encrypt-master-password <password>.","Store this master password in the settings-security.xml file of the ~/.m2 folder.","Encrypt the Zendesk instance password using the command: mvn --encrypt-password <zendesk-password>.","Create a server entry under servers in Maven settings.xml file located in the ~/.m2 folder.","You can store the settings-security.xml and settings.xml files elsewhere that the default location (~/.m2). To do that, set the path of the directory containing the files in the talend.maven.decrypter.m2.location environment variable.","Add the MavenDecrypterRule rule to the test class. This rule allows to inject server information stored in Maven settings.xml file to the test. The rule also decrypts credentials if they are encrypted.","Inject the Zendesk server to the test. To do that, add a new field to the class with the @DecryptedServer annotation, that holds the server ID to be injected.","The MavenDecrypterRule is able to inject the server instance into this class at runtime. The server instance contains the username and the decrypted password.","Use the server instance in the test to get the real credentials in a secured manner.","Once modified, the complete test class looks as follows:","This test will continue to work in simulation mode, because the API simulation proxy is activated.","This tutorial shows how to set up a CI server in passthrough mode using Jenkins.","Log in to Jenkins.","Click New Item to create a new build job.","Enter an Item name (Job name) and choose the freestyle job. Then click OK.","In the Source Code Management section, enter your project repository URL. A GitHub repository is used in this tutorial.","Specify the master branch as Branches to build.","In the Build section, click Add build step and choose Invoke top-level Maven targets.","Choose your Maven version and enter the Maven build command. In this case: clean install. Then, click Save.","The -Dtalend.junit.http.passthrough=true option is part of the build command. This option tells the API simulation proxy to run in passthrough mode. This way, all the HTTP requests made in the test are forwarded to the real API server.","The MavenDecrypterRule rule allows to get the real credentials.","You can configure the passthrough mode globally on your CI server by setting the talend.junit.http.passthrough environment variable to true.","Test the job by selecting Build now, and check that the job has built correctly.","Now your tests run in a simulation mode on your development environment and in a passthrough mode on your CI server."]},{"lang":"en","title":"Testing on multiple environments","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/testing-multiple-envs.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Testing on multiple environments"],"lvl1":["JUnit 4","JUnit 5","Provided environments","Configuring environments"],"lvl2":["Advanced usage"],"description":"Learn how to test components on multiple environments with Talend Component Kit","keywords":"test, Junit, Beam, testing","text":["JUnit (4 or 5) already provides ways to parameterize tests and execute the same \"test logic\" against several sets of data. However, it is not very convenient for testing multiple environments.","For example, with Beam, you can test your code against multiple runners. But it requires resolving conflicts between runner dependencies, setting the correct classloaders, and so on.","To simplify such cases, the framework provides you a multi-environment support for your tests, through the JUnit module, which works with both JUnit 4 and JUnit 5.","The MultiEnvironmentsRunner executes the tests for each defined environments. With the example above, it means that it runs test1 for Env1 and Env2.","By default, the JUnit4 runner is used to execute the tests in one environment, but you can use @DelegateRunWith to use another runner.","The multi-environment configuration with JUnit 5 is similar to JUnit 4:","The main differences are that no runner is used because they do not exist in JUnit 5, and that you need to replace @Test by @EnvironmentalTest.","With JUnit5, tests are executed one after another for all environments, while tests are ran sequentially in each environments with JUnit 4. For example, this means that @BeforeAll and @AfterAll are executed once for all runners.","The provided environment sets the contextual classloader in order to load the related runner of Apache Beam.","Package: org.talend.sdk.component.junit.environment.builtin.beam","the configuration is read from system properties, environment variables, ….","_class: ContextualEnvironment.","_class: DirectRunnerEnvironment.","_class: FlinkRunnerEnvironment.","_class: SparkRunnerEnvironment.","If the environment extends BaseEnvironmentProvider and therefore defines an environment name - which is the case of the default ones - you can use EnvironmentConfiguration to customize the system properties used for that environment:","If you set the <environment name>.skip system property to true, the environment-related executions are skipped.","This usage assumes that Beam 2.4.0 or later is used.","The following dependencies bring the JUnit testing toolkit, the Beam integration and the multi-environment testing toolkit for JUnit into the test scope.","Dependencies:","Using the fluent DSL to define jobs, you can write a test as follows:","Your job must be linear and each step must send a single value (no multi-input or multi-output).","It executes the chain twice:","With a standalone environment to simulate the Studio.","With a Beam (direct runner) environment to ensure the portability of your job."]},{"lang":"en","title":"Tutorials","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-tutorials.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Tutorials"],"lvl1":["Creation tutorials","Testing tutorials"],"description":"Guided implementation examples to get your hands on Talend Component Kit","keywords":"tutorial, example, implement, test, dev, testing","text":["The following tutorials are designed to help you understand the main principles of component development using Talend Component Kit.","With this set of tutorials, get your hands on project creation using the Component Kit Starter and implement the logic of different types of components.","Creating your first component","Generating a project from the starter","Creating a Hazelcast input component","Creating a Hazelcast output component","Creating a Zendesk REST API connector","Handling component version migration","With this set of tutorials, learn the different approaches to test the components created in the previous tutorials.","Testing a Zendesk REST API connector","Testing a Hazelcast component","Testing in a continuous integration environment"]},{"lang":"en","title":"Version compatibility","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/compatibility.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Version compatibility"],"lvl1":["Compatibility matrix","Changing the Talend Component Kit version of your project"],"description":"Learn which version of Talend Component Kit you can use for your components to be compatible with the right version of your Talend applications.","keywords":"versions, Studio, studio-integration, Cloud, compatibility","text":["You can integrate and start using components developed using Talend Component Kit in Talend applications very easily.","As both the development framework and Talend applications evolve over time, you need to ensure compatibility between the components you develop and the versions of Talend applications that you are targeting, by making sure that you use the right version of Talend Component Kit.","The version of Talend Component Kit you need to use to develop new components depends on the versions of the Talend applications in which these components will be integrated.","Talend product","Talend Component Kit version","Talend Studio 8.8.8 (aka master)","latest release","Talend Studio 8.0.1","latest release QA approved","Talend Studio 7.3.1","Framework until 1.38.x","Talend Studio 7.2.1","Framework until 1.1.10","Talend Studio 7.1.1","Framework until 1.1.1","Talend Studio 7.0.1","Framework until 0.0.5","Talend Cloud","latest release QA and cloud teams approved","More recent versions of Talend Component Kit contain many fixes, improvements and features that help developing your components. However, they can cause some compatibility issues when deploying these components to older/different versions of Talend Studio and Talend Cloud. Choose the version of Talend Component Kit that best fits your needs.","Creating a project using the Component Kit Starter always uses the latest release of Talend Component Kit.","However, you can manually change the version of Talend Component Kit directly in the generated project.","Go to your IDE and access the project root .pom file.","Look for the org.talend.sdk.component dependency nodes.","Replace the version in the relevant nodes with the version that you need to use for your project.","You can use a Snapshot of the version under development using the -SNAPSHOT version and Sonatype snapshot repository."]},{"lang":"en","title":"Wall of Fame","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/contributors.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Wall of Fame"],"lvl2":["Romain Manni-Bucau","#2548 commits","Emmanuel GALLOIS","#532 commits","Florent LB","#218 commits","Ivan Gonchar","#195 commits","clesaec","#69 commits","Jean-Michel FRANCOIS","#59 commits","ypiel","#37 commits","Chao MENG","#23 commits","Chen Bin","#9 commits","Jimmy Somsanith","Colm O hEigeartaigh","#8 commits","Ismaël Mejía","#4 commits","Oleksandr Zhelezniak","Axel MAUMONT","#3 commits","wang wei","pyzhou","chmyga","lcelton-talend","#2 commits","C⁠‌⁠⁠‌﻿⁠‍‌‌‍‌yprien Q⁠‌⁠⁠‌﻿⁠‍‌‌‍‌uilici","Zoltán Takács","Zhiwei Xue","#1 commit","Etienne Chauchot","Benoit Guillon","sgandon","François Violette","Aurélien Leboulanger","Gabriel Marquet","Pierre Teyssier","Stéphane Kermabon","Roman","Jad Darrous"],"description":"Heroes of Talend Component Kit.","keywords":"contributor, github, profile, developper, gravatar, commit","text":["Apache addict I'm involved in several project (OpenWebBeans, Johnzon, Geronimo, Meecrowave, ... - http://home.apache.org/committer-index.html#rmannibucau). Blog: https://rmannibucau.metawerx.net","Software engineer @Talend. Components team member. Blog: undx.github.io","Technical Writer","","","Frontend Architect","","R&D","","Frontend Architect. This is my Talend account. You can check out @jsomsanith for my personal account","Senior principal software engineer at @Talend, security contributor at @apache. Blog: http://coheigea.blogspot.com/","Committer and PMC member of Apache Beam and Apache Avro. Free education and Open Source enthusiast. Distributed Systems practitioner (victim?) Blog: https://ismaelmejia.com/","","","","Templar","","","I'm a serial tooler.","Blog: https://www.linkedin.com/in/zoltantakacsdev/","","Focused on Big Data technologies. I contribute to open source projects. I'm an Apache Beam committer and PMC member and an Apache Software Foundation member Blog: https://echauchot.blogspot.com/","","Senior Cloud Software Architect","Product Manager, Information Architect","","","Blog: www.talend.com","573PH4N3 D3M15 K3RM480N","",""]},{"lang":"en","title":"Widget and validation gallery","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/gallery.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Widget and validation gallery"],"lvl1":["Widgets","Validations"],"lvl2":["Input/Text","Password","Textarea","Integer","Checkbox","Datetime","List","Suggestions","Table","Code","Schema","Property validation","Property validation with Pattern","Data store validation"],"description":"Sample screenshots of the Talend Component Kit available widgets and validation methods","keywords":"Widget, validation, service","text":["This gallery shows how widgets and validations are rendered in both Studio and web environments, along with sample implementation code.","You can also find sample working components for each of the configuration cases below:","ActiveIf: Add visibility conditions on some configurations.","Checkbox: Add checkboxes or toggles to your component.","Code: Allow users to enter their own code.","Credential: Mark a configuration as sensitive data to avoid displaying it as plain text.","Datastore: Add a button allowing to check the connection to a datastore.","Datalist: Two ways of implementing a dropdown list with predefined choices.","Integer: Add numeric fields to your component configuration.","Min/Max: Specify a minimum or a maximum value for a numeric configuration.","Multiselect: Add a list and allow users to select multiple elements of that list.","Pattern: Enforce rules based on a specific a pattern to prevent users from entering invalid values.","Required: Make a configuration mandatory.","Suggestions: Suggest possible values in a field based on what the users are entering.","Table: Add a table to your component configuration.","Textarea: Add a text area for configurations expecting long texts or values.","Input: Add a simple text input field to the component configuration","Update: Provide a button allowing to fill a part of the component configuration based on a service.","Validation: Specify constraints to make sure that a URL is well formed.","Widgets allow to easily implement different types of input fields to your components.","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Datetime fields rely on the Java Date Time API, including LocalTime, LocalDate, LocalDateTime and ZonedDateTime classes.","Studio Rendering","Web Rendering","or","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Validations help restricting what can be entered or selected in an input field, to make sure that the value complies with the expected type of information.","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","Studio Rendering","Web Rendering","You can also use other types of validation that are similar to @Pattern:","@Min, @Max to specify a minimum and maximum value for numerical fields.","@Uniques for collection values.","@Required for a required configuration."]},{"lang":"en","title":"Wrapping a Beam I/O","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/wrapping-a-beam-io.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["Wrapping a Beam I/O"],"lvl1":["Limitations","Wrapping an input","Wrapping an output","Tip","Advanced"],"lvl2":["Coder","JsonObject to IndexedRecord","Record coder","Sample"],"description":"Learn how to wrap Beam inputs and outputs","keywords":"Beam, input, output","text":["This part is limited to specific kinds of Beam PTransform:","PTransform<PBegin, PCollection<?>> for inputs.","PTransform<PCollection<?>, PDone> for outputs. Outputs must use a single (composite or not) DoFn in their apply method.","To illustrate the input wrapping, this procedure uses the following input as a starting point (based on existing Beam inputs):","To wrap the Read in a framework component, create a transform delegating to that Read with at least a @PartitionMapper annotation and using @Option constructor injections to configure the component. Also make sure to follow the best practices and to specify @Icon and @Version.","To illustrate the output wrapping, this procedure uses the following output as a starting point (based on existing Beam outputs):","You can wrap this output exactly the same way you wrap an input, but using @Processor instead of:","Note that the org.talend.sdk.component.runtime.beam.transform.DelegatingTransform class fully delegates the \"expansion\" to another transform. Therefore, you can extend it and implement the configuration mapping:","In terms of classloading, when you write an I/O, the Beam SDK Java core stack is assumed as provided in Talend Component Kit runtime. This way, you don’t need to include it in the compile scope, it would be ignored anyway.","If you need a JSonCoder, you can use the org.talend.sdk.component.runtime.beam.factory.service.PluginCoderFactory service, which gives you access to the JSON-P and JSON-B coders.","There is also an Avro coder, which uses the FileContainer. It ensures it is self-contained for IndexedRecord and it does not require—as the default Apache Beam AvroCoder—to set the schema when creating a pipeline. It consumes more space and therefore is slightly slower, but it is fine for DoFn, since it does not rely on serialization in most cases. See org.talend.sdk.component.runtime.beam.transform.avro.IndexedRecordCoder.","If your PCollection is made of JsonObject records, and you want to convert them to IndexedRecord, you can use the following PTransforms:","converts an IndexedRecord to a JsonObject.","converts a JsonObject to an IndexedRecord.","converts a JsonObject to an IndexedRecord with AVRO schema inference.","There are two main provided coder for Record:","it will unwrap the record as an Avro IndexedRecord and serialize it with its schema. This can indeed have a performance impact but, due to the structure of component, it will not impact the runtime performance in general - except with direct runner - because the runners will optimize the pipeline accurately.","it will serialize the Avro IndexedRecord as well but it will ensure the schema is in the SchemaRegistry to be able to deserialize it when needed. This implementation is faster but the default implementation of the registry is \"in memory\" so will only work with a single worker node. You can extend it using Java SPI mecanism to use a custom distributed implementation.","Sample input based on Beam Kafka:","Because the Beam wrapper does not respect the standard Talend Component Kit programming model ( for example, there is no @Emitter), you need to set the <talend.validation.component>false</talend.validation.component> property in your pom.xml file (or equivalent for Gradle) to skip the component programming model validations of the framework."]},{"lang":"en","title":"component-runtime-testing","version":"1.44.0","url":"https://talend.github.io/component-runtime/main/1.44.0/index-sub-testing-runtime.html","date":"2022-04-29T11:28:18Z","timestamp":1651231698636,"lvl0":["component-runtime-testing"],"lvl1":["component-runtime-junit","component-runtime-testing-spark","component-runtime-http-junit"],"lvl2":["JUnit 4","JUnit 5","Streaming components","Mocking the output","Mocking the input","Creating runtime configuration from component configuration","Testing a Mapper","Testing a Processor","Checking the job execution status","Capturing mode","Passthrough mode","JUnit 5 and capture names"],"lvl3":["SSL","Query Parameters"],"description":"Testing component logic using Talend Component Kit tooling","keywords":"runtime, testing, JUnit, Spark, HTTP, testing","text":["component-runtime-junit is a test library that allows you to validate simple logic based on the Talend Component Kit tooling.","To import it, add the following dependency to your project:","This dependency also provides mocked components that you can use with your own component to create tests.","The mocked components are provided under the test family:","emitter : a mock of an input component","collector : a mock of an output component","The collector is \"per thread\" by default. If you are executing a Beam (or concurrent) job, it will not work. To switch to a JVM wide storage, set the talend.component.junit.handler.state system property to static (default being thread). You can do it in a maven-surefire-plugin execution.","You can define a standard JUnit test and use the SimpleComponentRule rule:","The rule can also be defined as a @ClassRule to start it once per class and not per test as with @Rule.","To go further, you can add the ServiceInjectionRule rule, which allows to inject all the component family services into the test class by marking test class fields with @Service:","The JUnit 5 integration is very similar to JUnit 4, except that it uses the JUnit 5 extension mechanism.","The entry point is the @WithComponents annotation that you add to your test class, and which takes the component package you want to test. You can use @Injected to inject an instance of ComponentsHandler - which exposes the same utilities than the JUnit 4 rule - in a test class field :","If you use JUnit 5 for the first time, keep in mind that the imports changed and that you need to use org.junit.jupiter.api.Test instead of org.junit.Test. Some IDE versions and surefire versions can also require you to install either a plugin or a specific configuration.","As for JUnit 4, you can go further by injecting test class fields marked with @Service, but there is no additional extension to specify in this case:","Streaming components have the issue to not stop by design. The Job DSL exposes two properties to help with that issue:","streaming.maxRecords: enables to request a maximum number of records","streaming.maxDurationMs: enables to request a maximum duration for the execution of the input","You can set them as properties on the job:","Using the test://collector component as shown in the previous sample stores all records emitted by the chain (typically your source) in memory. You can then access them using theSimpleComponentRule.getCollectedData(type).","Note that this method filters by type. If you don’t need any specific type, you can use Object.class.","The input mocking is symmetric to the output. In this case, you provide the data you want to inject:","The component configuration is a POJO (using @Option on fields) and the runtime configuration (ExecutionChainBuilder) uses a Map<String, String>. To make the conversion easier, the JUnit integration provides a SimpleFactory.configurationByExample utility to get this map instance from a configuration instance.","Example:","The same factory provides a fluent DSL to create the configuration by calling configurationByExample without any parameter. The advantage is to be able to convert an object as a Map<String, String> or as a query string in order to use it with the Job DSL:","It handles the encoding of the URI to ensure it is correctly done.","When writing tests for your components, you can force the maxBatchSize parameter value by setting it with the following syntax: $configuration.$maxBatchSize=10.","The SimpleComponentRule also allows to test a mapper unitarily. You can get an instance from a configuration and execute this instance to collect the output.","Example:","As for a mapper, a processor is testable unitary. However, this case can be more complex in case of multiple inputs or outputs.","Example:","The rule allows you to instantiate a Processor from your code, and then to collect the output from the inputs you pass in. There are two convenient implementations of the input factory:","MainInputFactory for processors using only the default input.","JoinInputfactory with the withInput(branch, data) method for processors using multiple inputs. The first argument is the branch name and the second argument is the data used by the branch.","If needed, you can also implement your own input representation using org.talend.sdk.component.junit.ControllableInputFactory.","The following artifact allows you to test against a Spark cluster:","The testing relies on a JUnit TestRule. It is recommended to use it as a @ClassRule, to make sure that a single instance of a Spark cluster is built. You can also use it as a simple @Rule, to create the Spark cluster instances per method instead of per test class.","The @ClassRule takes the Spark and Scala versions to use as parameters. It then forks a master and N slaves. Finally, the submit* method allows you to send jobs either from the test classpath or from a shade if you run it as an integration test.","For example:","This testing methodology works with @Parameterized. You can submit several jobs with different arguments and even combine it with Beam TestPipeline if you make it transient.","The integration of that Spark cluster logic with JUnit 5 is done using the @WithSpark marker for the extension. Optionally, it allows you to inject—through @SparkInject—the BaseSpark<?> handler to access the Spark cluster meta information. For example, its host/port.","Example:","Currently, SparkClusterRule does not allow to know when a job execution is done, even by exposing and polling the web UI URL to check. The best solution at the moment is to make sure that the output of your job exists and contains the right value.","awaitability or any equivalent library can help you to implement such logic:","To wait until a file exists and check that its content (for example) is the expected one, you can use the following logic:","The HTTP JUnit module allows you to mock REST API very simply. The module coordinates are:","This module uses Apache Johnzon and Netty. If you have any conflict (in particular with Netty), you can add the shaded classifier to the dependency. This way, both dependencies are shaded, which avoids conflicts with your component.","It supports both JUnit 4 and JUnit 5. The concept is the exact same one: the extension/rule is able to serve precomputed responses saved in the classpath.","You can plug your own ResponseLocator to map a request to a response, but the default implementation - which should be sufficient in most cases - looks in talend/testing/http/<class name>_<method name>.json. Note that you can also put it in talend/testing/http/<request path>.json.","JUnit 4 setup is done through two rules:","JUnit4HttpApi, which is starts the server.","JUnit4HttpApiPerMethodConfigurator, which configures the server per test and also handles the capture mode.","If you don’t use the JUnit4HttpApiPerMethodConfigurator, the capture feature is disabled and the per test mocking is not available.","For tests using SSL-based services, you need to use activeSsl() on the JUnit4HttpApi rule.","You can access the client SSL socket factory through the API handler:","Sometimes the query parameters are sensitive and you don’t want to store them when capturing. In such cases, you can drop them from the captured data (.json) and the mock implementation will be able to match the request ignoring the query parameters.","JUnit 5 uses a JUnit 5 extension based on the HttpApi annotation that you can add to your test class. You can inject the test handler - which has some utilities for advanced cases - through @HttpApiInject:","The injection is optional and the @HttpApi annotation allows you to configure several test behaviors.","For tests using SSL-based services, you need to use @HttpApi(useSsl = true).","You can access the client SSL socket factory through the API handler:","The strength of this implementation is to run a small proxy server and to auto-configure the JVM: http[s].proxyHost, http[s].proxyPort, HttpsURLConnection#defaultSSLSocketFactory and SSLContext#default are auto-configured to work out-of-the-box with the proxy.","It allows you to keep the native and real URLs in your tests. For example, the following test is valid:","If you execute this test, it fails with an HTTP 400 error because the proxy does not find the mocked response. You can create it manually, as described in component-runtime-http-junit, but you can also set the talend.junit.http.capture property to the folder storing the captures. It must be the root folder and not the folder where the JSON files are located (not prefixed by talend/testing/http by default).","In most cases, use src/test/resources. If new File(\"src/test/resources\") resolves the valid folder when executing your test (Maven default), then you can just set the system property to true. Otherwise, you need to adjust accordingly the system property value.","When set to false, the capture is enabled. Instead, captures are saved in a false/ directory.","When the tests run with this system property, the testing framework creates the correct mock response files. After that, you can remove the system property. The tests will still pass, using google.com, even if you disconnect your machine from the Internet.","If you set the talend.junit.http.passthrough system property to true, the server acts as a proxy and executes each request to the actual server - similarly to the capturing mode.","With its @ParameterizedTest, you can want to customize the name of the output file for JUnit 5 based captures/mocks. Concretely you want to ensure the replay of the same method with different data lead to different mock files. By default the framework will use the display name of the test to specialize it but it is not always very friendly. If you want some more advanced control over the name you can use @HttpApiName(\"myCapture.json\") on the test method. To parameterize the name using @HttpApiName, you can use the placeholders ${class} and ${method} which represents the declaring class and method name, and ${displayName} which represents the method name.","Here is an example to use the same capture file for all repeated test:","And here, the same example but using different files for each repetition:"]}]